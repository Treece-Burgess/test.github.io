<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SLATE: slate::Tile&lt; scalar_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
// see https://stackoverflow.com/questions/40270302/latex-newcommand-in-doxgygen-html-output
// see http://docs.mathjax.org/en/latest/tex.html#defining-tex-macros
MathJax.Hub.Config({
    TeX: {
        Macros: {
            abs: ["\\left| #1 \\right|", 1],
            norm: ["\\left\\lVert #1 \\right\\rVert", 1],
        }
    }
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SLATE<span id="projectnumber">&#160;2023.08.25</span>
   </div>
   <div id="projectbrief">Software for Linear Algebra Targeting Exascale</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classslate_1_1_tile.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classslate_1_1_tile-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">slate::Tile&lt; scalar_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a> holding an mb-by-nb matrix, with leading dimension (stride).  
 <a href="classslate_1_1_tile.html#details">More...</a></p>

<p><code>#include &lt;Tile.hh&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad933ff6c81392b56bedbdc9294a955dd"><td class="memItemLeft" align="right" valign="top"><a id="ad933ff6c81392b56bedbdc9294a955dd" name="ad933ff6c81392b56bedbdc9294a955dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Tile</b> ()</td></tr>
<tr class="memdesc:ad933ff6c81392b56bedbdc9294a955dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create empty tile. <br /></td></tr>
<tr class="separator:ad933ff6c81392b56bedbdc9294a955dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99b1567e982ee50a714e1d7e813eeb2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#ae99b1567e982ee50a714e1d7e813eeb2">Tile</a> (int64_t <a class="el" href="classslate_1_1_tile.html#a1ad68995cc606f7ee11c4a75495c231c">mb</a>, int64_t <a class="el" href="classslate_1_1_tile.html#a6ad54b71912d39f828fcf7f6c10a6d42">nb</a>, scalar_t *A, int64_t lda, int <a class="el" href="classslate_1_1_tile.html#a4c5f3cce8983c90e578ca432341107cc">device</a>, <a class="el" href="group__enum.html#ga119c7d48492946c3c016fa8df49d6b01">TileKind</a> kind, Layout layout=Layout::ColMajor)</td></tr>
<tr class="memdesc:ae99b1567e982ee50a714e1d7e813eeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create tile that wraps existing memory buffer.  <br /></td></tr>
<tr class="separator:ae99b1567e982ee50a714e1d7e813eeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e68bf9b069c5fd14602a4da1e8cb3a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#a63e68bf9b069c5fd14602a4da1e8cb3a">Tile</a> (<a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; src_tile, scalar_t *A, int64_t lda, <a class="el" href="group__enum.html#ga119c7d48492946c3c016fa8df49d6b01">TileKind</a> kind)</td></tr>
<tr class="memdesc:a63e68bf9b069c5fd14602a4da1e8cb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create tile based on an existing tile and use existing memory buffer.  <br /></td></tr>
<tr class="separator:a63e68bf9b069c5fd14602a4da1e8cb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab833d9a7b9c2a606f7240ae1f0c0d7dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#ab833d9a7b9c2a606f7240ae1f0c0d7dc">copyData</a> (<a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; *dst_tile, blas::Queue &amp;queue, bool async=false) const</td></tr>
<tr class="memdesc:ab833d9a7b9c2a606f7240ae1f0c0d7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from this tile to dst_tile.  <br /></td></tr>
<tr class="separator:ab833d9a7b9c2a606f7240ae1f0c0d7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c31dbf131fa90c78dedf44df696e4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#aa5c31dbf131fa90c78dedf44df696e4a">copyData</a> (<a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; *dst_tile) const</td></tr>
<tr class="memdesc:aa5c31dbf131fa90c78dedf44df696e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies this tile's data to dst_tile data, both assumed on host  <br /></td></tr>
<tr class="separator:aa5c31dbf131fa90c78dedf44df696e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefa9107c4fbd69e7bc3df70af930dbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#afefa9107c4fbd69e7bc3df70af930dbc">send</a> (int dst, MPI_Comm mpi_comm, int tag=0) const</td></tr>
<tr class="memdesc:afefa9107c4fbd69e7bc3df70af930dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends tile to MPI rank dst.  <br /></td></tr>
<tr class="separator:afefa9107c4fbd69e7bc3df70af930dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946f0e8bfbf7caad818e9d253f08afbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#a946f0e8bfbf7caad818e9d253f08afbd">isend</a> (int dst, MPI_Comm mpi_comm, int tag, MPI_Request *req)</td></tr>
<tr class="memdesc:a946f0e8bfbf7caad818e9d253f08afbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends tile to MPI rank dst.  <br /></td></tr>
<tr class="separator:a946f0e8bfbf7caad818e9d253f08afbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e99f32f7ad33fad788d40ddc3402ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#a28e99f32f7ad33fad788d40ddc3402ab">recv</a> (int src, MPI_Comm mpi_comm, Layout layout, int tag=0)</td></tr>
<tr class="memdesc:a28e99f32f7ad33fad788d40ddc3402ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives tile from MPI rank src.  <br /></td></tr>
<tr class="separator:a28e99f32f7ad33fad788d40ddc3402ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de5523746ae626fd22017262ee8a957"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#a0de5523746ae626fd22017262ee8a957">bcast</a> (int bcast_root, MPI_Comm mpi_comm)</td></tr>
<tr class="memdesc:a0de5523746ae626fd22017262ee8a957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts tile from MPI rank bcast_root, using given communicator.  <br /></td></tr>
<tr class="separator:a0de5523746ae626fd22017262ee8a957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad68995cc606f7ee11c4a75495c231c"><td class="memItemLeft" align="right" valign="top"><a id="a1ad68995cc606f7ee11c4a75495c231c" name="a1ad68995cc606f7ee11c4a75495c231c"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>mb</b> () const</td></tr>
<tr class="memdesc:a1ad68995cc606f7ee11c4a75495c231c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of rows of op(A), where A is this tile. <br /></td></tr>
<tr class="separator:a1ad68995cc606f7ee11c4a75495c231c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad54b71912d39f828fcf7f6c10a6d42"><td class="memItemLeft" align="right" valign="top"><a id="a6ad54b71912d39f828fcf7f6c10a6d42" name="a6ad54b71912d39f828fcf7f6c10a6d42"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>nb</b> () const</td></tr>
<tr class="memdesc:a6ad54b71912d39f828fcf7f6c10a6d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of cols of op(A), where A is this tile. <br /></td></tr>
<tr class="separator:a6ad54b71912d39f828fcf7f6c10a6d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada445c9363f166b9f143768e5a449f1a"><td class="memItemLeft" align="right" valign="top"><a id="ada445c9363f166b9f143768e5a449f1a" name="ada445c9363f166b9f143768e5a449f1a"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>stride</b> () const</td></tr>
<tr class="memdesc:ada445c9363f166b9f143768e5a449f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns column stride of this tile. <br /></td></tr>
<tr class="separator:ada445c9363f166b9f143768e5a449f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bb8283db14ec3845299a4ce998b2bf"><td class="memItemLeft" align="right" valign="top"><a id="a19bb8283db14ec3845299a4ce998b2bf" name="a19bb8283db14ec3845299a4ce998b2bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>stride</b> (int64_t in_stride)</td></tr>
<tr class="memdesc:a19bb8283db14ec3845299a4ce998b2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets column stride of this tile. <br /></td></tr>
<tr class="separator:a19bb8283db14ec3845299a4ce998b2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d92597fb180e7409fa77cf52cc698e"><td class="memItemLeft" align="right" valign="top"><a id="ae6d92597fb180e7409fa77cf52cc698e" name="ae6d92597fb180e7409fa77cf52cc698e"></a>
scalar_t const *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const</td></tr>
<tr class="memdesc:ae6d92597fb180e7409fa77cf52cc698e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const pointer to data, i.e., A(0,0), where A is this tile. <br /></td></tr>
<tr class="separator:ae6d92597fb180e7409fa77cf52cc698e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1eb20d7e7b201223ca6e5028034b77"><td class="memItemLeft" align="right" valign="top"><a id="a9a1eb20d7e7b201223ca6e5028034b77" name="a9a1eb20d7e7b201223ca6e5028034b77"></a>
scalar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> ()</td></tr>
<tr class="memdesc:a9a1eb20d7e7b201223ca6e5028034b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to data, i.e., A(0,0), where A is this tile. <br /></td></tr>
<tr class="separator:a9a1eb20d7e7b201223ca6e5028034b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fb7d5524840ca5aa300be286cbf2d3"><td class="memItemLeft" align="right" valign="top">scalar_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#ab1fb7d5524840ca5aa300be286cbf2d3">operator()</a> (int64_t i, int64_t j) const</td></tr>
<tr class="memdesc:ab1fb7d5524840ca5aa300be286cbf2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns element {i, j} of op(A).  <br /></td></tr>
<tr class="separator:ab1fb7d5524840ca5aa300be286cbf2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33073ed0335d865e6121cc33e8381ef"><td class="memItemLeft" align="right" valign="top">scalar_t const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#ab33073ed0335d865e6121cc33e8381ef">at</a> (int64_t i, int64_t j) const</td></tr>
<tr class="memdesc:ab33073ed0335d865e6121cc33e8381ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to element {i, j} of op(A).  <br /></td></tr>
<tr class="separator:ab33073ed0335d865e6121cc33e8381ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cd17ad328c2c09505cf4ff17bd1dc0"><td class="memItemLeft" align="right" valign="top">scalar_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#a61cd17ad328c2c09505cf4ff17bd1dc0">at</a> (int64_t i, int64_t j)</td></tr>
<tr class="memdesc:a61cd17ad328c2c09505cf4ff17bd1dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to element {i, j} of op(A).  <br /></td></tr>
<tr class="separator:a61cd17ad328c2c09505cf4ff17bd1dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81cea1015a640b9969dca07f873fcdd"><td class="memItemLeft" align="right" valign="top"><a id="ab81cea1015a640b9969dca07f873fcdd" name="ab81cea1015a640b9969dca07f873fcdd"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>rowIncrement</b> () const</td></tr>
<tr class="memdesc:ab81cea1015a640b9969dca07f873fcdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements to increment to get to the next element in the row, accounting for row-or-column major layout and transposed tiles. <br /></td></tr>
<tr class="separator:ab81cea1015a640b9969dca07f873fcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4df96913e08a0ef5d3583b3faf1b1b"><td class="memItemLeft" align="right" valign="top"><a id="a2f4df96913e08a0ef5d3583b3faf1b1b" name="a2f4df96913e08a0ef5d3583b3faf1b1b"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>colIncrement</b> () const</td></tr>
<tr class="memdesc:a2f4df96913e08a0ef5d3583b3faf1b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements to increment to get to the next element in the column, accounting for row-or-column major layout and transposed tiles. <br /></td></tr>
<tr class="separator:a2f4df96913e08a0ef5d3583b3faf1b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5acecf74a3c22c051d250c2175e778"><td class="memItemLeft" align="right" valign="top"><a id="a6b5acecf74a3c22c051d250c2175e778" name="a6b5acecf74a3c22c051d250c2175e778"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>origin</b> () const</td></tr>
<tr class="memdesc:a6b5acecf74a3c22c051d250c2175e778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is an origin (local non-workspace) tile. <br /></td></tr>
<tr class="separator:a6b5acecf74a3c22c051d250c2175e778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab048a84eb312e5b4fe39441daecf18ba"><td class="memItemLeft" align="right" valign="top"><a id="ab048a84eb312e5b4fe39441daecf18ba" name="ab048a84eb312e5b4fe39441daecf18ba"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>workspace</b> () const</td></tr>
<tr class="memdesc:ab048a84eb312e5b4fe39441daecf18ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is a workspace tile. <br /></td></tr>
<tr class="separator:ab048a84eb312e5b4fe39441daecf18ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a2e206e3db0fe59e370d28c4880b46"><td class="memItemLeft" align="right" valign="top"><a id="a82a2e206e3db0fe59e370d28c4880b46" name="a82a2e206e3db0fe59e370d28c4880b46"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>allocated</b> () const</td></tr>
<tr class="memdesc:a82a2e206e3db0fe59e370d28c4880b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if SLATE allocated this tile's memory, false if the user provided the tile's memory, e.g., via a fromScaLAPACK constructor. <br /></td></tr>
<tr class="separator:a82a2e206e3db0fe59e370d28c4880b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ad00890fc13b693eb660a05437fc3e"><td class="memItemLeft" align="right" valign="top"><a id="a74ad00890fc13b693eb660a05437fc3e" name="a74ad00890fc13b693eb660a05437fc3e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>bytes</b> () const</td></tr>
<tr class="memdesc:a74ad00890fc13b693eb660a05437fc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of bytes; but NOT consecutive if stride != mb_. <br /></td></tr>
<tr class="separator:a74ad00890fc13b693eb660a05437fc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0568f74e9af8c9da1cfd9eea722974f2"><td class="memItemLeft" align="right" valign="top"><a id="a0568f74e9af8c9da1cfd9eea722974f2" name="a0568f74e9af8c9da1cfd9eea722974f2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="memdesc:a0568f74e9af8c9da1cfd9eea722974f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of elements; but NOT consecutive if stride != mb_. <br /></td></tr>
<tr class="separator:a0568f74e9af8c9da1cfd9eea722974f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d95f849f51748f4fc746eb53682a290"><td class="memItemLeft" align="right" valign="top"><a id="a0d95f849f51748f4fc746eb53682a290" name="a0d95f849f51748f4fc746eb53682a290"></a>
Uplo&#160;</td><td class="memItemRight" valign="bottom"><b>uplo</b> () const</td></tr>
<tr class="memdesc:a0d95f849f51748f4fc746eb53682a290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether op(A) is logically Lower, Upper, or General storage. <br /></td></tr>
<tr class="separator:a0d95f849f51748f4fc746eb53682a290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6f48dcc5289507e6fb4b0f0f792645"><td class="memItemLeft" align="right" valign="top">Uplo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#ada6f48dcc5289507e6fb4b0f0f792645">uploLogical</a> () const</td></tr>
<tr class="memdesc:ada6f48dcc5289507e6fb4b0f0f792645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether op(A) is logically Upper, Lower, or General storage, taking the transposition operation into account.  <br /></td></tr>
<tr class="separator:ada6f48dcc5289507e6fb4b0f0f792645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ddd325e43eb7a2e183f17e4b5d4f88"><td class="memItemLeft" align="right" valign="top">Uplo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#a41ddd325e43eb7a2e183f17e4b5d4f88">uploPhysical</a> () const</td></tr>
<tr class="memdesc:a41ddd325e43eb7a2e183f17e4b5d4f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether A is Upper, Lower, or General storage, ignoring the transposition operation.  <br /></td></tr>
<tr class="separator:a41ddd325e43eb7a2e183f17e4b5d4f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65446fb5ba29de9ec1d7316c17d7d09d"><td class="memItemLeft" align="right" valign="top">Uplo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#a65446fb5ba29de9ec1d7316c17d7d09d">uplo_logical</a> () const</td></tr>
<tr class="separator:a65446fb5ba29de9ec1d7316c17d7d09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9302adb2bee20f5932d39adaefd4a5b9"><td class="memItemLeft" align="right" valign="top"><a id="a9302adb2bee20f5932d39adaefd4a5b9" name="a9302adb2bee20f5932d39adaefd4a5b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>uplo</b> (Uplo uplo)</td></tr>
<tr class="memdesc:a9302adb2bee20f5932d39adaefd4a5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets upper, lower, or general storage flag. <br /></td></tr>
<tr class="separator:a9302adb2bee20f5932d39adaefd4a5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16263f1b4ad9b52c96f22a2c032f56d"><td class="memItemLeft" align="right" valign="top"><a id="ac16263f1b4ad9b52c96f22a2c032f56d" name="ac16263f1b4ad9b52c96f22a2c032f56d"></a>
Op&#160;</td><td class="memItemRight" valign="bottom"><b>op</b> () const</td></tr>
<tr class="memdesc:ac16263f1b4ad9b52c96f22a2c032f56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns transposition operation. <br /></td></tr>
<tr class="separator:ac16263f1b4ad9b52c96f22a2c032f56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf161fab2d7c73ff05df1a308e4da318"><td class="memItemLeft" align="right" valign="top"><a id="acf161fab2d7c73ff05df1a308e4da318" name="acf161fab2d7c73ff05df1a308e4da318"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>op</b> (Op op)</td></tr>
<tr class="memdesc:acf161fab2d7c73ff05df1a308e4da318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets transposition operation. <br /></td></tr>
<tr class="separator:acf161fab2d7c73ff05df1a308e4da318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5f3cce8983c90e578ca432341107cc"><td class="memItemLeft" align="right" valign="top"><a id="a4c5f3cce8983c90e578ca432341107cc" name="a4c5f3cce8983c90e578ca432341107cc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>device</b> () const</td></tr>
<tr class="memdesc:a4c5f3cce8983c90e578ca432341107cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns which host or GPU device tile's data is located on. <br /></td></tr>
<tr class="separator:a4c5f3cce8983c90e578ca432341107cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15249f6937b5081c01932b94671428a"><td class="memItemLeft" align="right" valign="top"><a id="ad15249f6937b5081c01932b94671428a" name="ad15249f6937b5081c01932b94671428a"></a>
Layout&#160;</td><td class="memItemRight" valign="bottom"><b>layout</b> () const</td></tr>
<tr class="separator:ad15249f6937b5081c01932b94671428a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2d2967438022174a60c64fbb5b2bc4"><td class="memItemLeft" align="right" valign="top"><a id="a2d2d2967438022174a60c64fbb5b2bc4" name="a2d2d2967438022174a60c64fbb5b2bc4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>layout</b> (Layout in_layout)</td></tr>
<tr class="separator:a2d2d2967438022174a60c64fbb5b2bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3705214c2a36585edf524608434ecc95"><td class="memItemLeft" align="right" valign="top"><a id="a3705214c2a36585edf524608434ecc95" name="a3705214c2a36585edf524608434ecc95"></a>
Layout&#160;</td><td class="memItemRight" valign="bottom"><b>userLayout</b> () const</td></tr>
<tr class="separator:a3705214c2a36585edf524608434ecc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3833d3a31ed57f0960058aa0b9851bfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#a3833d3a31ed57f0960058aa0b9851bfb">set</a> (scalar_t alpha)</td></tr>
<tr class="memdesc:a3833d3a31ed57f0960058aa0b9851bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set tile data to constant.  <br /></td></tr>
<tr class="separator:a3833d3a31ed57f0960058aa0b9851bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5c6b65517ee88801d9411069c20e90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#a8f5c6b65517ee88801d9411069c20e90">set</a> (scalar_t alpha, scalar_t beta)</td></tr>
<tr class="memdesc:a8f5c6b65517ee88801d9411069c20e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set tile data to constants.  <br /></td></tr>
<tr class="separator:a8f5c6b65517ee88801d9411069c20e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc0824c523baeb6daf690ef36d92b92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#afcc0824c523baeb6daf690ef36d92b92">isContiguous</a> () const</td></tr>
<tr class="separator:afcc0824c523baeb6daf690ef36d92b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c81f340db0150ddda87b59de66b686"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#aa0c81f340db0150ddda87b59de66b686">isTransposable</a> ()</td></tr>
<tr class="memdesc:aa0c81f340db0150ddda87b59de66b686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this tile can safely store its data in transposed form based on its 'TileKind', buffer size, Layout, and stride.  <br /></td></tr>
<tr class="separator:aa0c81f340db0150ddda87b59de66b686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adf724ea7ec1ab24c58737484539893"><td class="memItemLeft" align="right" valign="top"><a id="a0adf724ea7ec1ab24c58737484539893" name="a0adf724ea7ec1ab24c58737484539893"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>makeTransposable</b> (scalar_t *<a class="el" href="classslate_1_1_tile.html#ae6d92597fb180e7409fa77cf52cc698e">data</a>)</td></tr>
<tr class="memdesc:a0adf724ea7ec1ab24c58737484539893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches the new_data buffer to this tile as an extended buffer extended buffer to be used to hold the transposed data of rectangular tiles Marks the tile as extended NOTE: does not set the front buffer to be the extended one NOTE: throws error if not already transposable. <br /></td></tr>
<tr class="separator:a0adf724ea7ec1ab24c58737484539893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75fcb87cdd7e972f1fc6d88cf701f92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#aa75fcb87cdd7e972f1fc6d88cf701f92">layoutReset</a> ()</td></tr>
<tr class="memdesc:aa75fcb87cdd7e972f1fc6d88cf701f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the tile's member fields related to being extended.  <br /></td></tr>
<tr class="separator:aa75fcb87cdd7e972f1fc6d88cf701f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab82961ca82d5effaeced9c74aab7222"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#aab82961ca82d5effaeced9c74aab7222">extended</a> () const</td></tr>
<tr class="separator:aab82961ca82d5effaeced9c74aab7222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b8cb460aa0a4b3be9921fd903914f6"><td class="memItemLeft" align="right" valign="top">scalar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#a83b8cb460aa0a4b3be9921fd903914f6">extData</a> ()</td></tr>
<tr class="separator:a83b8cb460aa0a4b3be9921fd903914f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3db11511149388406129d80a2ba6ada"><td class="memItemLeft" align="right" valign="top">scalar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#ab3db11511149388406129d80a2ba6ada">userData</a> ()</td></tr>
<tr class="separator:ab3db11511149388406129d80a2ba6ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b8b64e88cbdd91852cd68b1c719c1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#a69b8b64e88cbdd91852cd68b1c719c1a">layoutSetFrontDataExt</a> (bool front=true)</td></tr>
<tr class="memdesc:a69b8b64e88cbdd91852cd68b1c719c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the front buffer of the extended tile, and adjusts stride accordingly.  <br /></td></tr>
<tr class="separator:a69b8b64e88cbdd91852cd68b1c719c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430f64b5697e14f659b0abb5ea1399c2"><td class="memItemLeft" align="right" valign="top">scalar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#a430f64b5697e14f659b0abb5ea1399c2">layoutBackData</a> ()</td></tr>
<tr class="separator:a430f64b5697e14f659b0abb5ea1399c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08569a09ce8dcf2f5cecd4a0d97a45f"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#ac08569a09ce8dcf2f5cecd4a0d97a45f">layoutBackStride</a> () const</td></tr>
<tr class="separator:ac08569a09ce8dcf2f5cecd4a0d97a45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5edc17fb9696f7aeb036168bd57b40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#aaa5edc17fb9696f7aeb036168bd57b40">layoutConvert</a> (scalar_t *work_data=nullptr)</td></tr>
<tr class="memdesc:aaa5edc17fb9696f7aeb036168bd57b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert layout (Column / Row major) of this tile (host CPU implementation).  <br /></td></tr>
<tr class="separator:aaa5edc17fb9696f7aeb036168bd57b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa824da88519c7860d07e74c599832bf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#aa824da88519c7860d07e74c599832bf2">layoutConvert</a> (scalar_t *work_data, blas::Queue &amp;queue, bool async=false)</td></tr>
<tr class="memdesc:aa824da88519c7860d07e74c599832bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert layout (Column / Row major) of this tile (device GPU implementation).  <br /></td></tr>
<tr class="separator:aa824da88519c7860d07e74c599832bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3888bad27f93b0409d486cacdb306e9a"><td class="memItemLeft" align="right" valign="top"><a id="a3888bad27f93b0409d486cacdb306e9a" name="a3888bad27f93b0409d486cacdb306e9a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>layoutConvert</b> (blas::Queue &amp;queue, bool async=false)</td></tr>
<tr class="memdesc:a3888bad27f93b0409d486cacdb306e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload with work_data = nullptr. <br /></td></tr>
<tr class="separator:a3888bad27f93b0409d486cacdb306e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a50239afa6d1af736513cf06ccb5e735a"><td class="memItemLeft" align="right" valign="top"><a id="a50239afa6d1af736513cf06ccb5e735a" name="a50239afa6d1af736513cf06ccb5e735a"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_complex</b> = <a class="el" href="structslate_1_1is__complex.html">slate::is_complex</a>&lt;scalar_t&gt;::value</td></tr>
<tr class="separator:a50239afa6d1af736513cf06ccb5e735a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cab364b177421a0c09500660ed53ef5"><td class="memItemLeft" align="right" valign="top"><a id="a1cab364b177421a0c09500660ed53ef5" name="a1cab364b177421a0c09500660ed53ef5"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_real</b> = ! <a class="el" href="structslate_1_1is__complex.html">is_complex</a></td></tr>
<tr class="separator:a1cab364b177421a0c09500660ed53ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4b8f84f1139071dce3ef97eb4cad5899"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#a4b8f84f1139071dce3ef97eb4cad5899">mb</a> (int64_t in_mb)</td></tr>
<tr class="memdesc:a4b8f84f1139071dce3ef97eb4cad5899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets number of rows of op(A), where A is this tile.  <br /></td></tr>
<tr class="separator:a4b8f84f1139071dce3ef97eb4cad5899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd735d4204a6f11d7614de23475c4d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#aadd735d4204a6f11d7614de23475c4d3">nb</a> (int64_t in_nb)</td></tr>
<tr class="memdesc:aadd735d4204a6f11d7614de23475c4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets number of cols of op(A), where A is this tile.  <br /></td></tr>
<tr class="separator:aadd735d4204a6f11d7614de23475c4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb19b664ebb7d9c34ddd2e68d5c48598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#abb19b664ebb7d9c34ddd2e68d5c48598">offset</a> (int64_t i, int64_t j)</td></tr>
<tr class="memdesc:abb19b664ebb7d9c34ddd2e68d5c48598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offsets data pointer to op(A)(i, j), where A is this tile.  <br /></td></tr>
<tr class="separator:abb19b664ebb7d9c34ddd2e68d5c48598"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a60aa466c937beb47e37d574b86eb372c"><td class="memItemLeft" align="right" valign="top"><a id="a60aa466c937beb47e37d574b86eb372c" name="a60aa466c937beb47e37d574b86eb372c"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>mb_</b></td></tr>
<tr class="separator:a60aa466c937beb47e37d574b86eb372c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3fff72bb939e5744d6e8d742e3b418"><td class="memItemLeft" align="right" valign="top"><a id="a5c3fff72bb939e5744d6e8d742e3b418" name="a5c3fff72bb939e5744d6e8d742e3b418"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>nb_</b></td></tr>
<tr class="separator:a5c3fff72bb939e5744d6e8d742e3b418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbf96364c834baed60df199058b0b53"><td class="memItemLeft" align="right" valign="top"><a id="a0bbf96364c834baed60df199058b0b53" name="a0bbf96364c834baed60df199058b0b53"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>stride_</b></td></tr>
<tr class="separator:a0bbf96364c834baed60df199058b0b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59aa55b5f7eff2a8b3c88cbe5279aa0"><td class="memItemLeft" align="right" valign="top"><a id="aa59aa55b5f7eff2a8b3c88cbe5279aa0" name="aa59aa55b5f7eff2a8b3c88cbe5279aa0"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>user_stride_</b></td></tr>
<tr class="separator:aa59aa55b5f7eff2a8b3c88cbe5279aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c4a2f36be24503bfd1278cdbe12fa7"><td class="memItemLeft" align="right" valign="top"><a id="a50c4a2f36be24503bfd1278cdbe12fa7" name="a50c4a2f36be24503bfd1278cdbe12fa7"></a>
Op&#160;</td><td class="memItemRight" valign="bottom"><b>op_</b></td></tr>
<tr class="separator:a50c4a2f36be24503bfd1278cdbe12fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ab7c5480476e5e4a59b95828b4ed46"><td class="memItemLeft" align="right" valign="top"><a id="a47ab7c5480476e5e4a59b95828b4ed46" name="a47ab7c5480476e5e4a59b95828b4ed46"></a>
Uplo&#160;</td><td class="memItemRight" valign="bottom"><b>uplo_</b></td></tr>
<tr class="separator:a47ab7c5480476e5e4a59b95828b4ed46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f612382b1e07c397ece7d22a7fa819"><td class="memItemLeft" align="right" valign="top"><a id="aa2f612382b1e07c397ece7d22a7fa819" name="aa2f612382b1e07c397ece7d22a7fa819"></a>
scalar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>data_</b></td></tr>
<tr class="separator:aa2f612382b1e07c397ece7d22a7fa819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f99306ab73a1f4d6563edc0e59f806"><td class="memItemLeft" align="right" valign="top"><a id="a53f99306ab73a1f4d6563edc0e59f806" name="a53f99306ab73a1f4d6563edc0e59f806"></a>
scalar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>user_data_</b></td></tr>
<tr class="separator:a53f99306ab73a1f4d6563edc0e59f806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63702245cf1928f9bec31b6a17ca2d1"><td class="memItemLeft" align="right" valign="top"><a id="ad63702245cf1928f9bec31b6a17ca2d1" name="ad63702245cf1928f9bec31b6a17ca2d1"></a>
scalar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>ext_data_</b></td></tr>
<tr class="separator:ad63702245cf1928f9bec31b6a17ca2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15429d33dedaf549849125feebc29447"><td class="memItemLeft" align="right" valign="top"><a id="a15429d33dedaf549849125feebc29447" name="a15429d33dedaf549849125feebc29447"></a>
<a class="el" href="group__enum.html#ga119c7d48492946c3c016fa8df49d6b01">TileKind</a>&#160;</td><td class="memItemRight" valign="bottom"><b>kind_</b></td></tr>
<tr class="separator:a15429d33dedaf549849125feebc29447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cceca09b964a018813d543a4d502dd"><td class="memItemLeft" align="right" valign="top">Layout&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#a47cceca09b964a018813d543a4d502dd">layout_</a></td></tr>
<tr class="memdesc:a47cceca09b964a018813d543a4d502dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">layout_: The physical ordering of elements in the data buffer:  <br /></td></tr>
<tr class="separator:a47cceca09b964a018813d543a4d502dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1eb04b6cf0ccc6cea012a5b8b7c3bf4"><td class="memItemLeft" align="right" valign="top"><a id="ae1eb04b6cf0ccc6cea012a5b8b7c3bf4" name="ae1eb04b6cf0ccc6cea012a5b8b7c3bf4"></a>
Layout&#160;</td><td class="memItemRight" valign="bottom"><b>user_layout_</b></td></tr>
<tr class="separator:ae1eb04b6cf0ccc6cea012a5b8b7c3bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b8757f9d203583337736f5a5179a28"><td class="memItemLeft" align="right" valign="top"><a id="ad9b8757f9d203583337736f5a5179a28" name="ad9b8757f9d203583337736f5a5179a28"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>device_</b></td></tr>
<tr class="separator:ad9b8757f9d203583337736f5a5179a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8742b83dfb7abba40daae4505498cec7"><td class="memTemplParams" colspan="2"><a id="a8742b83dfb7abba40daae4505498cec7" name="a8742b83dfb7abba40daae4505498cec7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8742b83dfb7abba40daae4505498cec7"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BaseMatrix</b></td></tr>
<tr class="separator:a8742b83dfb7abba40daae4505498cec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2947c9a6472c14d5131cb442142398b8"><td class="memTemplParams" colspan="2"><a id="a2947c9a6472c14d5131cb442142398b8" name="a2947c9a6472c14d5131cb442142398b8"></a>
template&lt;typename TileType &gt; </td></tr>
<tr class="memitem:a2947c9a6472c14d5131cb442142398b8"><td class="memTemplItemLeft" align="right" valign="top">TileType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (TileType &amp;A)</td></tr>
<tr class="memdesc:a2947c9a6472c14d5131cb442142398b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns shallow copy of tile that is transposed. <br /></td></tr>
<tr class="separator:a2947c9a6472c14d5131cb442142398b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b62edd91a1897ed18191877861c1d0"><td class="memTemplParams" colspan="2"><a id="a09b62edd91a1897ed18191877861c1d0" name="a09b62edd91a1897ed18191877861c1d0"></a>
template&lt;typename TileType &gt; </td></tr>
<tr class="memitem:a09b62edd91a1897ed18191877861c1d0"><td class="memTemplItemLeft" align="right" valign="top">TileType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conj_transpose</b> (TileType &amp;A)</td></tr>
<tr class="memdesc:a09b62edd91a1897ed18191877861c1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns shallow copy of tile that is conjugate-transposed. <br /></td></tr>
<tr class="separator:a09b62edd91a1897ed18191877861c1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d08d3af3bb35a39ae0d1d49d32ff2b"><td class="memTemplParams" colspan="2">template&lt;typename TileType &gt; </td></tr>
<tr class="memitem:a71d08d3af3bb35a39ae0d1d49d32ff2b"><td class="memTemplItemLeft" align="right" valign="top">TileType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classslate_1_1_tile.html#a71d08d3af3bb35a39ae0d1d49d32ff2b">conjTranspose</a> (TileType &amp;A)</td></tr>
<tr class="separator:a71d08d3af3bb35a39ae0d1d49d32ff2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename scalar_t&gt;<br />
class slate::Tile&lt; scalar_t &gt;</div><p><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a> holding an mb-by-nb matrix, with leading dimension (stride). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae99b1567e982ee50a714e1d7e813eeb2" name="ae99b1567e982ee50a714e1d7e813eeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99b1567e982ee50a714e1d7e813eeb2">&#9670;&#160;</a></span>Tile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::Tile </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#ga119c7d48492946c3c016fa8df49d6b01">TileKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em> = <code>Layout::ColMajor</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create tile that wraps existing memory buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mb</td><td>Number of rows of the tile. mb &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>Number of columns of the tile. nb &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>The mb-by-nb tile A, stored in an lda-by-nb array if ColMajor, or lda-by-mb array if RowMajor.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of the array A. lda &gt;= mb if ColMajor. lda &gt;= nb if RowMajor.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>The kind of tile:<ul>
<li>Workspace: temporary tile, allocated by SLATE</li>
<li>SlateOwned: origin tile, allocated by SLATE</li>
<li>UserOwned: origin tile, allocated by user</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>The physical ordering of elements in the data buffer:<ul>
<li>ColMajor: elements of a column are 1-strided</li>
<li>RowMajor: elements of a row are 1-strided </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63e68bf9b069c5fd14602a4da1e8cb3a" name="a63e68bf9b069c5fd14602a4da1e8cb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e68bf9b069c5fd14602a4da1e8cb3a">&#9670;&#160;</a></span>Tile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::Tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt;&#160;</td>
          <td class="paramname"><em>src_tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#ga119c7d48492946c3c016fa8df49d6b01">TileKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create tile based on an existing tile and use existing memory buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src_tile</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a> to copy metadata from</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>The mb-by-nb tile A, stored in an lda-by-nb array if ColMajor, or lda-by-mb array if RowMajor.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>The kind of tile:<ul>
<li>Workspace: temporary tile, allocated by SLATE</li>
<li>SlateOwned: origin tile, allocated by SLATE</li>
<li>UserOwned: origin tile, allocated by user </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a61cd17ad328c2c09505cf4ff17bd1dc0" name="a61cd17ad328c2c09505cf4ff17bd1dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61cd17ad328c2c09505cf4ff17bd1dc0">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">scalar_t &amp; <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to element {i, j} of op(A). </p>
<p>If <a class="el" href="classslate_1_1_tile.html#ac16263f1b4ad9b52c96f22a2c032f56d" title="Returns transposition operation.">op()</a> is ConjTrans, data is NOT conjugated, because a reference is returned. Use operator() to get the actual value, conjugated if need be.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Row index. 0 &lt;= i &lt; mb.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>Column index. 0 &lt;= j &lt; nb. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab33073ed0335d865e6121cc33e8381ef" name="ab33073ed0335d865e6121cc33e8381ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33073ed0335d865e6121cc33e8381ef">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">scalar_t const  &amp; <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::at </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const reference to element {i, j} of op(A). </p>
<p>If <a class="el" href="classslate_1_1_tile.html#ac16263f1b4ad9b52c96f22a2c032f56d" title="Returns transposition operation.">op()</a> is ConjTrans, data is NOT conjugated, because a reference is returned. Use operator() to get the actual value, conjugated if need be. This takes column-major / row-major layout into account.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Row index. 0 &lt;= i &lt; mb.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>Column index. 0 &lt;= j &lt; nb. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0de5523746ae626fd22017262ee8a957" name="a0de5523746ae626fd22017262ee8a957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de5523746ae626fd22017262ee8a957">&#9670;&#160;</a></span>bcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::bcast </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bcast_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts tile from MPI rank bcast_root, using given communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bcast_root</td><td>Root (source) MPI rank in mpi_comm.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpi_comm</td><td>MPI communicator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5c31dbf131fa90c78dedf44df696e4a" name="aa5c31dbf131fa90c78dedf44df696e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c31dbf131fa90c78dedf44df696e4a">&#9670;&#160;</a></span>copyData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>dst_tile</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copies this tile's data to dst_tile data, both assumed on host </p>
<p>Copies data from this tile to dst_tile (host to host implementation).</p>
<p>WARNING: device ID set in device_ of both tiles should be properly set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_tile</td><td>Destination tile. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab833d9a7b9c2a606f7240ae1f0c0d7dc" name="ab833d9a7b9c2a606f7240ae1f0c0d7dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab833d9a7b9c2a606f7240ae1f0c0d7dc">&#9670;&#160;</a></span>copyData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>dst_tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from this tile to dst_tile. </p>
<p>Figures out the direction of copy and the source and destination devices from the destination tile and this tile. WARNING: device ID set in device_ of both tiles should be properly set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_tile</td><td>Destination tile.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue for copy if needed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">async</td><td>If false, don't synchronize the device queues (asynchronous mode), otherwise synchronize at every device operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83b8cb460aa0a4b3be9921fd903914f6" name="a83b8cb460aa0a4b3be9921fd903914f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b8cb460aa0a4b3be9921fd903914f6">&#9670;&#160;</a></span>extData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scalar_t * <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::extData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Pointer to the extended buffer </dd></dl>

</div>
</div>
<a id="aab82961ca82d5effaeced9c74aab7222" name="aab82961ca82d5effaeced9c74aab7222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab82961ca82d5effaeced9c74aab7222">&#9670;&#160;</a></span>extended()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::extended </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether this tile has extended buffer </dd></dl>

</div>
</div>
<a id="afcc0824c523baeb6daf690ef36d92b92" name="afcc0824c523baeb6daf690ef36d92b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc0824c523baeb6daf690ef36d92b92">&#9670;&#160;</a></span>isContiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::isContiguous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether the front memory buffer is contiguous </dd></dl>

</div>
</div>
<a id="a946f0e8bfbf7caad818e9d253f08afbd" name="a946f0e8bfbf7caad818e9d253f08afbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946f0e8bfbf7caad818e9d253f08afbd">&#9670;&#160;</a></span>isend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::isend </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Request *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends tile to MPI rank dst. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Destination MPI rank in mpi_comm.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpi_comm</td><td>MPI communicator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0c81f340db0150ddda87b59de66b686" name="aa0c81f340db0150ddda87b59de66b686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c81f340db0150ddda87b59de66b686">&#9670;&#160;</a></span>isTransposable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::isTransposable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this tile can safely store its data in transposed form based on its 'TileKind', buffer size, Layout, and stride. </p>
<p>todo: validate and handle sliced-matrix </p>

</div>
</div>
<a id="a430f64b5697e14f659b0abb5ea1399c2" name="a430f64b5697e14f659b0abb5ea1399c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430f64b5697e14f659b0abb5ea1399c2">&#9670;&#160;</a></span>layoutBackData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scalar_t * <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::layoutBackData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Pointer to the back buffer </dd></dl>

</div>
</div>
<a id="ac08569a09ce8dcf2f5cecd4a0d97a45f" name="ac08569a09ce8dcf2f5cecd4a0d97a45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08569a09ce8dcf2f5cecd4a0d97a45f">&#9670;&#160;</a></span>layoutBackStride()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::layoutBackStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Stride of the back buffer </dd></dl>

</div>
</div>
<a id="aa824da88519c7860d07e74c599832bf2" name="aa824da88519c7860d07e74c599832bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa824da88519c7860d07e74c599832bf2">&#9670;&#160;</a></span>layoutConvert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::layoutConvert </td>
          <td>(</td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>work_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert layout (Column / Row major) of this tile (device GPU implementation). </p>
<p>Performs:</p><ul>
<li>In-place conversion for square tiles</li>
<li>In-place conversion for contiguous rectangular tiles, using a workspace.</li>
<li>Out-of-place conversion if extended tile, swaps front buffer accordingly.</li>
</ul>
<p><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a> must be transposable already, should call <a class="el" href="classslate_1_1_tile.html#a0adf724ea7ec1ab24c58737484539893" title="Attaches the new_data buffer to this tile as an extended buffer extended buffer to be used to hold th...">makeTransposable()</a> if not. A BLAS++ queue should be provided if tile instance is on a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">work_data</td><td>Pointer to a workspace buffer, needed for out-of-place transpose.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to run the kernels on the device.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">async</td><td>If false, don't synchronize the device queues (asynchronous mode), otherwise synchronize at every device operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa5edc17fb9696f7aeb036168bd57b40" name="aaa5edc17fb9696f7aeb036168bd57b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5edc17fb9696f7aeb036168bd57b40">&#9670;&#160;</a></span>layoutConvert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::layoutConvert </td>
          <td>(</td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>work_data</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert layout (Column / Row major) of this tile (host CPU implementation). </p>
<p>Performs:</p><ul>
<li>In-place conversion for square tiles</li>
<li>In-place conversion for contiguous rectangular tiles, using a workspace.</li>
<li>Out-of-place conversion if extended tile, swaps front buffer accordingly.</li>
</ul>
<p><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a> must be transposable already, should call <a class="el" href="classslate_1_1_tile.html#a0adf724ea7ec1ab24c58737484539893" title="Attaches the new_data buffer to this tile as an extended buffer extended buffer to be used to hold th...">makeTransposable()</a> if not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">work_data</td><td>Pointer to a workspace buffer, needed for out-of-place transpose. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa75fcb87cdd7e972f1fc6d88cf701f92" name="aa75fcb87cdd7e972f1fc6d88cf701f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75fcb87cdd7e972f1fc6d88cf701f92">&#9670;&#160;</a></span>layoutReset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::layoutReset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the tile's member fields related to being extended. </p>
<p>WARNING: should be called within <a class="el" href="classslate_1_1_matrix_storage.html#ad9acd29f8389f7783a26e42fa765aa6d" title="Resets the extended tile.">MatrixStorage::tileLayoutReset()</a> only. NOTE: the front buffer should be already swapped to be the user buffer, throws error otherwise. </p>

</div>
</div>
<a id="a69b8b64e88cbdd91852cd68b1c719c1a" name="a69b8b64e88cbdd91852cd68b1c719c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b8b64e88cbdd91852cd68b1c719c1a">&#9670;&#160;</a></span>layoutSetFrontDataExt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::layoutSetFrontDataExt </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>front</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the front buffer of the extended tile, and adjusts stride accordingly. </p>
<p>NOTE: tile should be already extended, throws error otherwise. </p>

</div>
</div>
<a id="a4b8f84f1139071dce3ef97eb4cad5899" name="a4b8f84f1139071dce3ef97eb4cad5899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8f84f1139071dce3ef97eb4cad5899">&#9670;&#160;</a></span>mb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::mb </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>in_mb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets number of rows of op(A), where A is this tile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_mb</td><td>New number of rows. 0 &lt;= in_mb &lt;= mb. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadd735d4204a6f11d7614de23475c4d3" name="aadd735d4204a6f11d7614de23475c4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd735d4204a6f11d7614de23475c4d3">&#9670;&#160;</a></span>nb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::nb </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>in_nb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets number of cols of op(A), where A is this tile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_nb</td><td>New number of cols. 0 &lt;= in_nb &lt;= nb. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb19b664ebb7d9c34ddd2e68d5c48598" name="abb19b664ebb7d9c34ddd2e68d5c48598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb19b664ebb7d9c34ddd2e68d5c48598">&#9670;&#160;</a></span>offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::offset </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offsets data pointer to op(A)(i, j), where A is this tile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Row offset. 0 &lt;= i &lt; mb.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>Col offset. 0 &lt;= j &lt; nb. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1fb7d5524840ca5aa300be286cbf2d3" name="ab1fb7d5524840ca5aa300be286cbf2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1fb7d5524840ca5aa300be286cbf2d3">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">scalar_t <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns element {i, j} of op(A). </p>
<p>The actual value is returned, not a reference. Use <a class="el" href="classslate_1_1_tile.html#ab33073ed0335d865e6121cc33e8381ef" title="Returns a const reference to element {i, j} of op(A).">at()</a> to get a reference. If <a class="el" href="classslate_1_1_tile.html#ac16263f1b4ad9b52c96f22a2c032f56d" title="Returns transposition operation.">op()</a> is ConjTrans, data IS conjugated, unlike with <a class="el" href="classslate_1_1_tile.html#ab33073ed0335d865e6121cc33e8381ef" title="Returns a const reference to element {i, j} of op(A).">at()</a>. This takes column-major / row-major layout into account.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Row index. 0 &lt;= i &lt; mb.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>Column index. 0 &lt;= j &lt; nb. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28e99f32f7ad33fad788d40ddc3402ab" name="a28e99f32f7ad33fad788d40ddc3402ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e99f32f7ad33fad788d40ddc3402ab">&#9670;&#160;</a></span>recv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::recv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives tile from MPI rank src. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source MPI rank in mpi_comm.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpi_comm</td><td>MPI communicator.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates the Layout (ColMajor/RowMajor) of the received data. WARNING: need to call tileLayout(...) to properly set the layout of the origin matrix tile afterwards. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afefa9107c4fbd69e7bc3df70af930dbc" name="afefa9107c4fbd69e7bc3df70af930dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afefa9107c4fbd69e7bc3df70af930dbc">&#9670;&#160;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::send </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends tile to MPI rank dst. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Destination MPI rank in mpi_comm.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpi_comm</td><td>MPI communicator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3833d3a31ed57f0960058aa0b9851bfb" name="a3833d3a31ed57f0960058aa0b9851bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3833d3a31ed57f0960058aa0b9851bfb">&#9670;&#160;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::set </td>
          <td>(</td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set tile data to constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value set on both diagonal and off-diagonal elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f5c6b65517ee88801d9411069c20e90" name="a8f5c6b65517ee88801d9411069c20e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5c6b65517ee88801d9411069c20e90">&#9670;&#160;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::set </td>
          <td>(</td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>offdiag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>diag_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set tile data to constants. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offdiag_value</td><td>Value set on off-diagonal elements.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diag_value</td><td>Value set on diagonal elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65446fb5ba29de9ec1d7316c17d7d09d" name="a65446fb5ba29de9ec1d7316c17d7d09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65446fb5ba29de9ec1d7316c17d7d09d">&#9670;&#160;</a></span>uplo_logical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uplo <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::uplo_logical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="ada6f48dcc5289507e6fb4b0f0f792645" name="ada6f48dcc5289507e6fb4b0f0f792645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6f48dcc5289507e6fb4b0f0f792645">&#9670;&#160;</a></span>uploLogical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Uplo <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::uploLogical</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether op(A) is logically Upper, Lower, or General storage, taking the transposition operation into account. </p>
<p>Same as <a class="el" href="classslate_1_1_tile.html#a0d95f849f51748f4fc746eb53682a290" title="Returns whether op(A) is logically Lower, Upper, or General storage.">uplo()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_tile.html#a41ddd325e43eb7a2e183f17e4b5d4f88" title="Returns whether A is Upper, Lower, or General storage, ignoring the transposition operation.">uploPhysical()</a> </dd></dl>

</div>
</div>
<a id="a41ddd325e43eb7a2e183f17e4b5d4f88" name="a41ddd325e43eb7a2e183f17e4b5d4f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ddd325e43eb7a2e183f17e4b5d4f88">&#9670;&#160;</a></span>uploPhysical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Uplo <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::uploPhysical</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether A is Upper, Lower, or General storage, ignoring the transposition operation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_tile.html#a0d95f849f51748f4fc746eb53682a290" title="Returns whether op(A) is logically Lower, Upper, or General storage.">uplo()</a> </dd>
<dd>
<a class="el" href="classslate_1_1_tile.html#ada6f48dcc5289507e6fb4b0f0f792645" title="Returns whether op(A) is logically Upper, Lower, or General storage, taking the transposition operati...">uploLogical()</a> </dd></dl>

</div>
</div>
<a id="ab3db11511149388406129d80a2ba6ada" name="ab3db11511149388406129d80a2ba6ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3db11511149388406129d80a2ba6ada">&#9670;&#160;</a></span>userData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scalar_t * <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::userData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Pointer to the user allocated buffer </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a71d08d3af3bb35a39ae0d1d49d32ff2b" name="a71d08d3af3bb35a39ae0d1d49d32ff2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d08d3af3bb35a39ae0d1d49d32ff2b">&#9670;&#160;</a></span>conjTranspose</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<div class="memtemplate">
template&lt;typename TileType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TileType conjTranspose </td>
          <td>(</td>
          <td class="paramtype">TileType &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a47cceca09b964a018813d543a4d502dd" name="a47cceca09b964a018813d543a4d502dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47cceca09b964a018813d543a4d502dd">&#9670;&#160;</a></span>layout_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Layout <a class="el" href="classslate_1_1_tile.html">slate::Tile</a>&lt; scalar_t &gt;::layout_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>layout_: The physical ordering of elements in the data buffer: </p>
<ul>
<li>ColMajor: elements of a column are 1-strided</li>
<li>RowMajor: elements of a row are 1-strided </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/slate/Tile.hh</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceslate.html">slate</a></li><li class="navelem"><a class="el" href="classslate_1_1_tile.html">Tile</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
