<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SLATE: slate::device Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
// see https://stackoverflow.com/questions/40270302/latex-newcommand-in-doxgygen-html-output
// see http://docs.mathjax.org/en/latest/tex.html#defining-tex-macros
MathJax.Hub.Config({
    TeX: {
        Macros: {
            abs: ["\\left| #1 \\right|", 1],
            norm: ["\\left\\lVert #1 \\right\\rVert", 1],
        }
    }
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SLATE<span id="projectnumber">&#160;2023.08.25</span>
   </div>
   <div id="projectbrief">Software for Linear Algebra Targeting Exascale</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceslate_1_1device.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">slate::device Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>GPU device implementations of kernels.  
<a href="namespaceslate_1_1device.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9f0a7ef009c66a51c622d72a08b929ad"><td class="memItemLeft" align="right" valign="top"><a id="a9f0a7ef009c66a51c622d72a08b929ad" name="a9f0a7ef009c66a51c622d72a08b929ad"></a>
typedef std::complex&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>devFloatComplex</b></td></tr>
<tr class="separator:a9f0a7ef009c66a51c622d72a08b929ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32405cc47ae88055abf1f3f56de5ca06"><td class="memItemLeft" align="right" valign="top"><a id="a32405cc47ae88055abf1f3f56de5ca06" name="a32405cc47ae88055abf1f3f56de5ca06"></a>
typedef std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>devDoubleComplex</b></td></tr>
<tr class="separator:a32405cc47ae88055abf1f3f56de5ca06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8f7c3d16cad839668de1789efc626351"><td class="memTemplParams" colspan="2">template&lt;typename src_scalar_t , typename dst_scalar_t &gt; </td></tr>
<tr class="memitem:a8f7c3d16cad839668de1789efc626351"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a8f7c3d16cad839668de1789efc626351">gecopy</a> (int64_t m, int64_t n, src_scalar_t const  *const  *Aarray, int64_t lda, dst_scalar_t **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a8f7c3d16cad839668de1789efc626351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batched routine for element-wise copy and precision conversion, copying A to B.  <br /></td></tr>
<tr class="separator:a8f7c3d16cad839668de1789efc626351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498852bdfe25e2b29a1cb3956834f68a"><td class="memTemplParams" colspan="2"><a id="a498852bdfe25e2b29a1cb3956834f68a" name="a498852bdfe25e2b29a1cb3956834f68a"></a>
template&lt;typename src_scalar_t , typename dst_scalar_t &gt; </td></tr>
<tr class="memitem:a498852bdfe25e2b29a1cb3956834f68a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzcopy</b> (Uplo uplo, int64_t m, int64_t n, src_scalar_t const *const *Aarray, int64_t lda, dst_scalar_t **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a498852bdfe25e2b29a1cb3956834f68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81f2ef856c00f2bdf5eae81752bfb1b"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:af81f2ef856c00f2bdf5eae81752bfb1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#af81f2ef856c00f2bdf5eae81752bfb1b">geadd</a> (int64_t m, int64_t n, scalar_t const  &amp;alpha, scalar_t *A, int64_t lda, scalar_t const  &amp;beta, scalar_t *B, int64_t ldb, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:af81f2ef856c00f2bdf5eae81752bfb1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine for element-wise tile addition.  <br /></td></tr>
<tr class="separator:af81f2ef856c00f2bdf5eae81752bfb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9889999d6d50e414f2a3bd57e7c20cb7"><td class="memTemplParams" colspan="2"><a id="a9889999d6d50e414f2a3bd57e7c20cb7" name="a9889999d6d50e414f2a3bd57e7c20cb7"></a>
template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a9889999d6d50e414f2a3bd57e7c20cb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzadd</b> (Uplo uplo, int64_t m, int64_t n, scalar_t const &amp;alpha, scalar_t **Aarray, int64_t lda, scalar_t const &amp;beta, scalar_t **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a9889999d6d50e414f2a3bd57e7c20cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab550834c570e124e7b51d20e0d8447"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t , typename scalar_t2 &gt; </td></tr>
<tr class="memitem:aaab550834c570e124e7b51d20e0d8447"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#aaab550834c570e124e7b51d20e0d8447">gescale</a> (int64_t m, int64_t n, scalar_t2 numer, scalar_t2 denom, scalar_t *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:aaab550834c570e124e7b51d20e0d8447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing element-wise tile scale.  <br /></td></tr>
<tr class="separator:aaab550834c570e124e7b51d20e0d8447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234ba724138f4b4c0b5e7a3e18f4e79c"><td class="memTemplParams" colspan="2"><a id="a234ba724138f4b4c0b5e7a3e18f4e79c" name="a234ba724138f4b4c0b5e7a3e18f4e79c"></a>
template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a234ba724138f4b4c0b5e7a3e18f4e79c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzscale</b> (Uplo uplo, int64_t m, int64_t n, blas::real_type&lt; scalar_t &gt; numer, blas::real_type&lt; scalar_t &gt; denom, scalar_t **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a234ba724138f4b4c0b5e7a3e18f4e79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547b1e14b37d0c3616e92a82084b2f6b"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t , typename scalar_t2 &gt; </td></tr>
<tr class="memitem:a547b1e14b37d0c3616e92a82084b2f6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a547b1e14b37d0c3616e92a82084b2f6b">gescale_row_col_batch</a> (Equed equed, int64_t m, int64_t n, scalar_t2 const  *const  *Rarray, scalar_t2 const  *const  *Carray, scalar_t **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a547b1e14b37d0c3616e92a82084b2f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batched routine for row and column scaling.  <br /></td></tr>
<tr class="separator:a547b1e14b37d0c3616e92a82084b2f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f116ed80d6c87ef6026471fe3eae859"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a2f116ed80d6c87ef6026471fe3eae859"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a2f116ed80d6c87ef6026471fe3eae859">geset</a> (int64_t m, int64_t n, scalar_t const  &amp;offdiag_value, scalar_t const  &amp;diag_value, scalar_t *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a2f116ed80d6c87ef6026471fe3eae859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise m-by-n matrix A to diag_value on the diagonal and offdiag_value on the off-diagonals.  <br /></td></tr>
<tr class="separator:a2f116ed80d6c87ef6026471fe3eae859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d41697de8a5c5ac435d9f5c464459b"><td class="memTemplParams" colspan="2"><a id="a75d41697de8a5c5ac435d9f5c464459b" name="a75d41697de8a5c5ac435d9f5c464459b"></a>
template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a75d41697de8a5c5ac435d9f5c464459b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzset</b> (Uplo uplo, int64_t m, int64_t n, scalar_t const &amp;offdiag_value, scalar_t const &amp;diag_value, scalar_t *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a75d41697de8a5c5ac435d9f5c464459b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b351ce9c087021d4607dbd898fc878"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a60b351ce9c087021d4607dbd898fc878"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a60b351ce9c087021d4607dbd898fc878">genorm</a> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, <a class="el" href="group__enum.html#ga8adf8aeaee2927385592d44ff23b95bb">NormScope</a> scope, int64_t m, int64_t n, scalar_t const  *const  *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a60b351ce9c087021d4607dbd898fc878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batched routine that computes a partial norm for each tile.  <br /></td></tr>
<tr class="separator:a60b351ce9c087021d4607dbd898fc878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf654bcd573704a49aafe5771e47b2fa"><td class="memTemplParams" colspan="2"><a id="abf654bcd573704a49aafe5771e47b2fa" name="abf654bcd573704a49aafe5771e47b2fa"></a>
template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:abf654bcd573704a49aafe5771e47b2fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>henorm</b> (Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, Uplo uplo, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:abf654bcd573704a49aafe5771e47b2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b61e330f67092c267d7b4e29240094"><td class="memTemplParams" colspan="2"><a id="a44b61e330f67092c267d7b4e29240094" name="a44b61e330f67092c267d7b4e29240094"></a>
template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a44b61e330f67092c267d7b4e29240094"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>synorm</b> (Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, Uplo uplo, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a44b61e330f67092c267d7b4e29240094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bae869c820fdb608cc5c4a9d69ba746"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a4bae869c820fdb608cc5c4a9d69ba746"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a4bae869c820fdb608cc5c4a9d69ba746">synormOffdiag</a> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, int64_t m, int64_t n, scalar_t const  *const  *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a4bae869c820fdb608cc5c4a9d69ba746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batched routine that computes a partial norm for each tile.  <br /></td></tr>
<tr class="separator:a4bae869c820fdb608cc5c4a9d69ba746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7746640c4375b9249f0314e4da0d45ac"><td class="memTemplParams" colspan="2"><a id="a7746640c4375b9249f0314e4da0d45ac" name="a7746640c4375b9249f0314e4da0d45ac"></a>
template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a7746640c4375b9249f0314e4da0d45ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trnorm</b> (Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, Uplo uplo, Diag diag, int64_t m, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a7746640c4375b9249f0314e4da0d45ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b58c06cfb7511c5ae533fcb05b7c431"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a0b58c06cfb7511c5ae533fcb05b7c431"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a0b58c06cfb7511c5ae533fcb05b7c431">transpose</a> (bool is_conj, int64_t n, scalar_t *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a0b58c06cfb7511c5ae533fcb05b7c431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physically transpose a square matrix in place.  <br /></td></tr>
<tr class="separator:a0b58c06cfb7511c5ae533fcb05b7c431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1666cc690ea5c2abe2df7494b3d7bc"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a4a1666cc690ea5c2abe2df7494b3d7bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a4a1666cc690ea5c2abe2df7494b3d7bc">transpose_batch</a> (bool is_conj, int64_t n, scalar_t **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a4a1666cc690ea5c2abe2df7494b3d7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physically transpose a batch of square matrices in place.  <br /></td></tr>
<tr class="separator:a4a1666cc690ea5c2abe2df7494b3d7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef4150de14378e336fbed11bc99d971"><td class="memTemplParams" colspan="2"><a id="a5ef4150de14378e336fbed11bc99d971" name="a5ef4150de14378e336fbed11bc99d971"></a>
template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a5ef4150de14378e336fbed11bc99d971"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t m, int64_t n, scalar_t *dA, int64_t lda, scalar_t *dAT, int64_t ldat, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a5ef4150de14378e336fbed11bc99d971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc857419ad0b45d32158b8ab94062b6"><td class="memTemplParams" colspan="2"><a id="a6bc857419ad0b45d32158b8ab94062b6" name="a6bc857419ad0b45d32158b8ab94062b6"></a>
template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a6bc857419ad0b45d32158b8ab94062b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t m, int64_t n, scalar_t **dA_array, int64_t lda, scalar_t **dAT_array, int64_t ldat, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a6bc857419ad0b45d32158b8ab94062b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e6e27f4025a9fa3a640b8dffa67891"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a09e6e27f4025a9fa3a640b8dffa67891"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a09e6e27f4025a9fa3a640b8dffa67891">geadd_func</a> (int64_t m, int64_t n, scalar_t alpha, scalar_t *A, int64_t lda, scalar_t beta, scalar_t *B, int64_t ldb)</td></tr>
<tr class="memdesc:a09e6e27f4025a9fa3a640b8dffa67891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing element-wise tile addition.  <br /></td></tr>
<tr class="separator:a09e6e27f4025a9fa3a640b8dffa67891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb70d814f7a4f6e04be80eb10775dec1"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:adb70d814f7a4f6e04be80eb10775dec1"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#adb70d814f7a4f6e04be80eb10775dec1">geadd_kernel</a> (int64_t m, int64_t n, scalar_t alpha, scalar_t *A, int64_t lda, scalar_t beta, scalar_t *B, int64_t ldb)</td></tr>
<tr class="memdesc:adb70d814f7a4f6e04be80eb10775dec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing element-wise tile.  <br /></td></tr>
<tr class="separator:adb70d814f7a4f6e04be80eb10775dec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d56cfab6bd7336f56626cfc27c99ab"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a27d56cfab6bd7336f56626cfc27c99ab"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a27d56cfab6bd7336f56626cfc27c99ab">geadd_batch_kernel</a> (int64_t m, int64_t n, scalar_t alpha, scalar_t **Aarray, int64_t lda, scalar_t beta, scalar_t **Barray, int64_t ldb)</td></tr>
<tr class="memdesc:a27d56cfab6bd7336f56626cfc27c99ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing element-wise tile set.  <br /></td></tr>
<tr class="separator:a27d56cfab6bd7336f56626cfc27c99ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d7fd1861da1a8b47f873cf0181e6a1"><td class="memItemLeft" align="right" valign="top"><a id="a96d7fd1861da1a8b47f873cf0181e6a1" name="a96d7fd1861da1a8b47f873cf0181e6a1"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>geadd</b> (int64_t m, int64_t n, float const &amp;alpha, float *Aarray, int64_t lda, float const &amp;beta, float *Barray, int64_t ldb, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a96d7fd1861da1a8b47f873cf0181e6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710fc5212e3e9595e0c032b6ccc907c8"><td class="memItemLeft" align="right" valign="top"><a id="a710fc5212e3e9595e0c032b6ccc907c8" name="a710fc5212e3e9595e0c032b6ccc907c8"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>geadd</b> (int64_t m, int64_t n, double const &amp;alpha, double *Aarray, int64_t lda, double const &amp;beta, double *Barray, int64_t ldb, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a710fc5212e3e9595e0c032b6ccc907c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82783139b1d70a6352e4a48d08779ed1"><td class="memItemLeft" align="right" valign="top"><a id="a82783139b1d70a6352e4a48d08779ed1" name="a82783139b1d70a6352e4a48d08779ed1"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>geadd</b> (int64_t m, int64_t n, cuFloatComplex const &amp;alpha, cuFloatComplex *Aarray, int64_t lda, cuFloatComplex const &amp;beta, cuFloatComplex *Barray, int64_t ldb, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a82783139b1d70a6352e4a48d08779ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07845364af4540b117b04cad49c04eb0"><td class="memItemLeft" align="right" valign="top"><a id="a07845364af4540b117b04cad49c04eb0" name="a07845364af4540b117b04cad49c04eb0"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>geadd</b> (int64_t m, int64_t n, cuDoubleComplex const &amp;alpha, cuDoubleComplex *Aarray, int64_t lda, cuDoubleComplex const &amp;beta, cuDoubleComplex *Barray, int64_t ldb, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a07845364af4540b117b04cad49c04eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb8ca49b7b327db84163cd94ecc5a01"><td class="memTemplParams" colspan="2">template&lt;typename src_scalar_t , typename dst_scalar_t &gt; </td></tr>
<tr class="memitem:afeb8ca49b7b327db84163cd94ecc5a01"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#afeb8ca49b7b327db84163cd94ecc5a01">gecopy_kernel</a> (int64_t m, int64_t n, src_scalar_t const *const *Aarray, int64_t lda, dst_scalar_t **Barray, int64_t ldb)</td></tr>
<tr class="memdesc:afeb8ca49b7b327db84163cd94ecc5a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing copy and precision conversions, copying A to B.  <br /></td></tr>
<tr class="separator:afeb8ca49b7b327db84163cd94ecc5a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741f4406104caef16fd9710f419b6fb0"><td class="memItemLeft" align="right" valign="top"><a id="a741f4406104caef16fd9710f419b6fb0" name="a741f4406104caef16fd9710f419b6fb0"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, float const *const *Aarray, int64_t lda, float **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a741f4406104caef16fd9710f419b6fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca0712c3f91f72d31475bd6430c8133"><td class="memItemLeft" align="right" valign="top"><a id="a6ca0712c3f91f72d31475bd6430c8133" name="a6ca0712c3f91f72d31475bd6430c8133"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, float const *const *Aarray, int64_t lda, double **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a6ca0712c3f91f72d31475bd6430c8133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d87f98d5beb347d38bdd2334165f792"><td class="memItemLeft" align="right" valign="top"><a id="a6d87f98d5beb347d38bdd2334165f792" name="a6d87f98d5beb347d38bdd2334165f792"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, double const *const *Aarray, int64_t lda, double **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a6d87f98d5beb347d38bdd2334165f792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3586f5106b3a09d600643acd6ddbf7"><td class="memItemLeft" align="right" valign="top"><a id="abf3586f5106b3a09d600643acd6ddbf7" name="abf3586f5106b3a09d600643acd6ddbf7"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, double const *const *Aarray, int64_t lda, float **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:abf3586f5106b3a09d600643acd6ddbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7645944479ecb081ba01eeb40eaf427d"><td class="memItemLeft" align="right" valign="top"><a id="a7645944479ecb081ba01eeb40eaf427d" name="a7645944479ecb081ba01eeb40eaf427d"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, cuFloatComplex const *const *Aarray, int64_t lda, cuFloatComplex **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a7645944479ecb081ba01eeb40eaf427d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46266d627166d63eb5fe7dbf375842d5"><td class="memItemLeft" align="right" valign="top"><a id="a46266d627166d63eb5fe7dbf375842d5" name="a46266d627166d63eb5fe7dbf375842d5"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, cuFloatComplex const *const *Aarray, int64_t lda, cuDoubleComplex **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a46266d627166d63eb5fe7dbf375842d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb819e0302b837fb010d45d1b150b6b"><td class="memItemLeft" align="right" valign="top"><a id="aebb819e0302b837fb010d45d1b150b6b" name="aebb819e0302b837fb010d45d1b150b6b"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, cuDoubleComplex const *const *Aarray, int64_t lda, cuDoubleComplex **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aebb819e0302b837fb010d45d1b150b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654d409ee0d2b3b53e9ba3353ada7664"><td class="memItemLeft" align="right" valign="top"><a id="a654d409ee0d2b3b53e9ba3353ada7664" name="a654d409ee0d2b3b53e9ba3353ada7664"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, cuDoubleComplex const *const *Aarray, int64_t lda, cuFloatComplex **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a654d409ee0d2b3b53e9ba3353ada7664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd080c6b6d0157973a9a277f4fb3869b"><td class="memItemLeft" align="right" valign="top"><a id="abd080c6b6d0157973a9a277f4fb3869b" name="abd080c6b6d0157973a9a277f4fb3869b"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, float const *const *Aarray, int64_t lda, cuFloatComplex **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:abd080c6b6d0157973a9a277f4fb3869b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac348031b1c9e8557b2071a51dc613451"><td class="memItemLeft" align="right" valign="top"><a id="ac348031b1c9e8557b2071a51dc613451" name="ac348031b1c9e8557b2071a51dc613451"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, double const *const *Aarray, int64_t lda, cuDoubleComplex **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ac348031b1c9e8557b2071a51dc613451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a07d7aaa8ae5c389b7da13ec3da198"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a55a07d7aaa8ae5c389b7da13ec3da198"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a55a07d7aaa8ae5c389b7da13ec3da198">genorm_max_kernel</a> (int64_t m, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *tiles_maxima)</td></tr>
<tr class="memdesc:a55a07d7aaa8ae5c389b7da13ec3da198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the largest absolute value of elements, for each tile in Aarray.  <br /></td></tr>
<tr class="separator:a55a07d7aaa8ae5c389b7da13ec3da198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d318a816d0607b41e4c0f6a5ee518d"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a63d318a816d0607b41e4c0f6a5ee518d"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a63d318a816d0607b41e4c0f6a5ee518d">genorm_one_kernel</a> (int64_t m, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *tiles_sums, int64_t ldv)</td></tr>
<tr class="memdesc:a63d318a816d0607b41e4c0f6a5ee518d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of absolute values of each column of elements, for each tile in Aarray.  <br /></td></tr>
<tr class="separator:a63d318a816d0607b41e4c0f6a5ee518d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a0e917a785e84a0de6a5e7aa092f25"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a73a0e917a785e84a0de6a5e7aa092f25"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a73a0e917a785e84a0de6a5e7aa092f25">genorm_inf_kernel</a> (int64_t m, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *tiles_sums, int64_t ldv)</td></tr>
<tr class="memdesc:a73a0e917a785e84a0de6a5e7aa092f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of absolute values of each row of elements, for each tile in Aarray.  <br /></td></tr>
<tr class="separator:a73a0e917a785e84a0de6a5e7aa092f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b193c442e8fea90d0a7c37b86783158"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a6b193c442e8fea90d0a7c37b86783158"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a6b193c442e8fea90d0a7c37b86783158">genorm_fro_kernel</a> (int64_t m, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *tiles_values)</td></tr>
<tr class="memdesc:a6b193c442e8fea90d0a7c37b86783158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of squares, in scaled representation, for each tile in Aarray.  <br /></td></tr>
<tr class="separator:a6b193c442e8fea90d0a7c37b86783158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a92a02ddd4887377af5e22ecffda33"><td class="memTemplParams" colspan="2"><a id="a32a92a02ddd4887377af5e22ecffda33" name="a32a92a02ddd4887377af5e22ecffda33"></a>
template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a32a92a02ddd4887377af5e22ecffda33"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_col_norms_max_kernel</b> (int64_t m, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *col_max, int64_t ldv)</td></tr>
<tr class="separator:a32a92a02ddd4887377af5e22ecffda33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb356af55fc8879d3b7689474fb9dbc3"><td class="memItemLeft" align="right" valign="top"><a id="acb356af55fc8879d3b7689474fb9dbc3" name="acb356af55fc8879d3b7689474fb9dbc3"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>genorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, <a class="el" href="group__enum.html#ga8adf8aeaee2927385592d44ff23b95bb">NormScope</a> scope, int64_t m, int64_t n, float const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:acb356af55fc8879d3b7689474fb9dbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba248110e5fed621c2f91f24c198cdfd"><td class="memItemLeft" align="right" valign="top"><a id="aba248110e5fed621c2f91f24c198cdfd" name="aba248110e5fed621c2f91f24c198cdfd"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>genorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, <a class="el" href="group__enum.html#ga8adf8aeaee2927385592d44ff23b95bb">NormScope</a> scope, int64_t m, int64_t n, double const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aba248110e5fed621c2f91f24c198cdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a56b0a2435f4af2a1a38379f81a9a10"><td class="memItemLeft" align="right" valign="top"><a id="a3a56b0a2435f4af2a1a38379f81a9a10" name="a3a56b0a2435f4af2a1a38379f81a9a10"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>genorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, <a class="el" href="group__enum.html#ga8adf8aeaee2927385592d44ff23b95bb">NormScope</a> scope, int64_t m, int64_t n, cuFloatComplex const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a3a56b0a2435f4af2a1a38379f81a9a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7357ce7c7192a4c22cc27791c5d1df06"><td class="memItemLeft" align="right" valign="top"><a id="a7357ce7c7192a4c22cc27791c5d1df06" name="a7357ce7c7192a4c22cc27791c5d1df06"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>genorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, <a class="el" href="group__enum.html#ga8adf8aeaee2927385592d44ff23b95bb">NormScope</a> scope, int64_t m, int64_t n, cuDoubleComplex const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a7357ce7c7192a4c22cc27791c5d1df06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec106808d9ee4a6ccb7ff4dc0dbb4cad"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t , typename scalar_t2 &gt; </td></tr>
<tr class="memitem:aec106808d9ee4a6ccb7ff4dc0dbb4cad"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#aec106808d9ee4a6ccb7ff4dc0dbb4cad">gescale_func</a> (int64_t m, int64_t n, scalar_t2 mul, scalar_t *A, int64_t lda)</td></tr>
<tr class="memdesc:aec106808d9ee4a6ccb7ff4dc0dbb4cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device function implementing element-wise tile scale.  <br /></td></tr>
<tr class="separator:aec106808d9ee4a6ccb7ff4dc0dbb4cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d0963f8d030896bad39c5fdcdf19da"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t , typename scalar_t2 &gt; </td></tr>
<tr class="memitem:ae9d0963f8d030896bad39c5fdcdf19da"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#ae9d0963f8d030896bad39c5fdcdf19da">gescale_kernel</a> (int64_t m, int64_t n, scalar_t2 mul, scalar_t *A, int64_t lda)</td></tr>
<tr class="memdesc:ae9d0963f8d030896bad39c5fdcdf19da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing element-wise tile scale.  <br /></td></tr>
<tr class="separator:ae9d0963f8d030896bad39c5fdcdf19da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb13de304abcf20a71ac8288ac43cded"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t , typename scalar_t2 &gt; </td></tr>
<tr class="memitem:abb13de304abcf20a71ac8288ac43cded"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#abb13de304abcf20a71ac8288ac43cded">gescale_batch_kernel</a> (int64_t m, int64_t n, scalar_t2 mul, scalar_t **Aarray, int64_t lda)</td></tr>
<tr class="memdesc:abb13de304abcf20a71ac8288ac43cded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing element-wise tile scale.  <br /></td></tr>
<tr class="separator:abb13de304abcf20a71ac8288ac43cded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfbceec74687c9ff4a2c0d0fad90d12"><td class="memItemLeft" align="right" valign="top"><a id="a8bfbceec74687c9ff4a2c0d0fad90d12" name="a8bfbceec74687c9ff4a2c0d0fad90d12"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gescale</b> (int64_t m, int64_t n, float numer, float denom, float *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a8bfbceec74687c9ff4a2c0d0fad90d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced28e82ab490aeba47201e110d1e995"><td class="memItemLeft" align="right" valign="top"><a id="aced28e82ab490aeba47201e110d1e995" name="aced28e82ab490aeba47201e110d1e995"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gescale</b> (int64_t m, int64_t n, double numer, double denom, double *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aced28e82ab490aeba47201e110d1e995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ba6d848261a46c148b1ab4df6f9dc3"><td class="memItemLeft" align="right" valign="top"><a id="af3ba6d848261a46c148b1ab4df6f9dc3" name="af3ba6d848261a46c148b1ab4df6f9dc3"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gescale</b> (int64_t m, int64_t n, float numer, float denom, cuFloatComplex *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:af3ba6d848261a46c148b1ab4df6f9dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfc95a4caa34f81a779f329a9b905cd"><td class="memItemLeft" align="right" valign="top"><a id="aacfc95a4caa34f81a779f329a9b905cd" name="aacfc95a4caa34f81a779f329a9b905cd"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gescale</b> (int64_t m, int64_t n, cuFloatComplex numer, cuFloatComplex denom, cuFloatComplex *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aacfc95a4caa34f81a779f329a9b905cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab1c88595e247b4e2e1f8369345b0c6"><td class="memItemLeft" align="right" valign="top"><a id="a2ab1c88595e247b4e2e1f8369345b0c6" name="a2ab1c88595e247b4e2e1f8369345b0c6"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gescale</b> (int64_t m, int64_t n, double numer, double denom, cuDoubleComplex *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a2ab1c88595e247b4e2e1f8369345b0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345a219d6700bacad5cf3f66e4915cde"><td class="memItemLeft" align="right" valign="top"><a id="a345a219d6700bacad5cf3f66e4915cde" name="a345a219d6700bacad5cf3f66e4915cde"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gescale</b> (int64_t m, int64_t n, cuDoubleComplex numer, cuDoubleComplex denom, cuDoubleComplex *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a345a219d6700bacad5cf3f66e4915cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d72f28ac09d2eac26109cfef1056900"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t , typename scalar_t2 &gt; </td></tr>
<tr class="memitem:a1d72f28ac09d2eac26109cfef1056900"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a1d72f28ac09d2eac26109cfef1056900">gescale_row_col_batch_kernel</a> (int64_t m, int64_t n, scalar_t2 const *const *Rarray, scalar_t2 const *const *Carray, scalar_t **Aarray, int64_t lda)</td></tr>
<tr class="memdesc:a1d72f28ac09d2eac26109cfef1056900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing row and column scaling.  <br /></td></tr>
<tr class="separator:a1d72f28ac09d2eac26109cfef1056900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a4816edd5ef88f87ba99423880cfb3"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t , typename scalar_t2 &gt; </td></tr>
<tr class="memitem:af8a4816edd5ef88f87ba99423880cfb3"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#af8a4816edd5ef88f87ba99423880cfb3">gescale_col_batch_kernel</a> (int64_t m, int64_t n, scalar_t2 const *const *Carray, scalar_t **Aarray, int64_t lda)</td></tr>
<tr class="memdesc:af8a4816edd5ef88f87ba99423880cfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing column scaling.  <br /></td></tr>
<tr class="separator:af8a4816edd5ef88f87ba99423880cfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab791235f095b59356daa8997f5992ad3"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t , typename scalar_t2 &gt; </td></tr>
<tr class="memitem:ab791235f095b59356daa8997f5992ad3"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#ab791235f095b59356daa8997f5992ad3">gescale_row_batch_kernel</a> (int64_t m, int64_t n, scalar_t2 const *const *Rarray, scalar_t **Aarray, int64_t lda)</td></tr>
<tr class="memdesc:ab791235f095b59356daa8997f5992ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing row scaling.  <br /></td></tr>
<tr class="separator:ab791235f095b59356daa8997f5992ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9df5511e2f104c9fc3d1794bb8faaf8"><td class="memItemLeft" align="right" valign="top"><a id="af9df5511e2f104c9fc3d1794bb8faaf8" name="af9df5511e2f104c9fc3d1794bb8faaf8"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gescale_row_col_batch</b> (Equed equed, int64_t m, int64_t n, float const *const *Rarray, float const *const *Carray, float **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:af9df5511e2f104c9fc3d1794bb8faaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296211352a0acb4bcb3561ee140077ab"><td class="memItemLeft" align="right" valign="top"><a id="a296211352a0acb4bcb3561ee140077ab" name="a296211352a0acb4bcb3561ee140077ab"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gescale_row_col_batch</b> (Equed equed, int64_t m, int64_t n, double const *const *Rarray, double const *const *Carray, double **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a296211352a0acb4bcb3561ee140077ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0ea27708083022553886fcbd9a7acd"><td class="memItemLeft" align="right" valign="top"><a id="a9b0ea27708083022553886fcbd9a7acd" name="a9b0ea27708083022553886fcbd9a7acd"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gescale_row_col_batch</b> (Equed equed, int64_t m, int64_t n, float const *const *Rarray, float const *const *Carray, cuFloatComplex **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a9b0ea27708083022553886fcbd9a7acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b842cda83460acb35174296d3f1245"><td class="memItemLeft" align="right" valign="top"><a id="a94b842cda83460acb35174296d3f1245" name="a94b842cda83460acb35174296d3f1245"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gescale_row_col_batch</b> (Equed equed, int64_t m, int64_t n, double const *const *Rarray, double const *const *Carray, cuDoubleComplex **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a94b842cda83460acb35174296d3f1245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9005535ada73e0eca1aff49efb291c"><td class="memItemLeft" align="right" valign="top"><a id="abd9005535ada73e0eca1aff49efb291c" name="abd9005535ada73e0eca1aff49efb291c"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gescale_row_col_batch</b> (Equed equed, int64_t m, int64_t n, cuFloatComplex const *const *Rarray, cuFloatComplex const *const *Carray, cuFloatComplex **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:abd9005535ada73e0eca1aff49efb291c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4bd11c3a0bf3934e927af5bc2c705e"><td class="memItemLeft" align="right" valign="top"><a id="afa4bd11c3a0bf3934e927af5bc2c705e" name="afa4bd11c3a0bf3934e927af5bc2c705e"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>gescale_row_col_batch</b> (Equed equed, int64_t m, int64_t n, cuDoubleComplex const *const *Rarray, cuDoubleComplex const *const *Carray, cuDoubleComplex **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:afa4bd11c3a0bf3934e927af5bc2c705e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0702ff0c4d5d96a4d89d06b1cb72cf"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:aac0702ff0c4d5d96a4d89d06b1cb72cf"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#aac0702ff0c4d5d96a4d89d06b1cb72cf">geset_func</a> (int64_t m, int64_t n, scalar_t offdiag_value, scalar_t diag_value, scalar_t *A, int64_t lda)</td></tr>
<tr class="memdesc:aac0702ff0c4d5d96a4d89d06b1cb72cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing element-wise tile set.  <br /></td></tr>
<tr class="separator:aac0702ff0c4d5d96a4d89d06b1cb72cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b7983908de8253273442b185b2a316"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a98b7983908de8253273442b185b2a316"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a98b7983908de8253273442b185b2a316">geset_kernel</a> (int64_t m, int64_t n, scalar_t offdiag_value, scalar_t diag_value, scalar_t *A, int64_t lda)</td></tr>
<tr class="memdesc:a98b7983908de8253273442b185b2a316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing element-wise tile.  <br /></td></tr>
<tr class="separator:a98b7983908de8253273442b185b2a316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729ecd6ec881697545e7896972116f17"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a729ecd6ec881697545e7896972116f17"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a729ecd6ec881697545e7896972116f17">geset_batch_kernel</a> (int64_t m, int64_t n, scalar_t offdiag_value, scalar_t diag_value, scalar_t **Aarray, int64_t lda)</td></tr>
<tr class="memdesc:a729ecd6ec881697545e7896972116f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing element-wise tile set.  <br /></td></tr>
<tr class="separator:a729ecd6ec881697545e7896972116f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec2a6a938e3b3a45aa2ff3bc6d72951"><td class="memItemLeft" align="right" valign="top"><a id="a4ec2a6a938e3b3a45aa2ff3bc6d72951" name="a4ec2a6a938e3b3a45aa2ff3bc6d72951"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>geset</b> (int64_t m, int64_t n, float const &amp;offdiag_value, float const &amp;diag_value, float *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a4ec2a6a938e3b3a45aa2ff3bc6d72951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdde6dfc719a2f90d0b2155c0db6058"><td class="memItemLeft" align="right" valign="top"><a id="abbdde6dfc719a2f90d0b2155c0db6058" name="abbdde6dfc719a2f90d0b2155c0db6058"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>geset</b> (int64_t m, int64_t n, double const &amp;offdiag_value, double const &amp;diag_value, double *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:abbdde6dfc719a2f90d0b2155c0db6058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897ab98380cb543b0d27f67079578a78"><td class="memItemLeft" align="right" valign="top"><a id="a897ab98380cb543b0d27f67079578a78" name="a897ab98380cb543b0d27f67079578a78"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>geset</b> (int64_t m, int64_t n, cuFloatComplex const &amp;offdiag_value, cuFloatComplex const &amp;diag_value, cuFloatComplex *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a897ab98380cb543b0d27f67079578a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3897ca20b27cd7143ab408bf158fdab1"><td class="memItemLeft" align="right" valign="top"><a id="a3897ca20b27cd7143ab408bf158fdab1" name="a3897ca20b27cd7143ab408bf158fdab1"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>geset</b> (int64_t m, int64_t n, cuDoubleComplex const &amp;offdiag_value, cuDoubleComplex const &amp;diag_value, cuDoubleComplex *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a3897ca20b27cd7143ab408bf158fdab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267e6d26c7f388ac22f2bc90491b8abb"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a267e6d26c7f388ac22f2bc90491b8abb"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a267e6d26c7f388ac22f2bc90491b8abb">henorm_max_kernel</a> (lapack::Uplo uplo, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *tiles_maxima)</td></tr>
<tr class="memdesc:a267e6d26c7f388ac22f2bc90491b8abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the largest absolute value of elements, for each tile in Aarray.  <br /></td></tr>
<tr class="separator:a267e6d26c7f388ac22f2bc90491b8abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a17a28e139699b4ed2b53bf3fecfa06"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a6a17a28e139699b4ed2b53bf3fecfa06"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a6a17a28e139699b4ed2b53bf3fecfa06">henorm_one_kernel</a> (lapack::Uplo uplo, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *tiles_sums, int64_t ldv)</td></tr>
<tr class="memdesc:a6a17a28e139699b4ed2b53bf3fecfa06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of absolute values of each column of elements, for each tile in Aarray.  <br /></td></tr>
<tr class="separator:a6a17a28e139699b4ed2b53bf3fecfa06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab491b3ff67e42049e9bb6ae2c23461b1"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:ab491b3ff67e42049e9bb6ae2c23461b1"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#ab491b3ff67e42049e9bb6ae2c23461b1">henorm_fro_kernel</a> (lapack::Uplo uplo, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *tiles_values)</td></tr>
<tr class="memdesc:ab491b3ff67e42049e9bb6ae2c23461b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of squares, in scaled representation, for each tile in Aarray.  <br /></td></tr>
<tr class="separator:ab491b3ff67e42049e9bb6ae2c23461b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dbd054bd0a2272a50eae372315e546"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a37dbd054bd0a2272a50eae372315e546"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a37dbd054bd0a2272a50eae372315e546">henorm</a> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a37dbd054bd0a2272a50eae372315e546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batched routine that computes a partial norm for each tile.  <br /></td></tr>
<tr class="separator:a37dbd054bd0a2272a50eae372315e546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaf5f23889cf788b44473d3130ba7fd"><td class="memItemLeft" align="right" valign="top"><a id="a1eaf5f23889cf788b44473d3130ba7fd" name="a1eaf5f23889cf788b44473d3130ba7fd"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>henorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, int64_t n, float const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a1eaf5f23889cf788b44473d3130ba7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55df16e27064d32abe1f33f40112bb72"><td class="memItemLeft" align="right" valign="top"><a id="a55df16e27064d32abe1f33f40112bb72" name="a55df16e27064d32abe1f33f40112bb72"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>henorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, int64_t n, double const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a55df16e27064d32abe1f33f40112bb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194d163b4f6a268e67852242c2980330"><td class="memItemLeft" align="right" valign="top"><a id="a194d163b4f6a268e67852242c2980330" name="a194d163b4f6a268e67852242c2980330"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>henorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, int64_t n, cuFloatComplex const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a194d163b4f6a268e67852242c2980330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c01a68a3d816a54a61e5ae2b2c6cc30"><td class="memItemLeft" align="right" valign="top"><a id="a3c01a68a3d816a54a61e5ae2b2c6cc30" name="a3c01a68a3d816a54a61e5ae2b2c6cc30"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>henorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, int64_t n, cuDoubleComplex const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a3c01a68a3d816a54a61e5ae2b2c6cc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614fa7e65e7e37b0f8a54c95b81f1656"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a614fa7e65e7e37b0f8a54c95b81f1656"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a614fa7e65e7e37b0f8a54c95b81f1656">synorm_max_kernel</a> (lapack::Uplo uplo, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *tiles_maxima)</td></tr>
<tr class="memdesc:a614fa7e65e7e37b0f8a54c95b81f1656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the largest absolute value of elements, for each tile in Aarray.  <br /></td></tr>
<tr class="separator:a614fa7e65e7e37b0f8a54c95b81f1656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302280542e73454c342d78b725bc4330"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a302280542e73454c342d78b725bc4330"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a302280542e73454c342d78b725bc4330">synorm_one_kernel</a> (lapack::Uplo uplo, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *tiles_sums, int64_t ldv)</td></tr>
<tr class="memdesc:a302280542e73454c342d78b725bc4330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of absolute values of each column of elements, for each tile in Aarray.  <br /></td></tr>
<tr class="separator:a302280542e73454c342d78b725bc4330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b1cf478de49eb26801f221e11737fb"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:ad1b1cf478de49eb26801f221e11737fb"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#ad1b1cf478de49eb26801f221e11737fb">synorm_fro_kernel</a> (lapack::Uplo uplo, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *tiles_values)</td></tr>
<tr class="memdesc:ad1b1cf478de49eb26801f221e11737fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of squares, in scaled representation, for each tile in Aarray.  <br /></td></tr>
<tr class="separator:ad1b1cf478de49eb26801f221e11737fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18eeb0a397b830086c3688cbfdebe207"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a18eeb0a397b830086c3688cbfdebe207"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a18eeb0a397b830086c3688cbfdebe207">synorm</a> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a18eeb0a397b830086c3688cbfdebe207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batched routine that computes a partial norm for each tile.  <br /></td></tr>
<tr class="separator:a18eeb0a397b830086c3688cbfdebe207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e52d8ae608627675a292e5589383feb"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a8e52d8ae608627675a292e5589383feb"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a8e52d8ae608627675a292e5589383feb">synorm_offdiag_one_kernel</a> (int64_t m, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *tiles_sums, int64_t ldv)</td></tr>
<tr class="memdesc:a8e52d8ae608627675a292e5589383feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of absolute values of each row and each column of elements, for each tile in tiles.  <br /></td></tr>
<tr class="separator:a8e52d8ae608627675a292e5589383feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03ca2ffbfe229dc8af268c96e3f2010"><td class="memItemLeft" align="right" valign="top"><a id="af03ca2ffbfe229dc8af268c96e3f2010" name="af03ca2ffbfe229dc8af268c96e3f2010"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>synorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, int64_t n, float const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:af03ca2ffbfe229dc8af268c96e3f2010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e980bf1809b57d890231bb72673925c"><td class="memItemLeft" align="right" valign="top"><a id="a9e980bf1809b57d890231bb72673925c" name="a9e980bf1809b57d890231bb72673925c"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>synorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, int64_t n, double const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a9e980bf1809b57d890231bb72673925c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add185b3ec0c876681956a69572d08189"><td class="memItemLeft" align="right" valign="top"><a id="add185b3ec0c876681956a69572d08189" name="add185b3ec0c876681956a69572d08189"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>synorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, int64_t n, cuFloatComplex const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:add185b3ec0c876681956a69572d08189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1a4f7219a4fef05bfefb65af4257d3"><td class="memItemLeft" align="right" valign="top"><a id="a9b1a4f7219a4fef05bfefb65af4257d3" name="a9b1a4f7219a4fef05bfefb65af4257d3"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>synorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, int64_t n, cuDoubleComplex const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a9b1a4f7219a4fef05bfefb65af4257d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05907ab7aa0a3987ad5d6829c08aa30"><td class="memItemLeft" align="right" valign="top"><a id="ad05907ab7aa0a3987ad5d6829c08aa30" name="ad05907ab7aa0a3987ad5d6829c08aa30"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>synormOffdiag</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, int64_t m, int64_t n, float const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ad05907ab7aa0a3987ad5d6829c08aa30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fdce183b6c078a7d6795700ca15eb6"><td class="memItemLeft" align="right" valign="top"><a id="a56fdce183b6c078a7d6795700ca15eb6" name="a56fdce183b6c078a7d6795700ca15eb6"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>synormOffdiag</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, int64_t m, int64_t n, double const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a56fdce183b6c078a7d6795700ca15eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61aac5ae2bf9d1ced126bce515524413"><td class="memItemLeft" align="right" valign="top"><a id="a61aac5ae2bf9d1ced126bce515524413" name="a61aac5ae2bf9d1ced126bce515524413"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>synormOffdiag</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, int64_t m, int64_t n, cuFloatComplex const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a61aac5ae2bf9d1ced126bce515524413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd5552653427cb6d79fa255857dc1e3"><td class="memItemLeft" align="right" valign="top"><a id="a1dd5552653427cb6d79fa255857dc1e3" name="a1dd5552653427cb6d79fa255857dc1e3"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>synormOffdiag</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, int64_t m, int64_t n, cuDoubleComplex const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a1dd5552653427cb6d79fa255857dc1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd88f594f98e1adb985d0eb4de6c4e13"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:abd88f594f98e1adb985d0eb4de6c4e13"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#abd88f594f98e1adb985d0eb4de6c4e13">transpose_func</a> (bool is_conj, int n, scalar_t *A, int64_t lda)</td></tr>
<tr class="memdesc:abd88f594f98e1adb985d0eb4de6c4e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device routine handles one matrix.  <br /></td></tr>
<tr class="separator:abd88f594f98e1adb985d0eb4de6c4e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7883ab588ea7cf8c633afe2c4875c087"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t , int NX&gt; </td></tr>
<tr class="memitem:a7883ab588ea7cf8c633afe2c4875c087"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a7883ab588ea7cf8c633afe2c4875c087">transpose_func</a> (bool is_conj, int m, int n, const scalar_t *A, int64_t lda, scalar_t *AT, int64_t ldat)</td></tr>
<tr class="memdesc:a7883ab588ea7cf8c633afe2c4875c087"><td class="mdescLeft">&#160;</td><td class="mdescRight">tile M-by-N matrix with ceil(M/NB) by ceil(N/NB) tiles sized NB-by-NB.  <br /></td></tr>
<tr class="separator:a7883ab588ea7cf8c633afe2c4875c087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d83b4123ed10e24a0ec41a55ca1f310"><td class="memTemplParams" colspan="2"><a id="a7d83b4123ed10e24a0ec41a55ca1f310" name="a7d83b4123ed10e24a0ec41a55ca1f310"></a>
template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a7d83b4123ed10e24a0ec41a55ca1f310"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_kernel</b> (bool is_conj, int n, scalar_t *A, int64_t lda)</td></tr>
<tr class="memdesc:a7d83b4123ed10e24a0ec41a55ca1f310"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place transpose of a square buffer <br /></td></tr>
<tr class="separator:a7d83b4123ed10e24a0ec41a55ca1f310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c265ad80adfb51de1470ddf4d27b8f"><td class="memTemplParams" colspan="2"><a id="a21c265ad80adfb51de1470ddf4d27b8f" name="a21c265ad80adfb51de1470ddf4d27b8f"></a>
template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a21c265ad80adfb51de1470ddf4d27b8f"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch_kernel</b> (bool is_conj, int n, scalar_t **Aarray, int64_t lda)</td></tr>
<tr class="memdesc:a21c265ad80adfb51de1470ddf4d27b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place transpose of array of square buffers <br /></td></tr>
<tr class="separator:a21c265ad80adfb51de1470ddf4d27b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac04c3741ae86438a8f8372f29c67ec8"><td class="memTemplParams" colspan="2"><a id="aac04c3741ae86438a8f8372f29c67ec8" name="aac04c3741ae86438a8f8372f29c67ec8"></a>
template&lt;typename scalar_t , int NX&gt; </td></tr>
<tr class="memitem:aac04c3741ae86438a8f8372f29c67ec8"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_kernel</b> (bool is_conj, int m, int n, const scalar_t *A, int64_t lda, scalar_t *AT, int64_t ldat)</td></tr>
<tr class="memdesc:aac04c3741ae86438a8f8372f29c67ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">out-of-place transpose of a rectangular buffer transopses A onto AT <br /></td></tr>
<tr class="separator:aac04c3741ae86438a8f8372f29c67ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6bd28a79f88fa9f06af52df79ac1bb"><td class="memTemplParams" colspan="2"><a id="a0c6bd28a79f88fa9f06af52df79ac1bb" name="a0c6bd28a79f88fa9f06af52df79ac1bb"></a>
template&lt;typename scalar_t , int NX&gt; </td></tr>
<tr class="memitem:a0c6bd28a79f88fa9f06af52df79ac1bb"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch_kernel</b> (bool is_conj, int m, int n, scalar_t **dA_array, int64_t lda, scalar_t **dAT_array, int64_t ldat)</td></tr>
<tr class="memdesc:a0c6bd28a79f88fa9f06af52df79ac1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">out-of-place transpose of an array of rectangular buffers transopses dA_array onto dAT_array <br /></td></tr>
<tr class="separator:a0c6bd28a79f88fa9f06af52df79ac1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7475b89a28a56c93b480c5d612e93369"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t , int NX&gt; </td></tr>
<tr class="memitem:a7475b89a28a56c93b480c5d612e93369"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a7475b89a28a56c93b480c5d612e93369">transpose</a> (bool is_conj, int64_t m, int64_t n, scalar_t *dA, int64_t lda, scalar_t *dAT, int64_t ldat, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a7475b89a28a56c93b480c5d612e93369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physically transpose a rectangular matrix out-of-place.  <br /></td></tr>
<tr class="separator:a7475b89a28a56c93b480c5d612e93369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5903fb3d604edbe6ab667d2aab5f931e"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t , int NX&gt; </td></tr>
<tr class="memitem:a5903fb3d604edbe6ab667d2aab5f931e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a5903fb3d604edbe6ab667d2aab5f931e">transpose_batch</a> (bool is_conj, int64_t m, int64_t n, scalar_t **dA_array, int64_t lda, scalar_t **dAT_array, int64_t ldat, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a5903fb3d604edbe6ab667d2aab5f931e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physically transpose a batch of rectangular matrices out-of-place.  <br /></td></tr>
<tr class="separator:a5903fb3d604edbe6ab667d2aab5f931e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f534e081b0daf87842f1db53e904dc7"><td class="memItemLeft" align="right" valign="top"><a id="a6f534e081b0daf87842f1db53e904dc7" name="a6f534e081b0daf87842f1db53e904dc7"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t n, float *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a6f534e081b0daf87842f1db53e904dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5aeb8f50d5f637f0a57737c2572bec1"><td class="memItemLeft" align="right" valign="top"><a id="ab5aeb8f50d5f637f0a57737c2572bec1" name="ab5aeb8f50d5f637f0a57737c2572bec1"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t n, double *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ab5aeb8f50d5f637f0a57737c2572bec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efbbc3f46d1ec243592d9ee2df06a7b"><td class="memItemLeft" align="right" valign="top"><a id="a8efbbc3f46d1ec243592d9ee2df06a7b" name="a8efbbc3f46d1ec243592d9ee2df06a7b"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t n, cuFloatComplex *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a8efbbc3f46d1ec243592d9ee2df06a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6987d6702113178234a62f4ff4b38ad7"><td class="memItemLeft" align="right" valign="top"><a id="a6987d6702113178234a62f4ff4b38ad7" name="a6987d6702113178234a62f4ff4b38ad7"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t n, cuDoubleComplex *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a6987d6702113178234a62f4ff4b38ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3740e54e7a30a60a73170934be6dce4f"><td class="memItemLeft" align="right" valign="top"><a id="a3740e54e7a30a60a73170934be6dce4f" name="a3740e54e7a30a60a73170934be6dce4f"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t n, float **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a3740e54e7a30a60a73170934be6dce4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7f4f22188de1fc0fee6a19349c5864"><td class="memItemLeft" align="right" valign="top"><a id="ace7f4f22188de1fc0fee6a19349c5864" name="ace7f4f22188de1fc0fee6a19349c5864"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t n, double **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ace7f4f22188de1fc0fee6a19349c5864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb04fd4519c5f68d7dd4ec5886424cf"><td class="memItemLeft" align="right" valign="top"><a id="a8eb04fd4519c5f68d7dd4ec5886424cf" name="a8eb04fd4519c5f68d7dd4ec5886424cf"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t n, cuFloatComplex **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a8eb04fd4519c5f68d7dd4ec5886424cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9356b4c5e003b48bdd033b4ebb153c58"><td class="memItemLeft" align="right" valign="top"><a id="a9356b4c5e003b48bdd033b4ebb153c58" name="a9356b4c5e003b48bdd033b4ebb153c58"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t n, cuDoubleComplex **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a9356b4c5e003b48bdd033b4ebb153c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0366c987fcadfe93f144eb26a430dd24"><td class="memItemLeft" align="right" valign="top"><a id="a0366c987fcadfe93f144eb26a430dd24" name="a0366c987fcadfe93f144eb26a430dd24"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0366c987fcadfe93f144eb26a430dd24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t m, int64_t n, float *dA, int64_t lda, float *dAT, int64_t ldat, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a0366c987fcadfe93f144eb26a430dd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebfdc988e490c28f12d120b286ab97e"><td class="memItemLeft" align="right" valign="top"><a id="aeebfdc988e490c28f12d120b286ab97e" name="aeebfdc988e490c28f12d120b286ab97e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aeebfdc988e490c28f12d120b286ab97e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t m, int64_t n, double *dA, int64_t lda, double *dAT, int64_t ldat, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aeebfdc988e490c28f12d120b286ab97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa54f5aea2ecf124189dcda8f365777f"><td class="memItemLeft" align="right" valign="top"><a id="aaa54f5aea2ecf124189dcda8f365777f" name="aaa54f5aea2ecf124189dcda8f365777f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aaa54f5aea2ecf124189dcda8f365777f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t m, int64_t n, cuFloatComplex *dA, int64_t lda, cuFloatComplex *dAT, int64_t ldat, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aaa54f5aea2ecf124189dcda8f365777f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5c2f5afbac690db450ec063776a5d5"><td class="memItemLeft" align="right" valign="top"><a id="aec5c2f5afbac690db450ec063776a5d5" name="aec5c2f5afbac690db450ec063776a5d5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aec5c2f5afbac690db450ec063776a5d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t m, int64_t n, cuDoubleComplex *dA, int64_t lda, cuDoubleComplex *dAT, int64_t ldat, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aec5c2f5afbac690db450ec063776a5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd1779751147bc7ef65aa553914c14c"><td class="memItemLeft" align="right" valign="top"><a id="aabd1779751147bc7ef65aa553914c14c" name="aabd1779751147bc7ef65aa553914c14c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aabd1779751147bc7ef65aa553914c14c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t m, int64_t n, float **dA_array, int64_t lda, float **dAT_array, int64_t ldat, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aabd1779751147bc7ef65aa553914c14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac467d41a137c602e4415be4fc2082779"><td class="memItemLeft" align="right" valign="top"><a id="ac467d41a137c602e4415be4fc2082779" name="ac467d41a137c602e4415be4fc2082779"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac467d41a137c602e4415be4fc2082779"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t m, int64_t n, double **dA_array, int64_t lda, double **dAT_array, int64_t ldat, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ac467d41a137c602e4415be4fc2082779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d41844bd8d1c6bc65bbf556a13e35f"><td class="memItemLeft" align="right" valign="top"><a id="a44d41844bd8d1c6bc65bbf556a13e35f" name="a44d41844bd8d1c6bc65bbf556a13e35f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a44d41844bd8d1c6bc65bbf556a13e35f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t m, int64_t n, cuFloatComplex **dA_array, int64_t lda, cuFloatComplex **dAT_array, int64_t ldat, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a44d41844bd8d1c6bc65bbf556a13e35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7913affc4ce58a81e075d37ad951c64"><td class="memItemLeft" align="right" valign="top"><a id="ae7913affc4ce58a81e075d37ad951c64" name="ae7913affc4ce58a81e075d37ad951c64"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae7913affc4ce58a81e075d37ad951c64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t m, int64_t n, cuDoubleComplex **dA_array, int64_t lda, cuDoubleComplex **dAT_array, int64_t ldat, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ae7913affc4ce58a81e075d37ad951c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13aa86014eb77b3e6ae027aea47ae547"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a13aa86014eb77b3e6ae027aea47ae547"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a13aa86014eb77b3e6ae027aea47ae547">trnorm_max_kernel</a> (lapack::Uplo uplo, lapack::Diag diag, int64_t m, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *tiles_maxima)</td></tr>
<tr class="memdesc:a13aa86014eb77b3e6ae027aea47ae547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the largest absolute value of elements, for each tile in Aarray.  <br /></td></tr>
<tr class="separator:a13aa86014eb77b3e6ae027aea47ae547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab254e30979d820251eb98eafe9b148d9"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:ab254e30979d820251eb98eafe9b148d9"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#ab254e30979d820251eb98eafe9b148d9">trnorm_one_kernel</a> (lapack::Uplo uplo, lapack::Diag diag, int64_t m, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *tiles_sums, int64_t ldv)</td></tr>
<tr class="memdesc:ab254e30979d820251eb98eafe9b148d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of absolute values of each column of elements, for each tile in Aarray.  <br /></td></tr>
<tr class="separator:ab254e30979d820251eb98eafe9b148d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41493b5e18928a25fcf0e0302a873b2d"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a41493b5e18928a25fcf0e0302a873b2d"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a41493b5e18928a25fcf0e0302a873b2d">trnorm_inf_kernel</a> (lapack::Uplo uplo, lapack::Diag diag, int64_t m, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *tiles_sums, int64_t ldv)</td></tr>
<tr class="memdesc:a41493b5e18928a25fcf0e0302a873b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of absolute values of each row of elements, for each tile in Aarray.  <br /></td></tr>
<tr class="separator:a41493b5e18928a25fcf0e0302a873b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe21fef28e458d9538708fe79fa7dfd"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a7fe21fef28e458d9538708fe79fa7dfd"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a7fe21fef28e458d9538708fe79fa7dfd">trnorm_fro_kernel</a> (lapack::Uplo uplo, lapack::Diag diag, int64_t m, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *tiles_values)</td></tr>
<tr class="memdesc:a7fe21fef28e458d9538708fe79fa7dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of squares, in scaled representation, for each tile in Aarray.  <br /></td></tr>
<tr class="separator:a7fe21fef28e458d9538708fe79fa7dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5c5e6316ae5a420ca9a1edd340e9aa"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a8b5c5e6316ae5a420ca9a1edd340e9aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a8b5c5e6316ae5a420ca9a1edd340e9aa">trnorm</a> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, lapack::Diag diag, int64_t m, int64_t n, scalar_t const *const *Aarray, int64_t lda, blas::real_type&lt; scalar_t &gt; *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a8b5c5e6316ae5a420ca9a1edd340e9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batched routine that computes a partial norm for each trapezoidal tile.  <br /></td></tr>
<tr class="separator:a8b5c5e6316ae5a420ca9a1edd340e9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b12026724612448d20fff97867aaba"><td class="memItemLeft" align="right" valign="top"><a id="af6b12026724612448d20fff97867aaba" name="af6b12026724612448d20fff97867aaba"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>trnorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, lapack::Diag diag, int64_t m, int64_t n, float const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:af6b12026724612448d20fff97867aaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5c8f46eca136e46d66d2ddcf6ea127"><td class="memItemLeft" align="right" valign="top"><a id="aad5c8f46eca136e46d66d2ddcf6ea127" name="aad5c8f46eca136e46d66d2ddcf6ea127"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>trnorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, lapack::Diag diag, int64_t m, int64_t n, double const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aad5c8f46eca136e46d66d2ddcf6ea127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af976c7bc4d0378358dc86ff752373bf8"><td class="memItemLeft" align="right" valign="top"><a id="af976c7bc4d0378358dc86ff752373bf8" name="af976c7bc4d0378358dc86ff752373bf8"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>trnorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, lapack::Diag diag, int64_t m, int64_t n, cuFloatComplex const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:af976c7bc4d0378358dc86ff752373bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ace7b3059db46ee88058256f67218a"><td class="memItemLeft" align="right" valign="top"><a id="a10ace7b3059db46ee88058256f67218a" name="a10ace7b3059db46ee88058256f67218a"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>trnorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, lapack::Diag diag, int64_t m, int64_t n, cuDoubleComplex const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a10ace7b3059db46ee88058256f67218a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a0fd92f889ac508798ae309591293b"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:ad7a0fd92f889ac508798ae309591293b"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#ad7a0fd92f889ac508798ae309591293b">tzadd_kernel</a> (lapack::Uplo uplo, int64_t m, int64_t n, scalar_t alpha, scalar_t **Aarray, int64_t lda, scalar_t beta, scalar_t **Barray, int64_t ldb)</td></tr>
<tr class="memdesc:ad7a0fd92f889ac508798ae309591293b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing element-wise tile addition.  <br /></td></tr>
<tr class="separator:ad7a0fd92f889ac508798ae309591293b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3c62d83c449f2a5db05830408bbe1c"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a7b3c62d83c449f2a5db05830408bbe1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a7b3c62d83c449f2a5db05830408bbe1c">tzadd</a> (lapack::Uplo uplo, int64_t m, int64_t n, scalar_t const &amp;alpha, scalar_t **Aarray, int64_t lda, scalar_t const &amp;beta, scalar_t **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a7b3c62d83c449f2a5db05830408bbe1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batched routine for element-wise trapezoidal tile addition.  <br /></td></tr>
<tr class="separator:a7b3c62d83c449f2a5db05830408bbe1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24f0e2a1852758cce6697b4219ed0b6"><td class="memItemLeft" align="right" valign="top"><a id="ad24f0e2a1852758cce6697b4219ed0b6" name="ad24f0e2a1852758cce6697b4219ed0b6"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzadd</b> (lapack::Uplo uplo, int64_t m, int64_t n, float const &amp;alpha, float **Aarray, int64_t lda, float const &amp;beta, float **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ad24f0e2a1852758cce6697b4219ed0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbd8cd6a771b575eab2ff6ac6fea010"><td class="memItemLeft" align="right" valign="top"><a id="acfbd8cd6a771b575eab2ff6ac6fea010" name="acfbd8cd6a771b575eab2ff6ac6fea010"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzadd</b> (lapack::Uplo uplo, int64_t m, int64_t n, double const &amp;alpha, double **Aarray, int64_t lda, double const &amp;beta, double **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:acfbd8cd6a771b575eab2ff6ac6fea010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc95aea2946b1426d663702949effb8"><td class="memItemLeft" align="right" valign="top"><a id="a1fc95aea2946b1426d663702949effb8" name="a1fc95aea2946b1426d663702949effb8"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzadd</b> (lapack::Uplo uplo, int64_t m, int64_t n, cuFloatComplex const &amp;alpha, cuFloatComplex **Aarray, int64_t lda, cuFloatComplex const &amp;beta, cuFloatComplex **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a1fc95aea2946b1426d663702949effb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab3120025000e3ee5f7c7898d170fc7"><td class="memItemLeft" align="right" valign="top"><a id="abab3120025000e3ee5f7c7898d170fc7" name="abab3120025000e3ee5f7c7898d170fc7"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzadd</b> (lapack::Uplo uplo, int64_t m, int64_t n, cuDoubleComplex const &amp;alpha, cuDoubleComplex **Aarray, int64_t lda, cuDoubleComplex const &amp;beta, cuDoubleComplex **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:abab3120025000e3ee5f7c7898d170fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb09bc25625cd9248b7e585dabd9276d"><td class="memTemplParams" colspan="2">template&lt;typename src_scalar_t , typename dst_scalar_t &gt; </td></tr>
<tr class="memitem:acb09bc25625cd9248b7e585dabd9276d"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#acb09bc25625cd9248b7e585dabd9276d">tzcopy_kernel</a> (lapack::Uplo uplo, int64_t m, int64_t n, src_scalar_t const *const *Aarray, int64_t lda, dst_scalar_t **Barray, int64_t ldb)</td></tr>
<tr class="memdesc:acb09bc25625cd9248b7e585dabd9276d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing copy and precision conversions, copying A to B.  <br /></td></tr>
<tr class="separator:acb09bc25625cd9248b7e585dabd9276d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25ee70776f04b7cb79473c1517a2cbd"><td class="memTemplParams" colspan="2">template&lt;typename src_scalar_t , typename dst_scalar_t &gt; </td></tr>
<tr class="memitem:ad25ee70776f04b7cb79473c1517a2cbd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#ad25ee70776f04b7cb79473c1517a2cbd">tzcopy</a> (lapack::Uplo uplo, int64_t m, int64_t n, src_scalar_t const *const *Aarray, int64_t lda, dst_scalar_t **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:ad25ee70776f04b7cb79473c1517a2cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batched routine for element-wise trapezoidal copy and precision conversion, copying A to B.  <br /></td></tr>
<tr class="separator:ad25ee70776f04b7cb79473c1517a2cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3419b80d424e3ea80bd495ef735657f1"><td class="memItemLeft" align="right" valign="top"><a id="a3419b80d424e3ea80bd495ef735657f1" name="a3419b80d424e3ea80bd495ef735657f1"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzcopy</b> (lapack::Uplo uplo, int64_t m, int64_t n, float const *const *Aarray, int64_t lda, float **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a3419b80d424e3ea80bd495ef735657f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacb5abd5c76d6e097f17a108096a8f2"><td class="memItemLeft" align="right" valign="top"><a id="acacb5abd5c76d6e097f17a108096a8f2" name="acacb5abd5c76d6e097f17a108096a8f2"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzcopy</b> (lapack::Uplo uplo, int64_t m, int64_t n, float const *const *Aarray, int64_t lda, double **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:acacb5abd5c76d6e097f17a108096a8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6b3ff43d4f749a9345084d1c182c4d"><td class="memItemLeft" align="right" valign="top"><a id="a5b6b3ff43d4f749a9345084d1c182c4d" name="a5b6b3ff43d4f749a9345084d1c182c4d"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzcopy</b> (lapack::Uplo uplo, int64_t m, int64_t n, double const *const *Aarray, int64_t lda, double **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a5b6b3ff43d4f749a9345084d1c182c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c51307b6110cb97eda36f672ea3165"><td class="memItemLeft" align="right" valign="top"><a id="a96c51307b6110cb97eda36f672ea3165" name="a96c51307b6110cb97eda36f672ea3165"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzcopy</b> (lapack::Uplo uplo, int64_t m, int64_t n, double const *const *Aarray, int64_t lda, float **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a96c51307b6110cb97eda36f672ea3165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5c3bb520fbc634bceef549295cfad6"><td class="memItemLeft" align="right" valign="top"><a id="afb5c3bb520fbc634bceef549295cfad6" name="afb5c3bb520fbc634bceef549295cfad6"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzcopy</b> (lapack::Uplo uplo, int64_t m, int64_t n, cuFloatComplex const *const *Aarray, int64_t lda, cuFloatComplex **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:afb5c3bb520fbc634bceef549295cfad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492fe8bf1c83ebfba14a9524b482eeb6"><td class="memItemLeft" align="right" valign="top"><a id="a492fe8bf1c83ebfba14a9524b482eeb6" name="a492fe8bf1c83ebfba14a9524b482eeb6"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzcopy</b> (lapack::Uplo uplo, int64_t m, int64_t n, cuFloatComplex const *const *Aarray, int64_t lda, cuDoubleComplex **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a492fe8bf1c83ebfba14a9524b482eeb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc897c8669cc68808e8216f0a791982a"><td class="memItemLeft" align="right" valign="top"><a id="acc897c8669cc68808e8216f0a791982a" name="acc897c8669cc68808e8216f0a791982a"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzcopy</b> (lapack::Uplo uplo, int64_t m, int64_t n, cuDoubleComplex const *const *Aarray, int64_t lda, cuDoubleComplex **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:acc897c8669cc68808e8216f0a791982a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264e04b4290af224a86d73ec7349cbe6"><td class="memItemLeft" align="right" valign="top"><a id="a264e04b4290af224a86d73ec7349cbe6" name="a264e04b4290af224a86d73ec7349cbe6"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzcopy</b> (lapack::Uplo uplo, int64_t m, int64_t n, cuDoubleComplex const *const *Aarray, int64_t lda, cuFloatComplex **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a264e04b4290af224a86d73ec7349cbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac927241272af627bf54b354ae155a396"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:ac927241272af627bf54b354ae155a396"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#ac927241272af627bf54b354ae155a396">tzscale_kernel</a> (lapack::Uplo uplo, int64_t m, int64_t n, blas::real_type&lt; scalar_t &gt; numer, blas::real_type&lt; scalar_t &gt; denom, scalar_t **Aarray, int64_t lda)</td></tr>
<tr class="memdesc:ac927241272af627bf54b354ae155a396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing element-wise tile scale.  <br /></td></tr>
<tr class="separator:ac927241272af627bf54b354ae155a396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce04468574ec9f6bfee77eb0538e7a2"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:adce04468574ec9f6bfee77eb0538e7a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#adce04468574ec9f6bfee77eb0538e7a2">tzscale</a> (lapack::Uplo uplo, int64_t m, int64_t n, blas::real_type&lt; scalar_t &gt; numer, blas::real_type&lt; scalar_t &gt; denom, scalar_t **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:adce04468574ec9f6bfee77eb0538e7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batched routine for element-wise trapezoidal tile scale.  <br /></td></tr>
<tr class="separator:adce04468574ec9f6bfee77eb0538e7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcd8a3e21d316ed9cb7e3ae86ec1780"><td class="memItemLeft" align="right" valign="top"><a id="aabcd8a3e21d316ed9cb7e3ae86ec1780" name="aabcd8a3e21d316ed9cb7e3ae86ec1780"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzscale</b> (lapack::Uplo uplo, int64_t m, int64_t n, float numer, float denom, float **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aabcd8a3e21d316ed9cb7e3ae86ec1780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148902f92b9a6c20e2665e39f0a3b9d8"><td class="memItemLeft" align="right" valign="top"><a id="a148902f92b9a6c20e2665e39f0a3b9d8" name="a148902f92b9a6c20e2665e39f0a3b9d8"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzscale</b> (lapack::Uplo uplo, int64_t m, int64_t n, double numer, double denom, double **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a148902f92b9a6c20e2665e39f0a3b9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609aee118e80e9be4af9d1ff2ad85153"><td class="memItemLeft" align="right" valign="top"><a id="a609aee118e80e9be4af9d1ff2ad85153" name="a609aee118e80e9be4af9d1ff2ad85153"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzscale</b> (lapack::Uplo uplo, int64_t m, int64_t n, float numer, float denom, cuFloatComplex **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a609aee118e80e9be4af9d1ff2ad85153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236541b54c51f7c37d33233dc9cb2364"><td class="memItemLeft" align="right" valign="top"><a id="a236541b54c51f7c37d33233dc9cb2364" name="a236541b54c51f7c37d33233dc9cb2364"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzscale</b> (lapack::Uplo uplo, int64_t m, int64_t n, double numer, double denom, cuDoubleComplex **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a236541b54c51f7c37d33233dc9cb2364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2289398e7d5eaaa3b418fe8eb99e6d93"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a2289398e7d5eaaa3b418fe8eb99e6d93"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a2289398e7d5eaaa3b418fe8eb99e6d93">tzset_func</a> (lapack::Uplo uplo, int64_t m, int64_t n, scalar_t offdiag_value, scalar_t diag_value, scalar_t *A, int64_t lda)</td></tr>
<tr class="memdesc:a2289398e7d5eaaa3b418fe8eb99e6d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device function implementing element-wise tile set.  <br /></td></tr>
<tr class="separator:a2289398e7d5eaaa3b418fe8eb99e6d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ad3ce98a1ad71b7f91e954e3d6cb45"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a62ad3ce98a1ad71b7f91e954e3d6cb45"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a62ad3ce98a1ad71b7f91e954e3d6cb45">tzset_kernel</a> (lapack::Uplo uplo, int64_t m, int64_t n, scalar_t offdiag_value, scalar_t diag_value, scalar_t *A, int64_t lda)</td></tr>
<tr class="memdesc:a62ad3ce98a1ad71b7f91e954e3d6cb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing element-wise tile set.  <br /></td></tr>
<tr class="separator:a62ad3ce98a1ad71b7f91e954e3d6cb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbb6a459a998511b0fe71915a488879"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a3bbb6a459a998511b0fe71915a488879"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a3bbb6a459a998511b0fe71915a488879">tzset_batch_kernel</a> (lapack::Uplo uplo, int64_t m, int64_t n, scalar_t offdiag_value, scalar_t diag_value, scalar_t **Aarray, int64_t lda)</td></tr>
<tr class="memdesc:a3bbb6a459a998511b0fe71915a488879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing element-wise tile set.  <br /></td></tr>
<tr class="separator:a3bbb6a459a998511b0fe71915a488879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4251f42f05687393d25133b908ec12"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:aec4251f42f05687393d25133b908ec12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#aec4251f42f05687393d25133b908ec12">tzset</a> (lapack::Uplo uplo, int64_t m, int64_t n, scalar_t const &amp;offdiag_value, scalar_t const &amp;diag_value, scalar_t *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:aec4251f42f05687393d25133b908ec12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise trapezoidal tile set.  <br /></td></tr>
<tr class="separator:aec4251f42f05687393d25133b908ec12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9393e4900529f149274ba16dbe674433"><td class="memItemLeft" align="right" valign="top"><a id="a9393e4900529f149274ba16dbe674433" name="a9393e4900529f149274ba16dbe674433"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzset</b> (lapack::Uplo uplo, int64_t m, int64_t n, float const &amp;offdiag_value, float const &amp;diag_value, float *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a9393e4900529f149274ba16dbe674433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b898b4269e7abc950e200d954b186d3"><td class="memItemLeft" align="right" valign="top"><a id="a2b898b4269e7abc950e200d954b186d3" name="a2b898b4269e7abc950e200d954b186d3"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzset</b> (lapack::Uplo uplo, int64_t m, int64_t n, double const &amp;offdiag_value, double const &amp;diag_value, double *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a2b898b4269e7abc950e200d954b186d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7ae14df314f29bfa0a27dbf7f2e530"><td class="memItemLeft" align="right" valign="top"><a id="abe7ae14df314f29bfa0a27dbf7f2e530" name="abe7ae14df314f29bfa0a27dbf7f2e530"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzset</b> (lapack::Uplo uplo, int64_t m, int64_t n, cuFloatComplex const &amp;offdiag_value, cuFloatComplex const &amp;diag_value, cuFloatComplex *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:abe7ae14df314f29bfa0a27dbf7f2e530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9048d11f34e5e5a23b0cf5700ac8c1f1"><td class="memItemLeft" align="right" valign="top"><a id="a9048d11f34e5e5a23b0cf5700ac8c1f1" name="a9048d11f34e5e5a23b0cf5700ac8c1f1"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzset</b> (lapack::Uplo uplo, int64_t m, int64_t n, cuDoubleComplex const &amp;offdiag_value, cuDoubleComplex const &amp;diag_value, cuDoubleComplex *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a9048d11f34e5e5a23b0cf5700ac8c1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eda9ad2e2578bf81c71e08e47190826"><td class="memTemplParams" colspan="2"><a id="a4eda9ad2e2578bf81c71e08e47190826" name="a4eda9ad2e2578bf81c71e08e47190826"></a>
template&lt;typename real_t &gt; </td></tr>
<tr class="memitem:a4eda9ad2e2578bf81c71e08e47190826"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ real_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max_nan</b> (real_t x, real_t y)</td></tr>
<tr class="memdesc:a4eda9ad2e2578bf81c71e08e47190826"><td class="mdescLeft">&#160;</td><td class="mdescRight">max that propogates nan consistently: max_nan( 1,   nan ) = nan max_nan( nan, 1   ) = nan <br /></td></tr>
<tr class="separator:a4eda9ad2e2578bf81c71e08e47190826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d58c036c58fef39e6a5559d529dc8d"><td class="memTemplParams" colspan="2">template&lt;typename real_t &gt; </td></tr>
<tr class="memitem:ae1d58c036c58fef39e6a5559d529dc8d"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#ae1d58c036c58fef39e6a5559d529dc8d">max_nan_reduce</a> (int n, int tid, real_t *x)</td></tr>
<tr class="memdesc:ae1d58c036c58fef39e6a5559d529dc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max reduction of n-element array x, leaving total in x[0].  <br /></td></tr>
<tr class="separator:ae1d58c036c58fef39e6a5559d529dc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12ccce5f8f33571fb780edbec3ac8cf"><td class="memTemplParams" colspan="2">template&lt;typename real_t &gt; </td></tr>
<tr class="memitem:ae12ccce5f8f33571fb780edbec3ac8cf"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#ae12ccce5f8f33571fb780edbec3ac8cf">sum_reduce</a> (int n, int tid, real_t *x)</td></tr>
<tr class="memdesc:ae12ccce5f8f33571fb780edbec3ac8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum reduction of n-element array x, leaving total in x[0].  <br /></td></tr>
<tr class="separator:ae12ccce5f8f33571fb780edbec3ac8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1093865a7c9191829e093fb079714dc"><td class="memItemLeft" align="right" valign="top"><a id="ad1093865a7c9191829e093fb079714dc" name="ad1093865a7c9191829e093fb079714dc"></a>
__host__ __device__ float&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (float x)</td></tr>
<tr class="memdesc:ad1093865a7c9191829e093fb079714dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded versions of absolute value on device. <br /></td></tr>
<tr class="separator:ad1093865a7c9191829e093fb079714dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b1434a066cb444f9b9a0ef50e62a46"><td class="memItemLeft" align="right" valign="top"><a id="a71b1434a066cb444f9b9a0ef50e62a46" name="a71b1434a066cb444f9b9a0ef50e62a46"></a>
__host__ __device__ double&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (double x)</td></tr>
<tr class="separator:a71b1434a066cb444f9b9a0ef50e62a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eca6f85d1ec58b892ef6442bf64b11e"><td class="memItemLeft" align="right" valign="top"><a id="a0eca6f85d1ec58b892ef6442bf64b11e" name="a0eca6f85d1ec58b892ef6442bf64b11e"></a>
__host__ __device__ float&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (cuFloatComplex x)</td></tr>
<tr class="separator:a0eca6f85d1ec58b892ef6442bf64b11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff2fddaf4b4fcdf6a11009add81bdfd"><td class="memItemLeft" align="right" valign="top"><a id="a3ff2fddaf4b4fcdf6a11009add81bdfd" name="a3ff2fddaf4b4fcdf6a11009add81bdfd"></a>
__host__ __device__ double&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (cuDoubleComplex x)</td></tr>
<tr class="separator:a3ff2fddaf4b4fcdf6a11009add81bdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab509b8a6f3b719ada6629086d6d2ce"><td class="memTemplParams" colspan="2"><a id="acab509b8a6f3b719ada6629086d6d2ce" name="acab509b8a6f3b719ada6629086d6d2ce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acab509b8a6f3b719ada6629086d6d2ce"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>axpby</b> (T alpha, T x, T beta, T y)</td></tr>
<tr class="memdesc:acab509b8a6f3b719ada6629086d6d2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded versions of Ax+By on device. <br /></td></tr>
<tr class="separator:acab509b8a6f3b719ada6629086d6d2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27be054de85472125e55b700c6293309"><td class="memItemLeft" align="right" valign="top"><a id="a27be054de85472125e55b700c6293309" name="a27be054de85472125e55b700c6293309"></a>
__host__ __device__ cuFloatComplex&#160;</td><td class="memItemRight" valign="bottom"><b>axpby</b> (cuFloatComplex alpha, cuFloatComplex x, cuFloatComplex beta, cuFloatComplex y)</td></tr>
<tr class="separator:a27be054de85472125e55b700c6293309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae146c3f05608d23c680fdf81029693ec"><td class="memItemLeft" align="right" valign="top"><a id="ae146c3f05608d23c680fdf81029693ec" name="ae146c3f05608d23c680fdf81029693ec"></a>
__host__ __device__ cuDoubleComplex&#160;</td><td class="memItemRight" valign="bottom"><b>axpby</b> (cuDoubleComplex alpha, cuDoubleComplex x, cuDoubleComplex beta, cuDoubleComplex y)</td></tr>
<tr class="separator:ae146c3f05608d23c680fdf81029693ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baf50ff065a8349060ef66f5fd284a5"><td class="memTemplParams" colspan="2">template&lt;typename TA , typename TB &gt; </td></tr>
<tr class="memitem:a7baf50ff065a8349060ef66f5fd284a5"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a7baf50ff065a8349060ef66f5fd284a5">copy</a> (TA a, TB &amp;b)</td></tr>
<tr class="memdesc:a7baf50ff065a8349060ef66f5fd284a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded copy and precision conversion.  <br /></td></tr>
<tr class="separator:a7baf50ff065a8349060ef66f5fd284a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeacaa9b3471174fa9d7223c7e468f79"><td class="memItemLeft" align="right" valign="top"><a id="aaeacaa9b3471174fa9d7223c7e468f79" name="aaeacaa9b3471174fa9d7223c7e468f79"></a>
__host__ __device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> (cuFloatComplex a, cuDoubleComplex &amp;b)</td></tr>
<tr class="memdesc:aaeacaa9b3471174fa9d7223c7e468f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets b = a, converting from complex-float to complex-double. <br /></td></tr>
<tr class="separator:aaeacaa9b3471174fa9d7223c7e468f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf79045504afee2f5a056e82562e307"><td class="memItemLeft" align="right" valign="top"><a id="a6cf79045504afee2f5a056e82562e307" name="a6cf79045504afee2f5a056e82562e307"></a>
__host__ __device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> (cuDoubleComplex a, cuFloatComplex &amp;b)</td></tr>
<tr class="memdesc:a6cf79045504afee2f5a056e82562e307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets b = a, converting from complex-double to complex-float. <br /></td></tr>
<tr class="separator:a6cf79045504afee2f5a056e82562e307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cfe2a4096d000121617fb8e9242de2"><td class="memItemLeft" align="right" valign="top"><a id="aa2cfe2a4096d000121617fb8e9242de2" name="aa2cfe2a4096d000121617fb8e9242de2"></a>
__host__ __device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> (float a, cuFloatComplex &amp;b)</td></tr>
<tr class="memdesc:aa2cfe2a4096d000121617fb8e9242de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets b = a, converting from float to complex-float. <br /></td></tr>
<tr class="separator:aa2cfe2a4096d000121617fb8e9242de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018813ecf38c86396147bbae19deaf4e"><td class="memItemLeft" align="right" valign="top"><a id="a018813ecf38c86396147bbae19deaf4e" name="a018813ecf38c86396147bbae19deaf4e"></a>
__host__ __device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> (double a, cuDoubleComplex &amp;b)</td></tr>
<tr class="memdesc:a018813ecf38c86396147bbae19deaf4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets b = a, converting from double to complex-double. <br /></td></tr>
<tr class="separator:a018813ecf38c86396147bbae19deaf4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b1499908ea453e618a9252ef9e53bd"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a92b1499908ea453e618a9252ef9e53bd"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a92b1499908ea453e618a9252ef9e53bd">sqr</a> (scalar_t x)</td></tr>
<tr class="memdesc:a92b1499908ea453e618a9252ef9e53bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square of number.  <br /></td></tr>
<tr class="separator:a92b1499908ea453e618a9252ef9e53bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdba62bc3e9805fd90143a4fcb513fcd"><td class="memTemplParams" colspan="2">template&lt;typename real_t &gt; </td></tr>
<tr class="memitem:abdba62bc3e9805fd90143a4fcb513fcd"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#abdba62bc3e9805fd90143a4fcb513fcd">combine_sumsq</a> (real_t &amp;scale1, real_t &amp;sumsq1, real_t scale2, real_t sumsq2)</td></tr>
<tr class="memdesc:abdba62bc3e9805fd90143a4fcb513fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two scaled, sum-of-squares representations.  <br /></td></tr>
<tr class="separator:abdba62bc3e9805fd90143a4fcb513fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd9528305fe1f9ab33f80ca12c67961"><td class="memTemplParams" colspan="2">template&lt;typename real_t &gt; </td></tr>
<tr class="memitem:a1fd9528305fe1f9ab33f80ca12c67961"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a1fd9528305fe1f9ab33f80ca12c67961">add_sumsq</a> (real_t &amp;<a class="el" href="group__set.html#ga0930923d5547ec8c39388e5f1dee53e0">scale</a>, real_t &amp;sumsq, real_t absx)</td></tr>
<tr class="memdesc:a1fd9528305fe1f9ab33f80ca12c67961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new value to scaled, sum-of-squares representation.  <br /></td></tr>
<tr class="separator:a1fd9528305fe1f9ab33f80ca12c67961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d1f76d7d2df5931e57604dc5361982"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9d1f76d7d2df5931e57604dc5361982"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#af9d1f76d7d2df5931e57604dc5361982">ceildiv</a> (T x, T y)</td></tr>
<tr class="separator:af9d1f76d7d2df5931e57604dc5361982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dce3ac00519c24f395eb17a101a7781"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3dce3ac00519c24f395eb17a101a7781"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a3dce3ac00519c24f395eb17a101a7781">roundup</a> (T x, T y)</td></tr>
<tr class="separator:a3dce3ac00519c24f395eb17a101a7781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e088812fcbdb360ad8ed7a3f7ad221b"><td class="memItemLeft" align="right" valign="top"><a id="a6e088812fcbdb360ad8ed7a3f7ad221b" name="a6e088812fcbdb360ad8ed7a3f7ad221b"></a>
__host__ __device__ double&#160;</td><td class="memItemRight" valign="bottom"><b>real</b> (cuDoubleComplex x)</td></tr>
<tr class="separator:a6e088812fcbdb360ad8ed7a3f7ad221b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f75f03fedf530c9aeda1417a4be814"><td class="memItemLeft" align="right" valign="top"><a id="a05f75f03fedf530c9aeda1417a4be814" name="a05f75f03fedf530c9aeda1417a4be814"></a>
__host__ __device__ float&#160;</td><td class="memItemRight" valign="bottom"><b>real</b> (cuFloatComplex x)</td></tr>
<tr class="separator:a05f75f03fedf530c9aeda1417a4be814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e72742f86787091b551073c759ee62f"><td class="memItemLeft" align="right" valign="top"><a id="a0e72742f86787091b551073c759ee62f" name="a0e72742f86787091b551073c759ee62f"></a>
__host__ __device__ double&#160;</td><td class="memItemRight" valign="bottom"><b>imag</b> (cuDoubleComplex x)</td></tr>
<tr class="separator:a0e72742f86787091b551073c759ee62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf676db4b4db056945f2fb40b914be07"><td class="memItemLeft" align="right" valign="top"><a id="aaf676db4b4db056945f2fb40b914be07" name="aaf676db4b4db056945f2fb40b914be07"></a>
__host__ __device__ float&#160;</td><td class="memItemRight" valign="bottom"><b>imag</b> (cuFloatComplex x)</td></tr>
<tr class="separator:aaf676db4b4db056945f2fb40b914be07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c587c80cec29caffcc2ea90a1c7bc2"><td class="memItemLeft" align="right" valign="top"><a id="a66c587c80cec29caffcc2ea90a1c7bc2" name="a66c587c80cec29caffcc2ea90a1c7bc2"></a>
__host__ __device__ cuDoubleComplex&#160;</td><td class="memItemRight" valign="bottom"><b>conj</b> (cuDoubleComplex x)</td></tr>
<tr class="separator:a66c587c80cec29caffcc2ea90a1c7bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431c2d0a0d96d75e2d01afa8cc898762"><td class="memItemLeft" align="right" valign="top"><a id="a431c2d0a0d96d75e2d01afa8cc898762" name="a431c2d0a0d96d75e2d01afa8cc898762"></a>
__host__ __device__ cuFloatComplex&#160;</td><td class="memItemRight" valign="bottom"><b>conj</b> (cuFloatComplex x)</td></tr>
<tr class="separator:a431c2d0a0d96d75e2d01afa8cc898762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ab30c23a7dcfc173d5ef0731b0592c"><td class="memItemLeft" align="right" valign="top"><a id="aa7ab30c23a7dcfc173d5ef0731b0592c" name="aa7ab30c23a7dcfc173d5ef0731b0592c"></a>
__host__ __device__ double&#160;</td><td class="memItemRight" valign="bottom"><b>real</b> (double x)</td></tr>
<tr class="separator:aa7ab30c23a7dcfc173d5ef0731b0592c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e78771f82f80e6463968f00f9f23b5c"><td class="memItemLeft" align="right" valign="top"><a id="a4e78771f82f80e6463968f00f9f23b5c" name="a4e78771f82f80e6463968f00f9f23b5c"></a>
__host__ __device__ float&#160;</td><td class="memItemRight" valign="bottom"><b>real</b> (float x)</td></tr>
<tr class="separator:a4e78771f82f80e6463968f00f9f23b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7b76d59d16a26be8daa4ec61a1e949"><td class="memItemLeft" align="right" valign="top">__host__ __device__ double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#abe7b76d59d16a26be8daa4ec61a1e949">imag</a> (double x)</td></tr>
<tr class="separator:abe7b76d59d16a26be8daa4ec61a1e949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974ad1a85045470725d89c7775f6b949"><td class="memItemLeft" align="right" valign="top"><a id="a974ad1a85045470725d89c7775f6b949" name="a974ad1a85045470725d89c7775f6b949"></a>
__host__ __device__ float&#160;</td><td class="memItemRight" valign="bottom"><b>imag</b> (float x)</td></tr>
<tr class="separator:a974ad1a85045470725d89c7775f6b949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5493c7f0655a40c1124875e72591d0df"><td class="memItemLeft" align="right" valign="top">__host__ __device__ double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a5493c7f0655a40c1124875e72591d0df">conj</a> (double x)</td></tr>
<tr class="separator:a5493c7f0655a40c1124875e72591d0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3255acaa908e77cdb95092f9bc9e613f"><td class="memItemLeft" align="right" valign="top"><a id="a3255acaa908e77cdb95092f9bc9e613f" name="a3255acaa908e77cdb95092f9bc9e613f"></a>
__host__ __device__ float&#160;</td><td class="memItemRight" valign="bottom"><b>conj</b> (float x)</td></tr>
<tr class="separator:a3255acaa908e77cdb95092f9bc9e613f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ba5ee1ec3296002657df8bd27469b2"><td class="memItemLeft" align="right" valign="top"><a id="a57ba5ee1ec3296002657df8bd27469b2" name="a57ba5ee1ec3296002657df8bd27469b2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a57ba5ee1ec3296002657df8bd27469b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gescale_row_col_batch</b> (Equed equed, int64_t m, int64_t n, float const *const *Rarray, float const *const *Carray, float **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a57ba5ee1ec3296002657df8bd27469b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a297de83852d4a393d6358e83ceb51c"><td class="memItemLeft" align="right" valign="top"><a id="a5a297de83852d4a393d6358e83ceb51c" name="a5a297de83852d4a393d6358e83ceb51c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5a297de83852d4a393d6358e83ceb51c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gescale_row_col_batch</b> (Equed equed, int64_t m, int64_t n, double const *const *Rarray, double const *const *Carray, double **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a5a297de83852d4a393d6358e83ceb51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a26edede7caa43ee90e2e1ba684429c"><td class="memItemLeft" align="right" valign="top"><a id="a9a26edede7caa43ee90e2e1ba684429c" name="a9a26edede7caa43ee90e2e1ba684429c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9a26edede7caa43ee90e2e1ba684429c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gescale_row_col_batch</b> (Equed equed, int64_t m, int64_t n, float const *const *Rarray, float const *const *Carray, std::complex&lt; float &gt; **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a9a26edede7caa43ee90e2e1ba684429c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3893b048d5fa049aacf956b985a844de"><td class="memItemLeft" align="right" valign="top"><a id="a3893b048d5fa049aacf956b985a844de" name="a3893b048d5fa049aacf956b985a844de"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3893b048d5fa049aacf956b985a844de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gescale_row_col_batch</b> (Equed equed, int64_t m, int64_t n, double const *const *Rarray, double const *const *Carray, std::complex&lt; double &gt; **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a3893b048d5fa049aacf956b985a844de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8de2125ef08f11fd86c397a9d2b90d"><td class="memItemLeft" align="right" valign="top"><a id="aae8de2125ef08f11fd86c397a9d2b90d" name="aae8de2125ef08f11fd86c397a9d2b90d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aae8de2125ef08f11fd86c397a9d2b90d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gescale_row_col_batch</b> (Equed equed, int64_t m, int64_t n, std::complex&lt; float &gt; const *const *Rarray, std::complex&lt; float &gt; const *const *Carray, std::complex&lt; float &gt; **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aae8de2125ef08f11fd86c397a9d2b90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d0c8cd523c4587fdc70d1399a201c1"><td class="memItemLeft" align="right" valign="top"><a id="af0d0c8cd523c4587fdc70d1399a201c1" name="af0d0c8cd523c4587fdc70d1399a201c1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af0d0c8cd523c4587fdc70d1399a201c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gescale_row_col_batch</b> (Equed equed, int64_t m, int64_t n, std::complex&lt; double &gt; const *const *Rarray, std::complex&lt; double &gt; const *const *Carray, std::complex&lt; double &gt; **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:af0d0c8cd523c4587fdc70d1399a201c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bd330e0a3740aada62bcf8dc5b45d0"><td class="memItemLeft" align="right" valign="top"><a id="a19bd330e0a3740aada62bcf8dc5b45d0" name="a19bd330e0a3740aada62bcf8dc5b45d0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a19bd330e0a3740aada62bcf8dc5b45d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>geadd</b> (int64_t m, int64_t n, std::complex&lt; float &gt; const &amp;alpha, std::complex&lt; float &gt; *A, int64_t lda, std::complex&lt; float &gt; const &amp;beta, std::complex&lt; float &gt; *B, int64_t ldb, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a19bd330e0a3740aada62bcf8dc5b45d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9b85d994e28928353b1f8e7d96592e"><td class="memItemLeft" align="right" valign="top"><a id="adc9b85d994e28928353b1f8e7d96592e" name="adc9b85d994e28928353b1f8e7d96592e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adc9b85d994e28928353b1f8e7d96592e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>geadd</b> (int64_t m, int64_t n, std::complex&lt; double &gt; const &amp;alpha, std::complex&lt; double &gt; *A, int64_t lda, std::complex&lt; double &gt; const &amp;beta, std::complex&lt; double &gt; *B, int64_t ldb, blas::Queue &amp;queue)</td></tr>
<tr class="separator:adc9b85d994e28928353b1f8e7d96592e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17757889d2029616fe4bc5494f14d85"><td class="memItemLeft" align="right" valign="top"><a id="ab17757889d2029616fe4bc5494f14d85" name="ab17757889d2029616fe4bc5494f14d85"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab17757889d2029616fe4bc5494f14d85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>geadd</b> (int64_t m, int64_t n, double const &amp;alpha, double *A, int64_t lda, double const &amp;beta, double *B, int64_t ldb, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ab17757889d2029616fe4bc5494f14d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86812f8d130318ba4eac55ee2a54309c"><td class="memItemLeft" align="right" valign="top"><a id="a86812f8d130318ba4eac55ee2a54309c" name="a86812f8d130318ba4eac55ee2a54309c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a86812f8d130318ba4eac55ee2a54309c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>geadd</b> (int64_t m, int64_t n, float const &amp;alpha, float *A, int64_t lda, float const &amp;beta, float *B, int64_t ldb, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a86812f8d130318ba4eac55ee2a54309c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b94204eeae40b97e27cd077f7b2084"><td class="memTemplParams" colspan="2"><a id="ad3b94204eeae40b97e27cd077f7b2084" name="ad3b94204eeae40b97e27cd077f7b2084"></a>
template&lt;typename x_scalar_t , typename y_scalar_t &gt; </td></tr>
<tr class="memitem:ad3b94204eeae40b97e27cd077f7b2084"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t m, int64_t n, x_scalar_t **dA_array, int64_t lda, y_scalar_t **dAT_array, int64_t ldat, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ad3b94204eeae40b97e27cd077f7b2084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ef70008ce054c64d39947a3663cf55"><td class="memItemLeft" align="right" valign="top"><a id="a31ef70008ce054c64d39947a3663cf55" name="a31ef70008ce054c64d39947a3663cf55"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a31ef70008ce054c64d39947a3663cf55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, std::complex&lt; float &gt; const *const *Aarray, int64_t lda, std::complex&lt; float &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a31ef70008ce054c64d39947a3663cf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6e64c75805c0e3f908127f955fc002"><td class="memItemLeft" align="right" valign="top"><a id="a9c6e64c75805c0e3f908127f955fc002" name="a9c6e64c75805c0e3f908127f955fc002"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9c6e64c75805c0e3f908127f955fc002"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, std::complex&lt; float &gt; const *const *Aarray, int64_t lda, std::complex&lt; double &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a9c6e64c75805c0e3f908127f955fc002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c4618e5bcb0b9850861f0ea8cad409"><td class="memItemLeft" align="right" valign="top"><a id="ac9c4618e5bcb0b9850861f0ea8cad409" name="ac9c4618e5bcb0b9850861f0ea8cad409"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac9c4618e5bcb0b9850861f0ea8cad409"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, std::complex&lt; double &gt; const *const *Aarray, int64_t lda, std::complex&lt; double &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ac9c4618e5bcb0b9850861f0ea8cad409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a1c6124cdcf3be8d8d53e65e1a0f59"><td class="memItemLeft" align="right" valign="top"><a id="a68a1c6124cdcf3be8d8d53e65e1a0f59" name="a68a1c6124cdcf3be8d8d53e65e1a0f59"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a68a1c6124cdcf3be8d8d53e65e1a0f59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, std::complex&lt; double &gt; const *const *Aarray, int64_t lda, std::complex&lt; float &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a68a1c6124cdcf3be8d8d53e65e1a0f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa983edfc4d421665a0a493da395f7546"><td class="memItemLeft" align="right" valign="top"><a id="aa983edfc4d421665a0a493da395f7546" name="aa983edfc4d421665a0a493da395f7546"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa983edfc4d421665a0a493da395f7546"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, float const *const *Aarray, int64_t lda, std::complex&lt; float &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aa983edfc4d421665a0a493da395f7546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab767a70c29ff984cc142d2c3428f19de"><td class="memItemLeft" align="right" valign="top"><a id="ab767a70c29ff984cc142d2c3428f19de" name="ab767a70c29ff984cc142d2c3428f19de"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab767a70c29ff984cc142d2c3428f19de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, double const *const *Aarray, int64_t lda, std::complex&lt; double &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ab767a70c29ff984cc142d2c3428f19de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19742eaa4b016be9e0a654a2a1f4bbca"><td class="memItemLeft" align="right" valign="top"><a id="a19742eaa4b016be9e0a654a2a1f4bbca" name="a19742eaa4b016be9e0a654a2a1f4bbca"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a19742eaa4b016be9e0a654a2a1f4bbca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, double const *const *Aarray, int64_t lda, double **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a19742eaa4b016be9e0a654a2a1f4bbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc334cdd2f5de5b7ee4adf5e46099d4"><td class="memItemLeft" align="right" valign="top"><a id="a9fc334cdd2f5de5b7ee4adf5e46099d4" name="a9fc334cdd2f5de5b7ee4adf5e46099d4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9fc334cdd2f5de5b7ee4adf5e46099d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, double const *const *Aarray, int64_t lda, float **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a9fc334cdd2f5de5b7ee4adf5e46099d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae84a2a3ff8721f2e3a42349283151f"><td class="memItemLeft" align="right" valign="top"><a id="abae84a2a3ff8721f2e3a42349283151f" name="abae84a2a3ff8721f2e3a42349283151f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abae84a2a3ff8721f2e3a42349283151f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, float const *const *Aarray, int64_t lda, float **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:abae84a2a3ff8721f2e3a42349283151f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61db10fd1a64e9be0006f5188b44a1d1"><td class="memItemLeft" align="right" valign="top"><a id="a61db10fd1a64e9be0006f5188b44a1d1" name="a61db10fd1a64e9be0006f5188b44a1d1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a61db10fd1a64e9be0006f5188b44a1d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gecopy</b> (int64_t m, int64_t n, float const *const *Aarray, int64_t lda, double **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a61db10fd1a64e9be0006f5188b44a1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0466b714831e8117c1fcf86c9367e29f"><td class="memItemLeft" align="right" valign="top"><a id="a0466b714831e8117c1fcf86c9367e29f" name="a0466b714831e8117c1fcf86c9367e29f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0466b714831e8117c1fcf86c9367e29f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>genorm</b> (Norm in_norm, <a class="el" href="group__enum.html#ga8adf8aeaee2927385592d44ff23b95bb">NormScope</a> scope, int64_t m, int64_t n, std::complex&lt; float &gt; const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a0466b714831e8117c1fcf86c9367e29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73abcb8bb707ba50ca8882474710c17"><td class="memItemLeft" align="right" valign="top"><a id="ab73abcb8bb707ba50ca8882474710c17" name="ab73abcb8bb707ba50ca8882474710c17"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab73abcb8bb707ba50ca8882474710c17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>genorm</b> (Norm in_norm, <a class="el" href="group__enum.html#ga8adf8aeaee2927385592d44ff23b95bb">NormScope</a> scope, int64_t m, int64_t n, std::complex&lt; double &gt; const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ab73abcb8bb707ba50ca8882474710c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71894dc0997427525e8230d8917d2bd"><td class="memItemLeft" align="right" valign="top"><a id="ad71894dc0997427525e8230d8917d2bd" name="ad71894dc0997427525e8230d8917d2bd"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad71894dc0997427525e8230d8917d2bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>genorm</b> (Norm in_norm, <a class="el" href="group__enum.html#ga8adf8aeaee2927385592d44ff23b95bb">NormScope</a> scope, int64_t m, int64_t n, double const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ad71894dc0997427525e8230d8917d2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8beb02b074e4718a7770633d3c6c79d0"><td class="memItemLeft" align="right" valign="top"><a id="a8beb02b074e4718a7770633d3c6c79d0" name="a8beb02b074e4718a7770633d3c6c79d0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8beb02b074e4718a7770633d3c6c79d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>genorm</b> (Norm in_norm, <a class="el" href="group__enum.html#ga8adf8aeaee2927385592d44ff23b95bb">NormScope</a> scope, int64_t m, int64_t n, float const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a8beb02b074e4718a7770633d3c6c79d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040ad1c4b9eb6c38228cb84577b14911"><td class="memItemLeft" align="right" valign="top"><a id="a040ad1c4b9eb6c38228cb84577b14911" name="a040ad1c4b9eb6c38228cb84577b14911"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a040ad1c4b9eb6c38228cb84577b14911"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gescale</b> (int64_t m, int64_t n, float numer, float denom, std::complex&lt; float &gt; *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a040ad1c4b9eb6c38228cb84577b14911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b9fb1c065a2ee3a9d4ee8725371196"><td class="memItemLeft" align="right" valign="top"><a id="ae2b9fb1c065a2ee3a9d4ee8725371196" name="ae2b9fb1c065a2ee3a9d4ee8725371196"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae2b9fb1c065a2ee3a9d4ee8725371196"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gescale</b> (int64_t m, int64_t n, std::complex&lt; float &gt; numer, std::complex&lt; float &gt; denom, std::complex&lt; float &gt; *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ae2b9fb1c065a2ee3a9d4ee8725371196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6305778f274a7c589fdfa53c862171bc"><td class="memItemLeft" align="right" valign="top"><a id="a6305778f274a7c589fdfa53c862171bc" name="a6305778f274a7c589fdfa53c862171bc"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6305778f274a7c589fdfa53c862171bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gescale</b> (int64_t m, int64_t n, double numer, double denom, std::complex&lt; double &gt; *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a6305778f274a7c589fdfa53c862171bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6049a5791c37bbe2abfadc0738b4f3ce"><td class="memItemLeft" align="right" valign="top"><a id="a6049a5791c37bbe2abfadc0738b4f3ce" name="a6049a5791c37bbe2abfadc0738b4f3ce"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6049a5791c37bbe2abfadc0738b4f3ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gescale</b> (int64_t m, int64_t n, std::complex&lt; double &gt; numer, std::complex&lt; double &gt; denom, std::complex&lt; double &gt; *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a6049a5791c37bbe2abfadc0738b4f3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47819b5febed6bd2aebb10400946e25"><td class="memItemLeft" align="right" valign="top"><a id="ac47819b5febed6bd2aebb10400946e25" name="ac47819b5febed6bd2aebb10400946e25"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac47819b5febed6bd2aebb10400946e25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gescale</b> (int64_t m, int64_t n, double numer, double denom, double *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ac47819b5febed6bd2aebb10400946e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af451f0b1f1034e5ff023814ff8355a90"><td class="memItemLeft" align="right" valign="top"><a id="af451f0b1f1034e5ff023814ff8355a90" name="af451f0b1f1034e5ff023814ff8355a90"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af451f0b1f1034e5ff023814ff8355a90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gescale</b> (int64_t m, int64_t n, float numer, float denom, float *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:af451f0b1f1034e5ff023814ff8355a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5aed41fe5042f5fd0010d6b039a31d"><td class="memItemLeft" align="right" valign="top"><a id="a0e5aed41fe5042f5fd0010d6b039a31d" name="a0e5aed41fe5042f5fd0010d6b039a31d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0e5aed41fe5042f5fd0010d6b039a31d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>geset</b> (int64_t m, int64_t n, std::complex&lt; float &gt; const &amp;offdiag_value, std::complex&lt; float &gt; const &amp;diag_value, std::complex&lt; float &gt; *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a0e5aed41fe5042f5fd0010d6b039a31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244f5c1a7a275137ed2140035462f771"><td class="memItemLeft" align="right" valign="top"><a id="a244f5c1a7a275137ed2140035462f771" name="a244f5c1a7a275137ed2140035462f771"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a244f5c1a7a275137ed2140035462f771"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>geset</b> (int64_t m, int64_t n, std::complex&lt; double &gt; const &amp;offdiag_value, std::complex&lt; double &gt; const &amp;diag_value, std::complex&lt; double &gt; *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a244f5c1a7a275137ed2140035462f771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060c4ee409836748ee77fc4d385eaba4"><td class="memItemLeft" align="right" valign="top"><a id="a060c4ee409836748ee77fc4d385eaba4" name="a060c4ee409836748ee77fc4d385eaba4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a060c4ee409836748ee77fc4d385eaba4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>geset</b> (int64_t m, int64_t n, double const &amp;offdiag_value, double const &amp;diag_value, double *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a060c4ee409836748ee77fc4d385eaba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e98eb332d3e6adc9a4e7ea2dc98d76c"><td class="memItemLeft" align="right" valign="top"><a id="a7e98eb332d3e6adc9a4e7ea2dc98d76c" name="a7e98eb332d3e6adc9a4e7ea2dc98d76c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7e98eb332d3e6adc9a4e7ea2dc98d76c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>geset</b> (int64_t m, int64_t n, float const &amp;offdiag_value, float const &amp;diag_value, float *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a7e98eb332d3e6adc9a4e7ea2dc98d76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27edea97ec1f4719edef2be687bdd6a9"><td class="memItemLeft" align="right" valign="top"><a id="a27edea97ec1f4719edef2be687bdd6a9" name="a27edea97ec1f4719edef2be687bdd6a9"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a27edea97ec1f4719edef2be687bdd6a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>henorm</b> (Norm in_norm, Uplo uplo, int64_t n, std::complex&lt; float &gt; const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a27edea97ec1f4719edef2be687bdd6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2776ca4bba42565b803c381fee5dd605"><td class="memItemLeft" align="right" valign="top"><a id="a2776ca4bba42565b803c381fee5dd605" name="a2776ca4bba42565b803c381fee5dd605"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2776ca4bba42565b803c381fee5dd605"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>henorm</b> (Norm in_norm, Uplo uplo, int64_t n, std::complex&lt; double &gt; const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a2776ca4bba42565b803c381fee5dd605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac649357f33d724d8edeaa559f5e5258d"><td class="memItemLeft" align="right" valign="top"><a id="ac649357f33d724d8edeaa559f5e5258d" name="ac649357f33d724d8edeaa559f5e5258d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac649357f33d724d8edeaa559f5e5258d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>henorm</b> (Norm in_norm, Uplo uplo, int64_t n, double const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ac649357f33d724d8edeaa559f5e5258d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d3d001f6e5726526ece20e4a0f830e"><td class="memItemLeft" align="right" valign="top"><a id="af2d3d001f6e5726526ece20e4a0f830e" name="af2d3d001f6e5726526ece20e4a0f830e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af2d3d001f6e5726526ece20e4a0f830e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>henorm</b> (Norm in_norm, Uplo uplo, int64_t n, float const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:af2d3d001f6e5726526ece20e4a0f830e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944cb3384c8a6bee877945c0419da978"><td class="memItemLeft" align="right" valign="top"><a id="a944cb3384c8a6bee877945c0419da978" name="a944cb3384c8a6bee877945c0419da978"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a944cb3384c8a6bee877945c0419da978"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>synorm</b> (Norm in_norm, Uplo uplo, int64_t n, std::complex&lt; float &gt; const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a944cb3384c8a6bee877945c0419da978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2387a2d54e7fadc7d68814657f3f606"><td class="memItemLeft" align="right" valign="top"><a id="ac2387a2d54e7fadc7d68814657f3f606" name="ac2387a2d54e7fadc7d68814657f3f606"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac2387a2d54e7fadc7d68814657f3f606"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>synorm</b> (Norm in_norm, Uplo uplo, int64_t n, std::complex&lt; double &gt; const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ac2387a2d54e7fadc7d68814657f3f606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c26e25ab32c9e00c15b5242ae5fc8f"><td class="memItemLeft" align="right" valign="top"><a id="a99c26e25ab32c9e00c15b5242ae5fc8f" name="a99c26e25ab32c9e00c15b5242ae5fc8f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a99c26e25ab32c9e00c15b5242ae5fc8f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>synormOffdiag</b> (Norm in_norm, int64_t m, int64_t n, std::complex&lt; float &gt; const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a99c26e25ab32c9e00c15b5242ae5fc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fc1486056d436232855b84d49d8c26"><td class="memItemLeft" align="right" valign="top"><a id="a48fc1486056d436232855b84d49d8c26" name="a48fc1486056d436232855b84d49d8c26"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a48fc1486056d436232855b84d49d8c26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>synormOffdiag</b> (Norm in_norm, int64_t m, int64_t n, std::complex&lt; double &gt; const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a48fc1486056d436232855b84d49d8c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74078380abf3b12d265c4bbc8ed2f67a"><td class="memItemLeft" align="right" valign="top"><a id="a74078380abf3b12d265c4bbc8ed2f67a" name="a74078380abf3b12d265c4bbc8ed2f67a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a74078380abf3b12d265c4bbc8ed2f67a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>synorm</b> (Norm in_norm, Uplo uplo, int64_t n, double const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a74078380abf3b12d265c4bbc8ed2f67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd5bfbc53b7f7d5f80b6c752d87d35a"><td class="memItemLeft" align="right" valign="top"><a id="a1dd5bfbc53b7f7d5f80b6c752d87d35a" name="a1dd5bfbc53b7f7d5f80b6c752d87d35a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1dd5bfbc53b7f7d5f80b6c752d87d35a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>synorm</b> (Norm in_norm, Uplo uplo, int64_t n, float const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a1dd5bfbc53b7f7d5f80b6c752d87d35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08907507aecb634cda68f617c12e009"><td class="memItemLeft" align="right" valign="top"><a id="ae08907507aecb634cda68f617c12e009" name="ae08907507aecb634cda68f617c12e009"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae08907507aecb634cda68f617c12e009"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>synormOffdiag</b> (Norm in_norm, int64_t m, int64_t n, double const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ae08907507aecb634cda68f617c12e009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91e705f1e9cd4ca1138e6329590b936"><td class="memItemLeft" align="right" valign="top"><a id="ab91e705f1e9cd4ca1138e6329590b936" name="ab91e705f1e9cd4ca1138e6329590b936"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab91e705f1e9cd4ca1138e6329590b936"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>synormOffdiag</b> (Norm in_norm, int64_t m, int64_t n, float const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ab91e705f1e9cd4ca1138e6329590b936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8401837be905e3f657391bf9d17283"><td class="memItemLeft" align="right" valign="top"><a id="a2f8401837be905e3f657391bf9d17283" name="a2f8401837be905e3f657391bf9d17283"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2f8401837be905e3f657391bf9d17283"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t n, std::complex&lt; float &gt; *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a2f8401837be905e3f657391bf9d17283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a7c8e9c2d41e6aa9636acb528a3587"><td class="memItemLeft" align="right" valign="top"><a id="ac3a7c8e9c2d41e6aa9636acb528a3587" name="ac3a7c8e9c2d41e6aa9636acb528a3587"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac3a7c8e9c2d41e6aa9636acb528a3587"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t n, std::complex&lt; double &gt; *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ac3a7c8e9c2d41e6aa9636acb528a3587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc66f864c6e879af57222d59fa10bb5a"><td class="memItemLeft" align="right" valign="top"><a id="adc66f864c6e879af57222d59fa10bb5a" name="adc66f864c6e879af57222d59fa10bb5a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adc66f864c6e879af57222d59fa10bb5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t n, std::complex&lt; float &gt; **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:adc66f864c6e879af57222d59fa10bb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c4eeae072e8fca1b10a2b15b3673fa"><td class="memItemLeft" align="right" valign="top"><a id="a46c4eeae072e8fca1b10a2b15b3673fa" name="a46c4eeae072e8fca1b10a2b15b3673fa"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a46c4eeae072e8fca1b10a2b15b3673fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t n, std::complex&lt; double &gt; **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a46c4eeae072e8fca1b10a2b15b3673fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05d46dece91c708d2ecb84c48573d8d"><td class="memItemLeft" align="right" valign="top"><a id="af05d46dece91c708d2ecb84c48573d8d" name="af05d46dece91c708d2ecb84c48573d8d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af05d46dece91c708d2ecb84c48573d8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t m, int64_t n, std::complex&lt; float &gt; *A, int64_t lda, std::complex&lt; float &gt; *AT, int64_t ldat, blas::Queue &amp;queue)</td></tr>
<tr class="separator:af05d46dece91c708d2ecb84c48573d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d46d306102403a50dd248a26419cf5"><td class="memItemLeft" align="right" valign="top"><a id="ad2d46d306102403a50dd248a26419cf5" name="ad2d46d306102403a50dd248a26419cf5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad2d46d306102403a50dd248a26419cf5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t m, int64_t n, std::complex&lt; double &gt; *A, int64_t lda, std::complex&lt; double &gt; *AT, int64_t ldat, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ad2d46d306102403a50dd248a26419cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a43162d06da920da26cce17e3c2c26"><td class="memItemLeft" align="right" valign="top"><a id="ad0a43162d06da920da26cce17e3c2c26" name="ad0a43162d06da920da26cce17e3c2c26"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad0a43162d06da920da26cce17e3c2c26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t m, int64_t n, std::complex&lt; float &gt; **Aarray, int64_t lda, std::complex&lt; float &gt; **ATarray, int64_t ldat, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ad0a43162d06da920da26cce17e3c2c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362dc620a96df24d934d17af4fc81515"><td class="memItemLeft" align="right" valign="top"><a id="a362dc620a96df24d934d17af4fc81515" name="a362dc620a96df24d934d17af4fc81515"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a362dc620a96df24d934d17af4fc81515"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t m, int64_t n, std::complex&lt; double &gt; **Aarray, int64_t lda, std::complex&lt; double &gt; **ATarray, int64_t ldat, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a362dc620a96df24d934d17af4fc81515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2657de97907008665fcbb881fc7802e1"><td class="memItemLeft" align="right" valign="top"><a id="a2657de97907008665fcbb881fc7802e1" name="a2657de97907008665fcbb881fc7802e1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2657de97907008665fcbb881fc7802e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t n, float *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a2657de97907008665fcbb881fc7802e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae173b238463e22f573f7732641d95c2f"><td class="memItemLeft" align="right" valign="top"><a id="ae173b238463e22f573f7732641d95c2f" name="ae173b238463e22f573f7732641d95c2f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae173b238463e22f573f7732641d95c2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t n, double *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ae173b238463e22f573f7732641d95c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f338940a14bef6147da18888b9a9035"><td class="memItemLeft" align="right" valign="top"><a id="a1f338940a14bef6147da18888b9a9035" name="a1f338940a14bef6147da18888b9a9035"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1f338940a14bef6147da18888b9a9035"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t n, float **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a1f338940a14bef6147da18888b9a9035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975a0bb7934ff60e154a9164b122ef4c"><td class="memItemLeft" align="right" valign="top"><a id="a975a0bb7934ff60e154a9164b122ef4c" name="a975a0bb7934ff60e154a9164b122ef4c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a975a0bb7934ff60e154a9164b122ef4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t n, double **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a975a0bb7934ff60e154a9164b122ef4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9ed60faedc11ca1bac0ef09c41e2f0"><td class="memItemLeft" align="right" valign="top"><a id="a2b9ed60faedc11ca1bac0ef09c41e2f0" name="a2b9ed60faedc11ca1bac0ef09c41e2f0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2b9ed60faedc11ca1bac0ef09c41e2f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t m, int64_t n, float *A, int64_t lda, float *AT, int64_t ldat, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a2b9ed60faedc11ca1bac0ef09c41e2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563c8e9eb7209eaae2e5767e57306dc3"><td class="memItemLeft" align="right" valign="top"><a id="a563c8e9eb7209eaae2e5767e57306dc3" name="a563c8e9eb7209eaae2e5767e57306dc3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a563c8e9eb7209eaae2e5767e57306dc3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t m, int64_t n, double *A, int64_t lda, double *AT, int64_t ldat, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a563c8e9eb7209eaae2e5767e57306dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b78de1d331e1044770edb1a6667d380"><td class="memItemLeft" align="right" valign="top"><a id="a7b78de1d331e1044770edb1a6667d380" name="a7b78de1d331e1044770edb1a6667d380"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7b78de1d331e1044770edb1a6667d380"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t m, int64_t n, float **Aarray, int64_t lda, float **ATarray, int64_t ldat, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a7b78de1d331e1044770edb1a6667d380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152bac0fec3ef2350a19d8158f8df87b"><td class="memItemLeft" align="right" valign="top"><a id="a152bac0fec3ef2350a19d8158f8df87b" name="a152bac0fec3ef2350a19d8158f8df87b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a152bac0fec3ef2350a19d8158f8df87b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t m, int64_t n, double **Aarray, int64_t lda, double **ATarray, int64_t ldat, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a152bac0fec3ef2350a19d8158f8df87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9f8509a5f7ed5fd1d2b5c27ca24403"><td class="memItemLeft" align="right" valign="top"><a id="acb9f8509a5f7ed5fd1d2b5c27ca24403" name="acb9f8509a5f7ed5fd1d2b5c27ca24403"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acb9f8509a5f7ed5fd1d2b5c27ca24403"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trnorm</b> (Norm in_norm, Uplo uplo, Diag diag, int64_t m, int64_t n, std::complex&lt; float &gt; const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:acb9f8509a5f7ed5fd1d2b5c27ca24403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdc56c6e456faadfbded33f1f0b69ba"><td class="memItemLeft" align="right" valign="top"><a id="a8cdc56c6e456faadfbded33f1f0b69ba" name="a8cdc56c6e456faadfbded33f1f0b69ba"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8cdc56c6e456faadfbded33f1f0b69ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trnorm</b> (Norm in_norm, Uplo uplo, Diag diag, int64_t m, int64_t n, std::complex&lt; double &gt; const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a8cdc56c6e456faadfbded33f1f0b69ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963a76712792f1f89819a7d1ee5e0ea2"><td class="memItemLeft" align="right" valign="top"><a id="a963a76712792f1f89819a7d1ee5e0ea2" name="a963a76712792f1f89819a7d1ee5e0ea2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a963a76712792f1f89819a7d1ee5e0ea2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trnorm</b> (Norm in_norm, Uplo uplo, Diag diag, int64_t m, int64_t n, double const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a963a76712792f1f89819a7d1ee5e0ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb3fc88b6f6cc31041b572e3808250e"><td class="memItemLeft" align="right" valign="top"><a id="aadb3fc88b6f6cc31041b572e3808250e" name="aadb3fc88b6f6cc31041b572e3808250e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aadb3fc88b6f6cc31041b572e3808250e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trnorm</b> (Norm in_norm, Uplo uplo, Diag diag, int64_t m, int64_t n, float const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aadb3fc88b6f6cc31041b572e3808250e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e4c2902a3fb126e3a3dd44b8ec952e"><td class="memItemLeft" align="right" valign="top"><a id="af7e4c2902a3fb126e3a3dd44b8ec952e" name="af7e4c2902a3fb126e3a3dd44b8ec952e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af7e4c2902a3fb126e3a3dd44b8ec952e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzadd</b> (Uplo uplo, int64_t m, int64_t n, std::complex&lt; float &gt; const &amp;alpha, std::complex&lt; float &gt; **Aarray, int64_t lda, std::complex&lt; float &gt; const &amp;beta, std::complex&lt; float &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:af7e4c2902a3fb126e3a3dd44b8ec952e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449b6f685177ed8d0a83d4d3cfca3890"><td class="memItemLeft" align="right" valign="top"><a id="a449b6f685177ed8d0a83d4d3cfca3890" name="a449b6f685177ed8d0a83d4d3cfca3890"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a449b6f685177ed8d0a83d4d3cfca3890"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzadd</b> (Uplo uplo, int64_t m, int64_t n, std::complex&lt; double &gt; const &amp;alpha, std::complex&lt; double &gt; **Aarray, int64_t lda, std::complex&lt; double &gt; const &amp;beta, std::complex&lt; double &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a449b6f685177ed8d0a83d4d3cfca3890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b0f1921ca60bfe591337ea4ec9f02f"><td class="memItemLeft" align="right" valign="top"><a id="a95b0f1921ca60bfe591337ea4ec9f02f" name="a95b0f1921ca60bfe591337ea4ec9f02f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a95b0f1921ca60bfe591337ea4ec9f02f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzadd</b> (Uplo uplo, int64_t m, int64_t n, double const &amp;alpha, double **Aarray, int64_t lda, double const &amp;beta, double **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a95b0f1921ca60bfe591337ea4ec9f02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301739b186e93a3aa4b62a154f07f1b4"><td class="memItemLeft" align="right" valign="top"><a id="a301739b186e93a3aa4b62a154f07f1b4" name="a301739b186e93a3aa4b62a154f07f1b4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a301739b186e93a3aa4b62a154f07f1b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzadd</b> (Uplo uplo, int64_t m, int64_t n, float const &amp;alpha, float **Aarray, int64_t lda, float const &amp;beta, float **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a301739b186e93a3aa4b62a154f07f1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50396da55ac0a1ed2e690b7eb514cfc"><td class="memItemLeft" align="right" valign="top"><a id="ae50396da55ac0a1ed2e690b7eb514cfc" name="ae50396da55ac0a1ed2e690b7eb514cfc"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae50396da55ac0a1ed2e690b7eb514cfc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzcopy</b> (Uplo uplo, int64_t m, int64_t n, std::complex&lt; float &gt; const *const *Aarray, int64_t lda, std::complex&lt; float &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ae50396da55ac0a1ed2e690b7eb514cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bb81ff9c269056485815269af90ff6"><td class="memItemLeft" align="right" valign="top"><a id="a62bb81ff9c269056485815269af90ff6" name="a62bb81ff9c269056485815269af90ff6"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a62bb81ff9c269056485815269af90ff6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzcopy</b> (Uplo uplo, int64_t m, int64_t n, std::complex&lt; float &gt; const *const *Aarray, int64_t lda, std::complex&lt; double &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a62bb81ff9c269056485815269af90ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1d624b3aed1c6772d0d0073bba42be"><td class="memItemLeft" align="right" valign="top"><a id="a5a1d624b3aed1c6772d0d0073bba42be" name="a5a1d624b3aed1c6772d0d0073bba42be"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5a1d624b3aed1c6772d0d0073bba42be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzcopy</b> (Uplo uplo, int64_t m, int64_t n, std::complex&lt; double &gt; const *const *Aarray, int64_t lda, std::complex&lt; double &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a5a1d624b3aed1c6772d0d0073bba42be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bccc17a0d252e7d0561658c345cd66f"><td class="memItemLeft" align="right" valign="top"><a id="a3bccc17a0d252e7d0561658c345cd66f" name="a3bccc17a0d252e7d0561658c345cd66f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3bccc17a0d252e7d0561658c345cd66f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzcopy</b> (Uplo uplo, int64_t m, int64_t n, std::complex&lt; double &gt; const *const *Aarray, int64_t lda, std::complex&lt; float &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a3bccc17a0d252e7d0561658c345cd66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5021d4b369ffd066640e18858c85e1ac"><td class="memItemLeft" align="right" valign="top"><a id="a5021d4b369ffd066640e18858c85e1ac" name="a5021d4b369ffd066640e18858c85e1ac"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5021d4b369ffd066640e18858c85e1ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzcopy</b> (Uplo uplo, int64_t m, int64_t n, double const *const *Aarray, int64_t lda, double **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a5021d4b369ffd066640e18858c85e1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414c49117172cf41287af04c860088cb"><td class="memItemLeft" align="right" valign="top"><a id="a414c49117172cf41287af04c860088cb" name="a414c49117172cf41287af04c860088cb"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a414c49117172cf41287af04c860088cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzcopy</b> (Uplo uplo, int64_t m, int64_t n, double const *const *Aarray, int64_t lda, float **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a414c49117172cf41287af04c860088cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94555468fa21182dd388f00adcdd8511"><td class="memItemLeft" align="right" valign="top"><a id="a94555468fa21182dd388f00adcdd8511" name="a94555468fa21182dd388f00adcdd8511"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a94555468fa21182dd388f00adcdd8511"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzcopy</b> (Uplo uplo, int64_t m, int64_t n, float const *const *Aarray, int64_t lda, float **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a94555468fa21182dd388f00adcdd8511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916ffde38630c985d533bb9ff8c68c0e"><td class="memItemLeft" align="right" valign="top"><a id="a916ffde38630c985d533bb9ff8c68c0e" name="a916ffde38630c985d533bb9ff8c68c0e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a916ffde38630c985d533bb9ff8c68c0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzcopy</b> (Uplo uplo, int64_t m, int64_t n, float const *const *Aarray, int64_t lda, double **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a916ffde38630c985d533bb9ff8c68c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c3b0117080b36ac1c73275dc86a055"><td class="memItemLeft" align="right" valign="top"><a id="a75c3b0117080b36ac1c73275dc86a055" name="a75c3b0117080b36ac1c73275dc86a055"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a75c3b0117080b36ac1c73275dc86a055"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzscale</b> (Uplo uplo, int64_t m, int64_t n, float numer, float denom, std::complex&lt; float &gt; **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a75c3b0117080b36ac1c73275dc86a055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba0957137f6b39b9c29cd680fba88ae"><td class="memItemLeft" align="right" valign="top"><a id="a9ba0957137f6b39b9c29cd680fba88ae" name="a9ba0957137f6b39b9c29cd680fba88ae"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9ba0957137f6b39b9c29cd680fba88ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzscale</b> (Uplo uplo, int64_t m, int64_t n, double numer, double denom, std::complex&lt; double &gt; **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a9ba0957137f6b39b9c29cd680fba88ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed8467fcfb021c30d68e2a9c5279fca"><td class="memItemLeft" align="right" valign="top"><a id="aaed8467fcfb021c30d68e2a9c5279fca" name="aaed8467fcfb021c30d68e2a9c5279fca"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aaed8467fcfb021c30d68e2a9c5279fca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzscale</b> (Uplo uplo, int64_t m, int64_t n, double numer, double denom, double **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aaed8467fcfb021c30d68e2a9c5279fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9111ef959c42c5cea26687d71211d9e3"><td class="memItemLeft" align="right" valign="top"><a id="a9111ef959c42c5cea26687d71211d9e3" name="a9111ef959c42c5cea26687d71211d9e3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9111ef959c42c5cea26687d71211d9e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzscale</b> (Uplo uplo, int64_t m, int64_t n, float numer, float denom, float **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a9111ef959c42c5cea26687d71211d9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d46241dc72b1c7f3dcbd8d00c29c019"><td class="memItemLeft" align="right" valign="top"><a id="a3d46241dc72b1c7f3dcbd8d00c29c019" name="a3d46241dc72b1c7f3dcbd8d00c29c019"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3d46241dc72b1c7f3dcbd8d00c29c019"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzset</b> (Uplo uplo, int64_t m, int64_t n, std::complex&lt; float &gt; const &amp;offdiag_value, std::complex&lt; float &gt; const &amp;diag_value, std::complex&lt; float &gt; *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a3d46241dc72b1c7f3dcbd8d00c29c019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6698fba46778aa316f127f8840d62a4b"><td class="memItemLeft" align="right" valign="top"><a id="a6698fba46778aa316f127f8840d62a4b" name="a6698fba46778aa316f127f8840d62a4b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6698fba46778aa316f127f8840d62a4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzset</b> (Uplo uplo, int64_t m, int64_t n, std::complex&lt; double &gt; const &amp;offdiag_value, std::complex&lt; double &gt; const &amp;diag_value, std::complex&lt; double &gt; *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a6698fba46778aa316f127f8840d62a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2671486e4dd777df1d1ba58880ea4177"><td class="memItemLeft" align="right" valign="top"><a id="a2671486e4dd777df1d1ba58880ea4177" name="a2671486e4dd777df1d1ba58880ea4177"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2671486e4dd777df1d1ba58880ea4177"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzset</b> (Uplo uplo, int64_t m, int64_t n, double const &amp;offdiag_value, double const &amp;diag_value, double *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a2671486e4dd777df1d1ba58880ea4177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6c0f9651b4bff6ed330354f721d4a5"><td class="memItemLeft" align="right" valign="top"><a id="a8e6c0f9651b4bff6ed330354f721d4a5" name="a8e6c0f9651b4bff6ed330354f721d4a5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8e6c0f9651b4bff6ed330354f721d4a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tzset</b> (Uplo uplo, int64_t m, int64_t n, float const &amp;offdiag_value, float const &amp;diag_value, float *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a8e6c0f9651b4bff6ed330354f721d4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cb91c8693e02c83369fca4302cf78f"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t , typename scalar_t2 &gt; </td></tr>
<tr class="memitem:a93cb91c8693e02c83369fca4302cf78f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a93cb91c8693e02c83369fca4302cf78f">gescale_row_col_batch_kernel</a> (int64_t m, int64_t n, scalar_t2 const *const *Rarray, scalar_t2 const *const *Carray, scalar_t **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a93cb91c8693e02c83369fca4302cf78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing row and column scaling.  <br /></td></tr>
<tr class="separator:a93cb91c8693e02c83369fca4302cf78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee966028ea4bf8a239a9ed8b5ec1a66"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t , typename scalar_t2 &gt; </td></tr>
<tr class="memitem:a1ee966028ea4bf8a239a9ed8b5ec1a66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a1ee966028ea4bf8a239a9ed8b5ec1a66">gescale_col_batch_kernel</a> (int64_t m, int64_t n, scalar_t2 const *const *Carray, scalar_t **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a1ee966028ea4bf8a239a9ed8b5ec1a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing column scaling.  <br /></td></tr>
<tr class="separator:a1ee966028ea4bf8a239a9ed8b5ec1a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59238022da23e6d7d2bbe294c5d13e19"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t , typename scalar_t2 &gt; </td></tr>
<tr class="memitem:a59238022da23e6d7d2bbe294c5d13e19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a59238022da23e6d7d2bbe294c5d13e19">gescale_row_batch_kernel</a> (int64_t m, int64_t n, scalar_t2 const *const *Rarray, scalar_t **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a59238022da23e6d7d2bbe294c5d13e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementing row scaling.  <br /></td></tr>
<tr class="separator:a59238022da23e6d7d2bbe294c5d13e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94ad67742a5ebd5b74dfd941b058ae3"><td class="memItemLeft" align="right" valign="top"><a id="aa94ad67742a5ebd5b74dfd941b058ae3" name="aa94ad67742a5ebd5b74dfd941b058ae3"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>henorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, int64_t n, std::complex&lt; float &gt; const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aa94ad67742a5ebd5b74dfd941b058ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03089c9e3a248d11ba1185c49eb98f21"><td class="memItemLeft" align="right" valign="top"><a id="a03089c9e3a248d11ba1185c49eb98f21" name="a03089c9e3a248d11ba1185c49eb98f21"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>henorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, int64_t n, std::complex&lt; double &gt; const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a03089c9e3a248d11ba1185c49eb98f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5d43c9922f4673bb5a2aeddd999961"><td class="memItemLeft" align="right" valign="top"><a id="afa5d43c9922f4673bb5a2aeddd999961" name="afa5d43c9922f4673bb5a2aeddd999961"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>synorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, int64_t n, std::complex&lt; float &gt; const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:afa5d43c9922f4673bb5a2aeddd999961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf071c2f80eac85b280c6a816fa7022f"><td class="memItemLeft" align="right" valign="top"><a id="abf071c2f80eac85b280c6a816fa7022f" name="abf071c2f80eac85b280c6a816fa7022f"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>synorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, int64_t n, std::complex&lt; double &gt; const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:abf071c2f80eac85b280c6a816fa7022f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0faa116a8609119c395c84c85d1f95"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a0a0faa116a8609119c395c84c85d1f95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a0a0faa116a8609119c395c84c85d1f95">transpose_sqr_batch_func</a> (bool is_conj, int n, scalar_t **Aarray, int64_t lda, int batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a0a0faa116a8609119c395c84c85d1f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device routine handles batches of square matrices.  <br /></td></tr>
<tr class="separator:a0a0faa116a8609119c395c84c85d1f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47790071d4cff993ca95f01e8628da3f"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a47790071d4cff993ca95f01e8628da3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a47790071d4cff993ca95f01e8628da3f">transpose_sqr_func</a> (bool is_conj, int n, scalar_t *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a47790071d4cff993ca95f01e8628da3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device routine handles single square matrix.  <br /></td></tr>
<tr class="separator:a47790071d4cff993ca95f01e8628da3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bfe3526c6fa18ab2bfc267024a4202"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t , int NX&gt; </td></tr>
<tr class="memitem:ab8bfe3526c6fa18ab2bfc267024a4202"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#ab8bfe3526c6fa18ab2bfc267024a4202">transpose_rect_batch_func</a> (bool is_conj, int m, int n, scalar_t **dAarray, int64_t lda, scalar_t **dATarray, int64_t ldat, int batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:ab8bfe3526c6fa18ab2bfc267024a4202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device routine handles batches of rectangular matrices.  <br /></td></tr>
<tr class="separator:ab8bfe3526c6fa18ab2bfc267024a4202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356e9791bd80e453b213f1e99772a16a"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t , int NX&gt; </td></tr>
<tr class="memitem:a356e9791bd80e453b213f1e99772a16a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a356e9791bd80e453b213f1e99772a16a">transpose_rect_func</a> (bool is_conj, int m, int n, scalar_t *dA, int64_t lda, scalar_t *dAT, int64_t ldat, blas::Queue &amp;queue)</td></tr>
<tr class="memdesc:a356e9791bd80e453b213f1e99772a16a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device routine handles single rectangular matrox.  <br /></td></tr>
<tr class="separator:a356e9791bd80e453b213f1e99772a16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0366c987fcadfe93f144eb26a430dd24"><td class="memItemLeft" align="right" valign="top"><a id="a0366c987fcadfe93f144eb26a430dd24" name="a0366c987fcadfe93f144eb26a430dd24"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0366c987fcadfe93f144eb26a430dd24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t m, int64_t n, float *dA, int64_t lda, float *dAT, int64_t ldat, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a0366c987fcadfe93f144eb26a430dd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebfdc988e490c28f12d120b286ab97e"><td class="memItemLeft" align="right" valign="top"><a id="aeebfdc988e490c28f12d120b286ab97e" name="aeebfdc988e490c28f12d120b286ab97e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aeebfdc988e490c28f12d120b286ab97e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t m, int64_t n, double *dA, int64_t lda, double *dAT, int64_t ldat, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aeebfdc988e490c28f12d120b286ab97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7786cadf644f6bd266934283b95a9bf0"><td class="memItemLeft" align="right" valign="top"><a id="a7786cadf644f6bd266934283b95a9bf0" name="a7786cadf644f6bd266934283b95a9bf0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7786cadf644f6bd266934283b95a9bf0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t m, int64_t n, std::complex&lt; float &gt; *dA, int64_t lda, std::complex&lt; float &gt; *dAT, int64_t ldat, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a7786cadf644f6bd266934283b95a9bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacecb60b66ed471edf99f7c892652e5f"><td class="memItemLeft" align="right" valign="top"><a id="aacecb60b66ed471edf99f7c892652e5f" name="aacecb60b66ed471edf99f7c892652e5f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aacecb60b66ed471edf99f7c892652e5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (bool is_conj, int64_t m, int64_t n, std::complex&lt; double &gt; *dA, int64_t lda, std::complex&lt; double &gt; *dAT, int64_t ldat, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aacecb60b66ed471edf99f7c892652e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd1779751147bc7ef65aa553914c14c"><td class="memItemLeft" align="right" valign="top"><a id="aabd1779751147bc7ef65aa553914c14c" name="aabd1779751147bc7ef65aa553914c14c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aabd1779751147bc7ef65aa553914c14c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t m, int64_t n, float **dA_array, int64_t lda, float **dAT_array, int64_t ldat, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:aabd1779751147bc7ef65aa553914c14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac467d41a137c602e4415be4fc2082779"><td class="memItemLeft" align="right" valign="top"><a id="ac467d41a137c602e4415be4fc2082779" name="ac467d41a137c602e4415be4fc2082779"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac467d41a137c602e4415be4fc2082779"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t m, int64_t n, double **dA_array, int64_t lda, double **dAT_array, int64_t ldat, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ac467d41a137c602e4415be4fc2082779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe202228de4ab677767f19c382742f9d"><td class="memItemLeft" align="right" valign="top"><a id="abe202228de4ab677767f19c382742f9d" name="abe202228de4ab677767f19c382742f9d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abe202228de4ab677767f19c382742f9d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t m, int64_t n, std::complex&lt; float &gt; **dA_array, int64_t lda, std::complex&lt; float &gt; **dAT_array, int64_t ldat, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:abe202228de4ab677767f19c382742f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47abfd9be5d23115b6d0309699c962d5"><td class="memItemLeft" align="right" valign="top"><a id="a47abfd9be5d23115b6d0309699c962d5" name="a47abfd9be5d23115b6d0309699c962d5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a47abfd9be5d23115b6d0309699c962d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose_batch</b> (bool is_conj, int64_t m, int64_t n, std::complex&lt; double &gt; **dA_array, int64_t lda, std::complex&lt; double &gt; **dAT_array, int64_t ldat, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a47abfd9be5d23115b6d0309699c962d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54fd970cd0bc8d0b4e9cc1b0a674e71"><td class="memItemLeft" align="right" valign="top"><a id="ab54fd970cd0bc8d0b4e9cc1b0a674e71" name="ab54fd970cd0bc8d0b4e9cc1b0a674e71"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>trnorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, lapack::Diag diag, int64_t m, int64_t n, std::complex&lt; float &gt; const *const *Aarray, int64_t lda, float *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:ab54fd970cd0bc8d0b4e9cc1b0a674e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a526b81bce4a09740f21672f5f4381b"><td class="memItemLeft" align="right" valign="top"><a id="a1a526b81bce4a09740f21672f5f4381b" name="a1a526b81bce4a09740f21672f5f4381b"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>trnorm</b> (lapack::Norm <a class="el" href="group__norm.html#ga93fa1f226ba869ce747567c218da54c4">norm</a>, lapack::Uplo uplo, lapack::Diag diag, int64_t m, int64_t n, std::complex&lt; double &gt; const *const *Aarray, int64_t lda, double *values, int64_t ldv, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a1a526b81bce4a09740f21672f5f4381b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d65d28792e152a2ca42241cf18b2052"><td class="memItemLeft" align="right" valign="top"><a id="a9d65d28792e152a2ca42241cf18b2052" name="a9d65d28792e152a2ca42241cf18b2052"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzadd</b> (lapack::Uplo uplo, int64_t m, int64_t n, std::complex&lt; float &gt; const &amp;alpha, std::complex&lt; float &gt; **Aarray, int64_t lda, std::complex&lt; float &gt; const &amp;beta, std::complex&lt; float &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a9d65d28792e152a2ca42241cf18b2052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb10658c4323dc7efccd6f618254945d"><td class="memItemLeft" align="right" valign="top"><a id="afb10658c4323dc7efccd6f618254945d" name="afb10658c4323dc7efccd6f618254945d"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzadd</b> (lapack::Uplo uplo, int64_t m, int64_t n, std::complex&lt; double &gt; const &amp;alpha, std::complex&lt; double &gt; **Aarray, int64_t lda, std::complex&lt; double &gt; const &amp;beta, std::complex&lt; double &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:afb10658c4323dc7efccd6f618254945d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163d8ae238e442b5c33f8eef5f1bf70c"><td class="memItemLeft" align="right" valign="top"><a id="a163d8ae238e442b5c33f8eef5f1bf70c" name="a163d8ae238e442b5c33f8eef5f1bf70c"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzcopy</b> (lapack::Uplo uplo, int64_t m, int64_t n, std::complex&lt; float &gt; const *const *Aarray, int64_t lda, std::complex&lt; float &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a163d8ae238e442b5c33f8eef5f1bf70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9801d460197b258abdfd1240e3ef82"><td class="memItemLeft" align="right" valign="top"><a id="a6e9801d460197b258abdfd1240e3ef82" name="a6e9801d460197b258abdfd1240e3ef82"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzcopy</b> (lapack::Uplo uplo, int64_t m, int64_t n, std::complex&lt; float &gt; const *const *Aarray, int64_t lda, std::complex&lt; double &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a6e9801d460197b258abdfd1240e3ef82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6ebbcf0a1e5665650242594a80edeb"><td class="memItemLeft" align="right" valign="top"><a id="a3e6ebbcf0a1e5665650242594a80edeb" name="a3e6ebbcf0a1e5665650242594a80edeb"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzcopy</b> (lapack::Uplo uplo, int64_t m, int64_t n, std::complex&lt; double &gt; const *const *Aarray, int64_t lda, std::complex&lt; double &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a3e6ebbcf0a1e5665650242594a80edeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1a4b376d8459403425d7c81268af67"><td class="memItemLeft" align="right" valign="top"><a id="acc1a4b376d8459403425d7c81268af67" name="acc1a4b376d8459403425d7c81268af67"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzcopy</b> (lapack::Uplo uplo, int64_t m, int64_t n, std::complex&lt; double &gt; const *const *Aarray, int64_t lda, std::complex&lt; float &gt; **Barray, int64_t ldb, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:acc1a4b376d8459403425d7c81268af67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e57c8403b922dc1f15e7ae19e204ff"><td class="memItemLeft" align="right" valign="top"><a id="a10e57c8403b922dc1f15e7ae19e204ff" name="a10e57c8403b922dc1f15e7ae19e204ff"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzscale</b> (lapack::Uplo uplo, int64_t m, int64_t n, float numer, float denom, std::complex&lt; float &gt; **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a10e57c8403b922dc1f15e7ae19e204ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6432479e7e29be9af2e54d1506583954"><td class="memItemLeft" align="right" valign="top"><a id="a6432479e7e29be9af2e54d1506583954" name="a6432479e7e29be9af2e54d1506583954"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzscale</b> (lapack::Uplo uplo, int64_t m, int64_t n, double numer, double denom, std::complex&lt; double &gt; **Aarray, int64_t lda, int64_t batch_count, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a6432479e7e29be9af2e54d1506583954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8d9e63113174b238e32262adbf8638"><td class="memItemLeft" align="right" valign="top"><a id="a5c8d9e63113174b238e32262adbf8638" name="a5c8d9e63113174b238e32262adbf8638"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzset</b> (lapack::Uplo uplo, int64_t m, int64_t n, std::complex&lt; float &gt; const &amp;offdiag_value, std::complex&lt; float &gt; const &amp;diag_value, std::complex&lt; float &gt; *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a5c8d9e63113174b238e32262adbf8638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276d327158fb57cf844cc724c210dc8c"><td class="memItemLeft" align="right" valign="top"><a id="a276d327158fb57cf844cc724c210dc8c" name="a276d327158fb57cf844cc724c210dc8c"></a>
template void&#160;</td><td class="memItemRight" valign="bottom"><b>tzset</b> (lapack::Uplo uplo, int64_t m, int64_t n, std::complex&lt; double &gt; const &amp;offdiag_value, std::complex&lt; double &gt; const &amp;diag_value, std::complex&lt; double &gt; *A, int64_t lda, blas::Queue &amp;queue)</td></tr>
<tr class="separator:a276d327158fb57cf844cc724c210dc8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa469b302c41bc9348f75eb278d8688f0"><td class="memTemplParams" colspan="2"><a id="aa469b302c41bc9348f75eb278d8688f0" name="aa469b302c41bc9348f75eb278d8688f0"></a>
template&lt;typename real_t &gt; </td></tr>
<tr class="memitem:aa469b302c41bc9348f75eb278d8688f0"><td class="memTemplItemLeft" align="right" valign="top">real_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max_nan</b> (real_t x, real_t y)</td></tr>
<tr class="memdesc:aa469b302c41bc9348f75eb278d8688f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">max that propogates nan consistently: max_nan( 1,   nan ) = nan max_nan( nan, 1   ) = nan <br /></td></tr>
<tr class="separator:aa469b302c41bc9348f75eb278d8688f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6339759e276cceb4c38fd0112845e9"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:a6e6339759e276cceb4c38fd0112845e9"><td class="memTemplItemLeft" align="right" valign="top">scalar_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a6e6339759e276cceb4c38fd0112845e9">sqr</a> (scalar_t x)</td></tr>
<tr class="memdesc:a6e6339759e276cceb4c38fd0112845e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square of number.  <br /></td></tr>
<tr class="separator:a6e6339759e276cceb4c38fd0112845e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d909226a620ca2f155756aec0584295"><td class="memTemplParams" colspan="2">template&lt;typename real_t &gt; </td></tr>
<tr class="memitem:a9d909226a620ca2f155756aec0584295"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a9d909226a620ca2f155756aec0584295">combine_sumsq</a> (real_t &amp;scale1, real_t &amp;sumsq1, real_t scale2, real_t sumsq2)</td></tr>
<tr class="memdesc:a9d909226a620ca2f155756aec0584295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two scaled, sum-of-squares representations.  <br /></td></tr>
<tr class="separator:a9d909226a620ca2f155756aec0584295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e45ec23e74bbbcc64db44dbea097404"><td class="memTemplParams" colspan="2">template&lt;typename real_t &gt; </td></tr>
<tr class="memitem:a1e45ec23e74bbbcc64db44dbea097404"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a1e45ec23e74bbbcc64db44dbea097404">add_sumsq</a> (real_t &amp;<a class="el" href="group__set.html#ga0930923d5547ec8c39388e5f1dee53e0">scale</a>, real_t &amp;sumsq, real_t absx)</td></tr>
<tr class="memdesc:a1e45ec23e74bbbcc64db44dbea097404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new value to scaled, sum-of-squares representation.  <br /></td></tr>
<tr class="separator:a1e45ec23e74bbbcc64db44dbea097404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad904c10a0088fb19054037c8cab3444a"><td class="memItemLeft" align="right" valign="top"><a id="ad904c10a0088fb19054037c8cab3444a" name="ad904c10a0088fb19054037c8cab3444a"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>abs_val</b> (float x)</td></tr>
<tr class="memdesc:ad904c10a0088fb19054037c8cab3444a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded versions of absolute value on device. <br /></td></tr>
<tr class="separator:ad904c10a0088fb19054037c8cab3444a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776e1457f9f3d13b8b0d80823cb47935"><td class="memItemLeft" align="right" valign="top"><a id="a776e1457f9f3d13b8b0d80823cb47935" name="a776e1457f9f3d13b8b0d80823cb47935"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>abs_val</b> (double x)</td></tr>
<tr class="separator:a776e1457f9f3d13b8b0d80823cb47935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24308bea64e9c2cd18f9e01f383ba8fd"><td class="memItemLeft" align="right" valign="top"><a id="a24308bea64e9c2cd18f9e01f383ba8fd" name="a24308bea64e9c2cd18f9e01f383ba8fd"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>abs_val</b> (std::complex&lt; float &gt; x)</td></tr>
<tr class="separator:a24308bea64e9c2cd18f9e01f383ba8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b3cd91698a193a1f6276ce9d8bbf4b"><td class="memItemLeft" align="right" valign="top"><a id="ae2b3cd91698a193a1f6276ce9d8bbf4b" name="ae2b3cd91698a193a1f6276ce9d8bbf4b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>abs_val</b> (std::complex&lt; double &gt; x)</td></tr>
<tr class="separator:ae2b3cd91698a193a1f6276ce9d8bbf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a055f04b11eeed2104bbb8ad7b18c579e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceslate_1_1device.html#a055f04b11eeed2104bbb8ad7b18c579e">ib</a> = 32</td></tr>
<tr class="memdesc:a055f04b11eeed2104bbb8ad7b18c579e"><td class="mdescLeft">&#160;</td><td class="mdescRight">block size for genorm_one_kernel  <br /></td></tr>
<tr class="separator:a055f04b11eeed2104bbb8ad7b18c579e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c30d9ab64b5137c34eb44bdbf28a03"><td class="memItemLeft" align="right" valign="top"><a id="a27c30d9ab64b5137c34eb44bdbf28a03" name="a27c30d9ab64b5137c34eb44bdbf28a03"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>ib1</b> = 33</td></tr>
<tr class="memdesc:a27c30d9ab64b5137c34eb44bdbf28a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">ib + 1 for stride to avoid GPU bank conflicts <br /></td></tr>
<tr class="separator:a27c30d9ab64b5137c34eb44bdbf28a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac058a0f63638fb113b785456996bb14e"><td class="memItemLeft" align="right" valign="top"><a id="ac058a0f63638fb113b785456996bb14e" name="ac058a0f63638fb113b785456996bb14e"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>NB</b> = 32</td></tr>
<tr class="memdesc:ac058a0f63638fb113b785456996bb14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">block size for transpose_func <br /></td></tr>
<tr class="separator:ac058a0f63638fb113b785456996bb14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6533ad4bb74e1da4237133923efe5a5c"><td class="memItemLeft" align="right" valign="top"><a id="a6533ad4bb74e1da4237133923efe5a5c" name="a6533ad4bb74e1da4237133923efe5a5c"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>NY</b> = 8</td></tr>
<tr class="memdesc:a6533ad4bb74e1da4237133923efe5a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">y dim of thread block size for transpose_func <br /></td></tr>
<tr class="separator:a6533ad4bb74e1da4237133923efe5a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>GPU device implementations of kernels. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a1fd9528305fe1f9ab33f80ca12c67961" name="a1fd9528305fe1f9ab33f80ca12c67961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd9528305fe1f9ab33f80ca12c67961">&#9670;&#160;</a></span>add_sumsq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ void slate::device::add_sumsq </td>
          <td>(</td>
          <td class="paramtype">real_t &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t &amp;&#160;</td>
          <td class="paramname"><em>sumsq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>absx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds new value to scaled, sum-of-squares representation. </p>
<p>On exit, scale and sumsq are updated such that: scale^2 sumsq := scale^2 sumsq + (absx)^2 </p>

</div>
</div>
<a id="a1e45ec23e74bbbcc64db44dbea097404" name="a1e45ec23e74bbbcc64db44dbea097404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e45ec23e74bbbcc64db44dbea097404">&#9670;&#160;</a></span>add_sumsq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::add_sumsq </td>
          <td>(</td>
          <td class="paramtype">real_t &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t &amp;&#160;</td>
          <td class="paramname"><em>sumsq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>absx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds new value to scaled, sum-of-squares representation. </p>
<p>On exit, scale and sumsq are updated such that: scale^2 sumsq := scale^2 sumsq + (absx)^2 </p>

</div>
</div>
<a id="af9d1f76d7d2df5931e57604dc5361982" name="af9d1f76d7d2df5931e57604dc5361982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d1f76d7d2df5931e57604dc5361982">&#9670;&#160;</a></span>ceildiv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ constexpr T slate::device::ceildiv </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>ceil( x / y ), for integer type T. </dd></dl>

</div>
</div>
<a id="abdba62bc3e9805fd90143a4fcb513fcd" name="abdba62bc3e9805fd90143a4fcb513fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdba62bc3e9805fd90143a4fcb513fcd">&#9670;&#160;</a></span>combine_sumsq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ void slate::device::combine_sumsq </td>
          <td>(</td>
          <td class="paramtype">real_t &amp;&#160;</td>
          <td class="paramname"><em>scale1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t &amp;&#160;</td>
          <td class="paramname"><em>sumsq1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>scale2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>sumsq2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds two scaled, sum-of-squares representations. </p>
<p>On exit, scale1 and sumsq1 are updated such that: scale1^2 sumsq1 := scale1^2 sumsq1 + scale2^2 sumsq2. </p>

</div>
</div>
<a id="a9d909226a620ca2f155756aec0584295" name="a9d909226a620ca2f155756aec0584295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d909226a620ca2f155756aec0584295">&#9670;&#160;</a></span>combine_sumsq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::combine_sumsq </td>
          <td>(</td>
          <td class="paramtype">real_t &amp;&#160;</td>
          <td class="paramname"><em>scale1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t &amp;&#160;</td>
          <td class="paramname"><em>sumsq1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>scale2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>sumsq2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds two scaled, sum-of-squares representations. </p>
<p>On exit, scale1 and sumsq1 are updated such that: scale1^2 sumsq1 := scale1^2 sumsq1 + scale2^2 sumsq2. </p>

</div>
</div>
<a id="a5493c7f0655a40c1124875e72591d0df" name="a5493c7f0655a40c1124875e72591d0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5493c7f0655a40c1124875e72591d0df">&#9670;&#160;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ double slate::device::conj </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>conjugate of complex number x; x for real number. </dd></dl>

</div>
</div>
<a id="a7baf50ff065a8349060ef66f5fd284a5" name="a7baf50ff065a8349060ef66f5fd284a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7baf50ff065a8349060ef66f5fd284a5">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TA , typename TB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ void slate::device::copy </td>
          <td>(</td>
          <td class="paramtype">TA&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TB &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded copy and precision conversion. </p>
<p>Sets b = a, converting from type TA to type TB. </p>

</div>
</div>
<a id="af81f2ef856c00f2bdf5eae81752bfb1b" name="af81f2ef856c00f2bdf5eae81752bfb1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81f2ef856c00f2bdf5eae81752bfb1b">&#9670;&#160;</a></span>geadd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::geadd </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine for element-wise tile addition. </p>
<p>Sets  </p><p class="formulaDsp">
\[
    B = \alpha A + \beta B.
\]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar alpha.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The scalar beta.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>Leading dimension of each tile in B. ldb &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets  </p><p class="formulaDsp">
\[
    B = \alpha A + \beta B.
\]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar alpha.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The scalar beta.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>Leading dimension of each tile in B. ldb &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27d56cfab6bd7336f56626cfc27c99ab" name="a27d56cfab6bd7336f56626cfc27c99ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d56cfab6bd7336f56626cfc27c99ab">&#9670;&#160;</a></span>geadd_batch_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::geadd_batch_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Barray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing element-wise tile set. </p>

</div>
</div>
<a id="a09e6e27f4025a9fa3a640b8dffa67891" name="a09e6e27f4025a9fa3a640b8dffa67891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e6e27f4025a9fa3a640b8dffa67891">&#9670;&#160;</a></span>geadd_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void slate::device::geadd_func </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing element-wise tile addition. </p>
<p>Each thread deals with one row. Launched by <a class="el" href="namespaceslate_1_1device.html#adb70d814f7a4f6e04be80eb10775dec1" title="Kernel implementing element-wise tile.">geadd_kernel()</a> and <a class="el" href="namespaceslate_1_1device.html#a27d56cfab6bd7336f56626cfc27c99ab" title="Kernel implementing element-wise tile set.">geadd_batch_kernel()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in Aarray. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>is an m-by-n matrix stored in an ldb-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>Leading dimension of each tile in Barray. ldb &gt;= m.</td></tr>
  </table>
  </dd>
</dl>
<p>Routine for element-wise tile addition.  </p>
<p>Sets  </p><p class="formulaDsp">
\[
    B = \alpha A + \beta B.
\]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar alpha.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The scalar beta.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>Leading dimension of each tile in B. ldb &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets  </p><p class="formulaDsp">
\[
    B = \alpha A + \beta B.
\]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar alpha.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The scalar beta.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>Leading dimension of each tile in B. ldb &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.   </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb70d814f7a4f6e04be80eb10775dec1" name="adb70d814f7a4f6e04be80eb10775dec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb70d814f7a4f6e04be80eb10775dec1">&#9670;&#160;</a></span>geadd_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::geadd_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing element-wise tile. </p>
<p>Routine for element-wise tile addition.  </p>
<p>Sets  </p><p class="formulaDsp">
\[
    B = \alpha A + \beta B.
\]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar alpha.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The scalar beta.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>Leading dimension of each tile in B. ldb &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets  </p><p class="formulaDsp">
\[
    B = \alpha A + \beta B.
\]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar alpha.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The scalar beta.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>Leading dimension of each tile in B. ldb &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.   </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f7c3d16cad839668de1789efc626351" name="a8f7c3d16cad839668de1789efc626351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7c3d16cad839668de1789efc626351">&#9670;&#160;</a></span>gecopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename src_scalar_t , typename dst_scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::gecopy </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">src_scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dst_scalar_t **&#160;</td>
          <td class="paramname"><em>Barray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Batched routine for element-wise copy and precision conversion, copying A to B. </p>
<p>Sets  </p><p class="formulaDsp">
\[
    Barray[k] = Aarray[k].
\]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Barray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Barray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>Leading dimension of each tile in B. ldb &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray and Barray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets  </p><p class="formulaDsp">
\[
    Barray[k] = Aarray[k].
\]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Barray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Barray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>Leading dimension of each tile in B. ldb &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray and Barray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afeb8ca49b7b327db84163cd94ecc5a01" name="afeb8ca49b7b327db84163cd94ecc5a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb8ca49b7b327db84163cd94ecc5a01">&#9670;&#160;</a></span>gecopy_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename src_scalar_t , typename dst_scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::gecopy_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">src_scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dst_scalar_t **&#160;</td>
          <td class="paramname"><em>Barray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing copy and precision conversions, copying A to B. </p>
<p>Each thread block deals with one tile. Each thread deals with one row. Launched by <a class="el" href="namespaceslate_1_1device.html#a8f7c3d16cad839668de1789efc626351" title="Batched routine for element-wise copy and precision conversion, copying A to B.">gecopy()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in Aarray. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Barray</td><td>Array of tiles of dimension gridDim.x, where each Barray[k] is an m-by-n matrix stored in an ldb-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>Leading dimension of each tile in Barray. ldb &gt;= m. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60b351ce9c087021d4607dbd898fc878" name="a60b351ce9c087021d4607dbd898fc878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b351ce9c087021d4607dbd898fc878">&#9670;&#160;</a></span>genorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::genorm </td>
          <td>(</td>
          <td class="paramtype">lapack::Norm&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#ga8adf8aeaee2927385592d44ff23b95bb">NormScope</a>&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Batched routine that computes a partial norm for each tile. </p>
<p>Batched routine that returns the largest absolute value of elements for each tile in Aarray.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">norm</td><td>Norm to compute. See values for description.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scope</td><td>Scope of the norm.<ul>
<li><a class="el" href="group__enum.html#gga8adf8aeaee2927385592d44ff23b95bbaf53df0293e169f562bc1d9a20e1d2589" title="Compute matrix norm.">NormScope::Matrix</a> computes partial norm of each tile.</li>
<li><a class="el" href="group__enum.html#gga8adf8aeaee2927385592d44ff23b95bba168b82d33f8073018c50a4f658a02559" title="Compute column norms.">NormScope::Columns</a> computes norm of each column.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Array in GPU memory, dimension batch_count * ldv.<ul>
<li>Norm::Max: ldv = 1. On exit, values[k] = max_{i, j} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count.</li>
<li>Norm::One: ldv &gt;= n. On exit, values[k*ldv + j] = sum_{i} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count, 0 &lt;= j &lt; n.</li>
<li>Norm::Inf: ldv &gt;= m. On exit, values[k*ldv + i] = sum_{j} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count, 0 &lt;= i &lt; m.</li>
<li>Norm::Max: ldv = 2. On exit, values[k*2 + 0] = scale_k values[k*2 + 1] = sumsq_k where scale_k^2 sumsq_k = sum_{i,j} abs( A^(k)_(i, j) )^2 for 0 &lt;= k &lt; batch_count.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of values array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets tiles_maxima[k] = max_{i, j}( abs( A^(k)_(i, j) )), for each tile A^(k), where A^(k) = Aarray[k], k = 0, ..., blockDim.x-1, i = 0, ..., m-1, j = 0, ..., n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Array in GPU memory, dimension batch_count * ldv.<ul>
<li>Norm::Max: ldv = 1. On exit, values[k] = max_{i, j} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count.</li>
<li>Norm::One: ldv &gt;= n. On exit, values[k*ldv + j] = sum_{i} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count, 0 &lt;= j &lt; n.</li>
<li>Norm::Inf: ldv &gt;= m. On exit, values[k*ldv + i] = sum_{j} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count, 0 &lt;= i &lt; m.</li>
<li>Norm::Fro: ldv = 2. On exit, values[k*2 + 0] = scale_k values[k*2 + 1] = sumsq_k where scale_k^2 sumsq_k = sum_{i,j} abs( A^(k)_(i, j) )^2 for 0 &lt;= k &lt; batch_count.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of tiles_sums (values) array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>device to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b193c442e8fea90d0a7c37b86783158" name="a6b193c442e8fea90d0a7c37b86783158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b193c442e8fea90d0a7c37b86783158">&#9670;&#160;</a></span>genorm_fro_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::genorm_fro_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>tiles_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of squares, in scaled representation, for each tile in Aarray. </p>
<p>Each thread block deals with one tile. Each thread deals with one row, followed by a reduction. Kernel assumes non-trivial tiles (m, n &gt;= 1). Launched by <a class="el" href="namespaceslate_1_1device.html#a60b351ce9c087021d4607dbd898fc878" title="Batched routine that computes a partial norm for each tile.">genorm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1. Also the number of threads per block, hence,</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension blockDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tiles_values</td><td>Array of dimension 2 * blockDim.x. On exit, tiles_values[2*k + 0] = scale tiles_values[2*k + 1] = sumsq such that scale^2 * sumsq = sum_{i,j} abs( A^(k)_{i,j} )^2 for tile A^(k). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73a0e917a785e84a0de6a5e7aa092f25" name="a73a0e917a785e84a0de6a5e7aa092f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a0e917a785e84a0de6a5e7aa092f25">&#9670;&#160;</a></span>genorm_inf_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::genorm_inf_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>tiles_sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of absolute values of each row of elements, for each tile in Aarray. </p>
<p>Each thread block deals with one tile. Each thread deals with one row. Kernel assumes non-trivial tiles (m, n &gt;= 1). Launched by <a class="el" href="namespaceslate_1_1device.html#a60b351ce9c087021d4607dbd898fc878" title="Batched routine that computes a partial norm for each tile.">genorm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1. Also the number of threads per block, hence,</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tiles_sums</td><td>Array of dimension gridDim.x * ldv. On exit, tiles_sums[k*ldv + i] = sum_{j} abs( A^(k)_(i, j) ) for row i of tile A^(k).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of tiles_sums (values) array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55a07d7aaa8ae5c389b7da13ec3da198" name="a55a07d7aaa8ae5c389b7da13ec3da198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a07d7aaa8ae5c389b7da13ec3da198">&#9670;&#160;</a></span>genorm_max_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::genorm_max_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>tiles_maxima</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the largest absolute value of elements, for each tile in Aarray. </p>
<p>Each thread block deals with one tile. Each thread deals with one row, followed by a reduction. Uses dynamic shared memory array of length sizeof(real_t) * m. Kernel assumes non-trivial tiles (m, n &gt;= 1). Launched by <a class="el" href="namespaceslate_1_1device.html#a60b351ce9c087021d4607dbd898fc878" title="Batched routine that computes a partial norm for each tile.">genorm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1. Also the number of threads per block (blockDim.x), hence,</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tiles_maxima</td><td>Array of dimension gridDim.x. On exit, tiles_maxima[k] = max_{i, j} abs( A^(k)_(i, j) ) for tile A^(k). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63d318a816d0607b41e4c0f6a5ee518d" name="a63d318a816d0607b41e4c0f6a5ee518d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d318a816d0607b41e4c0f6a5ee518d">&#9670;&#160;</a></span>genorm_one_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::genorm_one_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>tiles_sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of absolute values of each column of elements, for each tile in Aarray. </p>
<p>Each thread block deals with one tile. Each thread deals with one column. Kernel assumes non-trivial tiles (m, n &gt;= 1). Launched by <a class="el" href="namespaceslate_1_1device.html#a60b351ce9c087021d4607dbd898fc878" title="Batched routine that computes a partial norm for each tile.">genorm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1. Also the number of threads per block (blockDim.x), hence,</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tiles_sums</td><td>Array of dimension gridDim.x * ldv. On exit, tiles_sums[k*ldv + j] = max_{i} abs( A^(k)_(i, j) ) for row j of tile A^(k).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of tiles_sums (values) array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaab550834c570e124e7b51d20e0d8447" name="aaab550834c570e124e7b51d20e0d8447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab550834c570e124e7b51d20e0d8447">&#9670;&#160;</a></span>gescale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t , typename scalar_t2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::gescale </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t2&#160;</td>
          <td class="paramname"><em>numer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t2&#160;</td>
          <td class="paramname"><em>denom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing element-wise tile scale. </p>
<p>Each thread block deals with one tile. Each thread deals with one row. Launched by <a class="el" href="namespaceslate_1_1device.html#aaab550834c570e124e7b51d20e0d8447" title="Kernel implementing element-wise tile scale.">gescale()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numer</td><td>Scale value numerator.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">denom</td><td>Scale value denominator.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>An m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in Aarray. lda &gt;= m. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb13de304abcf20a71ac8288ac43cded" name="abb13de304abcf20a71ac8288ac43cded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb13de304abcf20a71ac8288ac43cded">&#9670;&#160;</a></span>gescale_batch_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t , typename scalar_t2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::gescale_batch_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t2&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing element-wise tile scale. </p>

</div>
</div>
<a id="af8a4816edd5ef88f87ba99423880cfb3" name="af8a4816edd5ef88f87ba99423880cfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a4816edd5ef88f87ba99423880cfb3">&#9670;&#160;</a></span>gescale_col_batch_kernel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t , typename scalar_t2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::gescale_col_batch_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t2 const *const *&#160;</td>
          <td class="paramname"><em>Carray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing column scaling. </p>
<p>Each thread block deals with one tile. Each thread deals with one row. Launched by gescale_row_col().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Carray</td><td>Vector of length n containing column scaling factors.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in Aarray. lda &gt;= m. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ee966028ea4bf8a239a9ed8b5ec1a66" name="a1ee966028ea4bf8a239a9ed8b5ec1a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee966028ea4bf8a239a9ed8b5ec1a66">&#9670;&#160;</a></span>gescale_col_batch_kernel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t , typename scalar_t2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::gescale_col_batch_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t2 const *const *&#160;</td>
          <td class="paramname"><em>Carray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing column scaling. </p>
<p>Each thread block deals with one tile. Each thread deals with one row. Launched by gescale_row_col().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Carray</td><td>Vector of length n containing column scaling factors.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in Aarray. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec106808d9ee4a6ccb7ff4dc0dbb4cad" name="aec106808d9ee4a6ccb7ff4dc0dbb4cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec106808d9ee4a6ccb7ff4dc0dbb4cad">&#9670;&#160;</a></span>gescale_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t , typename scalar_t2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void slate::device::gescale_func </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t2&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Device function implementing element-wise tile scale. </p>
<p>Each thread block deals with one tile. gridDim.x == batch_count. Each thread deals with one row. Called by gescale_kernel and gescale_batch_kernel.</p>
<p>Kernel implementing element-wise tile scale.  </p>
<p>Each thread block deals with one tile. Each thread deals with one row. Launched by <a class="el" href="namespaceslate_1_1device.html#aaab550834c570e124e7b51d20e0d8447" title="Kernel implementing element-wise tile scale.">gescale()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numer</td><td>Scale value numerator.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">denom</td><td>Scale value denominator.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>An m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in Aarray. lda &gt;= m.   </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9d0963f8d030896bad39c5fdcdf19da" name="ae9d0963f8d030896bad39c5fdcdf19da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d0963f8d030896bad39c5fdcdf19da">&#9670;&#160;</a></span>gescale_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t , typename scalar_t2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::gescale_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t2&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing element-wise tile scale. </p>
<p>Kernel implementing element-wise tile scale.  </p>
<p>Each thread block deals with one tile. Each thread deals with one row. Launched by <a class="el" href="namespaceslate_1_1device.html#aaab550834c570e124e7b51d20e0d8447" title="Kernel implementing element-wise tile scale.">gescale()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numer</td><td>Scale value numerator.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">denom</td><td>Scale value denominator.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>An m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in Aarray. lda &gt;= m.   </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab791235f095b59356daa8997f5992ad3" name="ab791235f095b59356daa8997f5992ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab791235f095b59356daa8997f5992ad3">&#9670;&#160;</a></span>gescale_row_batch_kernel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t , typename scalar_t2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::gescale_row_batch_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t2 const *const *&#160;</td>
          <td class="paramname"><em>Rarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing row scaling. </p>
<p>Each thread block deals with one tile. Each thread deals with one row. Launched by gescale_row_col().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Rarray</td><td>Vector of length m containing row scaling factors.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in Aarray. lda &gt;= m. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59238022da23e6d7d2bbe294c5d13e19" name="a59238022da23e6d7d2bbe294c5d13e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59238022da23e6d7d2bbe294c5d13e19">&#9670;&#160;</a></span>gescale_row_batch_kernel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t , typename scalar_t2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::gescale_row_batch_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t2 const *const *&#160;</td>
          <td class="paramname"><em>Rarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing row scaling. </p>
<p>Each thread block deals with one tile. Each thread deals with one row. Launched by gescale_row_col().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Rarray</td><td>Vector of length m containing row scaling factors.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in Aarray. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a547b1e14b37d0c3616e92a82084b2f6b" name="a547b1e14b37d0c3616e92a82084b2f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547b1e14b37d0c3616e92a82084b2f6b">&#9670;&#160;</a></span>gescale_row_col_batch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t , typename scalar_t2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::gescale_row_col_batch </td>
          <td>(</td>
          <td class="paramtype">Equed&#160;</td>
          <td class="paramname"><em>equed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t2 const *const *&#160;</td>
          <td class="paramname"><em>Rarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t2 const *const *&#160;</td>
          <td class="paramname"><em>Carray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Batched routine for row and column scaling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">equed</td><td>Form of scaling to do.<ul>
<li>Equed::Row: sets \( A = diag(R) A         \)</li>
<li>Equed::Col: sets \( A =         A diag(C) \)</li>
<li>Equed::Both: sets \( A = diag(R) A diag(C) \) for each R in Rarray, C in Carray, and A in Aarray.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Rarray</td><td>Vector of length m containing row scaling factors.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Carray</td><td>Vector of length n containing column scaling factors.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d72f28ac09d2eac26109cfef1056900" name="a1d72f28ac09d2eac26109cfef1056900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d72f28ac09d2eac26109cfef1056900">&#9670;&#160;</a></span>gescale_row_col_batch_kernel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t , typename scalar_t2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::gescale_row_col_batch_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t2 const *const *&#160;</td>
          <td class="paramname"><em>Rarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t2 const *const *&#160;</td>
          <td class="paramname"><em>Carray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing row and column scaling. </p>
<p>Each thread block deals with one tile. Each thread deals with one row. Launched by gescale_row_col().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Rarray</td><td>Vector of length m containing row scaling factors.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Carray</td><td>Vector of length n containing column scaling factors.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in Aarray. lda &gt;= m. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93cb91c8693e02c83369fca4302cf78f" name="a93cb91c8693e02c83369fca4302cf78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93cb91c8693e02c83369fca4302cf78f">&#9670;&#160;</a></span>gescale_row_col_batch_kernel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t , typename scalar_t2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::gescale_row_col_batch_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t2 const *const *&#160;</td>
          <td class="paramname"><em>Rarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t2 const *const *&#160;</td>
          <td class="paramname"><em>Carray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing row and column scaling. </p>
<p>Each thread block deals with one tile. Each thread deals with one row. Launched by gescale_row_col().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Rarray</td><td>Vector of length m containing row scaling factors.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Carray</td><td>Vector of length n containing column scaling factors.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in Aarray. lda &gt;= m. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f116ed80d6c87ef6026471fe3eae859" name="a2f116ed80d6c87ef6026471fe3eae859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f116ed80d6c87ef6026471fe3eae859">&#9670;&#160;</a></span>geset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::geset </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const &amp;&#160;</td>
          <td class="paramname"><em>offdiag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const &amp;&#160;</td>
          <td class="paramname"><em>diag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise m-by-n matrix A to diag_value on the diagonal and offdiag_value on the off-diagonals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of A. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offdiag_value</td><td>The value to set outside of the diagonal.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diag_value</td><td>The value to set on the diagonal.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>An m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a729ecd6ec881697545e7896972116f17" name="a729ecd6ec881697545e7896972116f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729ecd6ec881697545e7896972116f17">&#9670;&#160;</a></span>geset_batch_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::geset_batch_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>offdiag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>diag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing element-wise tile set. </p>

</div>
</div>
<a id="aac0702ff0c4d5d96a4d89d06b1cb72cf" name="aac0702ff0c4d5d96a4d89d06b1cb72cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0702ff0c4d5d96a4d89d06b1cb72cf">&#9670;&#160;</a></span>geset_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void slate::device::geset_func </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>offdiag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>diag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing element-wise tile set. </p>
<p>Each thread block deals with one tile. Each thread deals with one row. Launched by <a class="el" href="namespaceslate_1_1device.html#a98b7983908de8253273442b185b2a316" title="Kernel implementing element-wise tile.">geset_kernel()</a> and <a class="el" href="namespaceslate_1_1device.html#a729ecd6ec881697545e7896972116f17" title="Kernel implementing element-wise tile set.">geset_batch_kernel()</a>.</p>
<p>Element-wise m-by-n matrix A to diag_value on the diagonal and offdiag_value on the off-diagonals.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of A. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offdiag_value</td><td>The value to set outside of the diagonal.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diag_value</td><td>The value to set on the diagonal.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>An m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.   </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98b7983908de8253273442b185b2a316" name="a98b7983908de8253273442b185b2a316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b7983908de8253273442b185b2a316">&#9670;&#160;</a></span>geset_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::geset_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>offdiag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>diag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing element-wise tile. </p>
<p>Element-wise m-by-n matrix A to diag_value on the diagonal and offdiag_value on the off-diagonals.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of A. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offdiag_value</td><td>The value to set outside of the diagonal.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diag_value</td><td>The value to set on the diagonal.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>An m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.   </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37dbd054bd0a2272a50eae372315e546" name="a37dbd054bd0a2272a50eae372315e546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dbd054bd0a2272a50eae372315e546">&#9670;&#160;</a></span>henorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::henorm </td>
          <td>(</td>
          <td class="paramtype">lapack::Norm&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Batched routine that computes a partial norm for each tile. </p>
<p>Batched routine that returns the largest absolute value of elements for each tile in Aarray.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">norm</td><td>Norm to compute. See values for description.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>Whether each Aarray[k] is stored in the upper or lower triangle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows and columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an n-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= n.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Array in GPU memory, dimension batch_count * ldv.<ul>
<li>Norm::Max: ldv = 1. On exit, values[k] = max_{i, j} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count.</li>
<li>Norm::One: ldv &gt;= n. On exit, values[k*ldv + j] = sum_{i} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count, 0 &lt;= j &lt; n.</li>
<li>Norm::Inf: for symmetric, same as Norm::One</li>
<li>Norm::Max: ldv = 2. On exit, values[k*2 + 0] = scale_k values[k*2 + 1] = sumsq_k where scale_k^2 sumsq_k = sum_{i,j} abs( A^(k)_(i, j) )^2 for 0 &lt;= k &lt; batch_count.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of values array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets tiles_maxima[k] = max_{i, j}( abs( A^(k)_(i, j) )), for each tile A^(k), where A^(k) = Aarray[k], k = 0, ..., blockDim.x-1, i = 0, ..., n-1, j = 0, ..., n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows and columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an n-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= n.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Array in GPU memory, dimension batch_count * ldv.<ul>
<li>Norm::Max: ldv = 1. On exit, values[k] = max_{i, j} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count.</li>
<li>Norm::One: ldv &gt;= n. On exit, values[k*ldv + j] = sum_{i} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count, 0 &lt;= j &lt; n.</li>
<li>Norm::Inf: for symmetric, same as Norm::One</li>
<li>Norm::Max: ldv = 2. On exit, values[k*2 + 0] = scale_k values[k*2 + 1] = sumsq_k where scale_k^2 sumsq_k = sum_{i,j} abs( A^(k)_(i, j) )^2 for 0 &lt;= k &lt; batch_count.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of tiles_sums (values) array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>device to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab491b3ff67e42049e9bb6ae2c23461b1" name="ab491b3ff67e42049e9bb6ae2c23461b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab491b3ff67e42049e9bb6ae2c23461b1">&#9670;&#160;</a></span>henorm_fro_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::henorm_fro_kernel </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>tiles_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of squares, in scaled representation, for each tile in Aarray. </p>
<p>Each thread block deals with one tile. Each thread deals with one row, followed by a reduction. Kernel assumes non-trivial tiles (n &gt;= 1). Launched by henorm().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows and columns of each tile. n &gt;= 1. Also the number of threads per block, hence,</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension blockDim.x, where each Aarray[k] is an n-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= n.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tiles_values</td><td>Array of dimension 2 * blockDim.x. On exit, tiles_values[2*k + 0] = scale tiles_values[2*k + 1] = sumsq such that scale^2 * sumsq = sum_{i,j} abs( A^(k)_{i,j} )^2 for tile A^(k). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a267e6d26c7f388ac22f2bc90491b8abb" name="a267e6d26c7f388ac22f2bc90491b8abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267e6d26c7f388ac22f2bc90491b8abb">&#9670;&#160;</a></span>henorm_max_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::henorm_max_kernel </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>tiles_maxima</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the largest absolute value of elements, for each tile in Aarray. </p>
<p>Each thread block deals with one tile. Each thread deals with one row, followed by a reduction. Uses dynamic shared memory array of length sizeof(real_t) * n. Kernel assumes non-trivial tiles (n &gt;= 1). Launched by henorm().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows and columns of each tile. n &gt;= 1. Also the number of threads per block (blockDim.x), hence,</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an n-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= n.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tiles_maxima</td><td>Array of dimension gridDim.x. On exit, tiles_maxima[k] = max_{i, j} abs( A^(k)_(i, j) ) for tile A^(k). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a17a28e139699b4ed2b53bf3fecfa06" name="a6a17a28e139699b4ed2b53bf3fecfa06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a17a28e139699b4ed2b53bf3fecfa06">&#9670;&#160;</a></span>henorm_one_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::henorm_one_kernel </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>tiles_sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of absolute values of each column of elements, for each tile in Aarray. </p>
<p>Each thread block deals with one tile. Each thread deals with one column. Kernel assumes non-trivial tiles (n &gt;= 1). Launched by henorm().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows and columns of each tile. n &gt;= 1. Also the number of threads per block (blockDim.x), hence,</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an n-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= n.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tiles_sums</td><td>Array of dimension gridDim.x * ldv. On exit, tiles_sums[k*ldv + j] = max_{i} abs( A^(k)_(i, j) ) for row j of tile A^(k).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of tiles_sums (values) array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe7b76d59d16a26be8daa4ec61a1e949" name="abe7b76d59d16a26be8daa4ec61a1e949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7b76d59d16a26be8daa4ec61a1e949">&#9670;&#160;</a></span>imag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ double slate::device::imag </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>imaginary component of complex number x; 0 for real number. </dd></dl>

</div>
</div>
<a id="ae1d58c036c58fef39e6a5559d529dc8d" name="ae1d58c036c58fef39e6a5559d529dc8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d58c036c58fef39e6a5559d529dc8d">&#9670;&#160;</a></span>max_nan_reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void slate::device::max_nan_reduce </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Max reduction of n-element array x, leaving total in x[0]. </p>
<p>Propogates NaN values consistently. With k threads, can reduce array up to 2*k in size. Assumes number of threads &lt;= 1024, which is the current max number of CUDA threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Size of array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>Thread id.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Array of dimension n. On exit, x[0] = max(x[0], ..., x[n-1]); the rest of x is overwritten. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dce3ac00519c24f395eb17a101a7781" name="a3dce3ac00519c24f395eb17a101a7781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dce3ac00519c24f395eb17a101a7781">&#9670;&#160;</a></span>roundup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ constexpr T slate::device::roundup </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>ceil( x / y )*y, i.e., x rounded up to next multiple of y. </dd></dl>

</div>
</div>
<a id="a92b1499908ea453e618a9252ef9e53bd" name="a92b1499908ea453e618a9252ef9e53bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b1499908ea453e618a9252ef9e53bd">&#9670;&#160;</a></span>sqr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ scalar_t slate::device::sqr </td>
          <td>(</td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Square of number. </p>
<dl class="section return"><dt>Returns</dt><dd>x^2 </dd></dl>

</div>
</div>
<a id="a6e6339759e276cceb4c38fd0112845e9" name="a6e6339759e276cceb4c38fd0112845e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6339759e276cceb4c38fd0112845e9">&#9670;&#160;</a></span>sqr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scalar_t slate::device::sqr </td>
          <td>(</td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Square of number. </p>
<dl class="section return"><dt>Returns</dt><dd>x^2 </dd></dl>

</div>
</div>
<a id="ae12ccce5f8f33571fb780edbec3ac8cf" name="ae12ccce5f8f33571fb780edbec3ac8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12ccce5f8f33571fb780edbec3ac8cf">&#9670;&#160;</a></span>sum_reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void slate::device::sum_reduce </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum reduction of n-element array x, leaving total in x[0]. </p>
<p>With k threads, can reduce array up to 2*k in size. Assumes number of threads &lt;= 1024 (which is current max number of CUDA threads).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Size of array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>Thread id.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Array of dimension n. On exit, x[0] = sum(x[0], ..., x[n-1]); rest of x is overwritten. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18eeb0a397b830086c3688cbfdebe207" name="a18eeb0a397b830086c3688cbfdebe207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18eeb0a397b830086c3688cbfdebe207">&#9670;&#160;</a></span>synorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::synorm </td>
          <td>(</td>
          <td class="paramtype">lapack::Norm&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Batched routine that computes a partial norm for each tile. </p>
<p>Batched routine that returns the largest absolute value of elements for each tile in Aarray.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">norm</td><td>Norm to compute. See values for description.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>Whether each Aarray[k] is stored in the upper or lower triangle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows and columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an n-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= n.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Array in GPU memory, dimension batch_count * ldv.<ul>
<li>Norm::Max: ldv = 1. On exit, values[k] = max_{i, j} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count.</li>
<li>Norm::One: ldv &gt;= n. On exit, values[k*ldv + j] = sum_{i} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count, 0 &lt;= j &lt; n.</li>
<li>Norm::Inf: for symmetric, same as Norm::One</li>
<li>Norm::Max: ldv = 2. On exit, values[k*2 + 0] = scale_k values[k*2 + 1] = sumsq_k where scale_k^2 sumsq_k = sum_{i,j} abs( A^(k)_(i, j) )^2 for 0 &lt;= k &lt; batch_count.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of values array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets tiles_maxima[k] = max_{i, j}( abs( A^(k)_(i, j) )), for each tile A^(k), where A^(k) = Aarray[k], k = 0, ..., blockDim.x-1, i = 0, ..., n-1, j = 0, ..., n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows and columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an n-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= n.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Array in GPU memory, dimension batch_count * ldv.<ul>
<li>Norm::Max: ldv = 1. On exit, values[k] = max_{i, j} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count.</li>
<li>Norm::One: ldv &gt;= n. On exit, values[k*ldv + j] = sum_{i} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count, 0 &lt;= j &lt; n.</li>
<li>Norm::Inf: for symmetric, same as Norm::One</li>
<li>Norm::Fro: ldv = 2. On exit, values[k*2 + 0] = scale_k values[k*2 + 1] = sumsq_k where scale_k^2 sumsq_k = sum_{i,j} abs( A^(k)_(i, j) )^2 for 0 &lt;= k &lt; batch_count.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of tiles_sums (values) array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>device to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1b1cf478de49eb26801f221e11737fb" name="ad1b1cf478de49eb26801f221e11737fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b1cf478de49eb26801f221e11737fb">&#9670;&#160;</a></span>synorm_fro_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::synorm_fro_kernel </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>tiles_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of squares, in scaled representation, for each tile in Aarray. </p>
<p>Each thread block deals with one tile. Each thread deals with one row, followed by a reduction. Kernel assumes non-trivial tiles (n &gt;= 1). Launched by synorm().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows and columns of each tile. n &gt;= 1. Also the number of threads per block, hence,</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension blockDim.x, where each Aarray[k] is an n-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= n.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tiles_values</td><td>Array of dimension 2 * blockDim.x. On exit, tiles_values[2*k + 0] = scale tiles_values[2*k + 1] = sumsq such that scale^2 * sumsq = sum_{i,j} abs( A^(k)_{i,j} )^2 for tile A^(k). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a614fa7e65e7e37b0f8a54c95b81f1656" name="a614fa7e65e7e37b0f8a54c95b81f1656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614fa7e65e7e37b0f8a54c95b81f1656">&#9670;&#160;</a></span>synorm_max_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::synorm_max_kernel </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>tiles_maxima</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the largest absolute value of elements, for each tile in Aarray. </p>
<p>Each thread block deals with one tile. Each thread deals with one row, followed by a reduction. Uses dynamic shared memory array of length sizeof(real_t) * n. Kernel assumes non-trivial tiles (n &gt;= 1). Launched by synorm().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows and columns of each tile. n &gt;= 1. Also the number of threads per block (blockDim.x), hence,</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an n-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= n.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tiles_maxima</td><td>Array of dimension gridDim.x. On exit, tiles_maxima[k] = max_{i, j} abs( A^(k)_(i, j) ) for tile A^(k). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e52d8ae608627675a292e5589383feb" name="a8e52d8ae608627675a292e5589383feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e52d8ae608627675a292e5589383feb">&#9670;&#160;</a></span>synorm_offdiag_one_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::synorm_offdiag_one_kernel </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>tiles_sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of absolute values of each row and each column of elements, for each tile in tiles. </p>
<p>Each thread block deals with one tile. Kernel assumes non-trivial tiles (m, n &gt;= 1). Launched by <a class="el" href="namespaceslate_1_1device.html#a4bae869c820fdb608cc5c4a9d69ba746" title="Batched routine that computes a partial norm for each tile.">synormOffdiag()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tiles_sums</td><td>Array of dimension gridDim.x * ldv. On exit, tiles_sums[k*ldv + j] = sum_{i} abs( A^(k)_(i, j) ) for column j of tile A^(k), and tiles_sums[k*ldv + i + n] = sum_{j} abs( A^(k)_(i, j) ) for row i of tile A^(k).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of tiles_sums (values) array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a302280542e73454c342d78b725bc4330" name="a302280542e73454c342d78b725bc4330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302280542e73454c342d78b725bc4330">&#9670;&#160;</a></span>synorm_one_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::synorm_one_kernel </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>tiles_sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of absolute values of each column of elements, for each tile in Aarray. </p>
<p>Each thread block deals with one tile. Each thread deals with one column. Kernel assumes non-trivial tiles (n &gt;= 1). Launched by synorm().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows and columns of each tile. n &gt;= 1. Also the number of threads per block (blockDim.x), hence,</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an n-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= n.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tiles_sums</td><td>Array of dimension gridDim.x * ldv. On exit, tiles_sums[k*ldv + j] = max_{i} abs( A^(k)_(i, j) ) for row j of tile A^(k).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of tiles_sums (values) array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bae869c820fdb608cc5c4a9d69ba746" name="a4bae869c820fdb608cc5c4a9d69ba746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bae869c820fdb608cc5c4a9d69ba746">&#9670;&#160;</a></span>synormOffdiag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::synormOffdiag </td>
          <td>(</td>
          <td class="paramtype">lapack::Norm&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Batched routine that computes a partial norm for each tile. </p>
<p>Batched routine that returns the largest absolute value of elements for each tile in Aarray.</p>
<p>Used for full, off-diagonal tiles within a symmetric matrix, where element Aij contributes to both column i and j.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">norm</td><td>Norm to compute. See values for description.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Array in GPU memory, dimension batch_count * ldv.<ul>
<li>Norm::Max: ldv = 1. On exit, values[k] = max_{i, j} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count.</li>
<li>Norm::One: ldv &gt;= n. On exit, values[k*ldv + j] = sum_{i} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count, 0 &lt;= j &lt; n.</li>
<li>Norm::Inf: for symmetric, same as Norm::One</li>
<li>Norm::Max: ldv = 2. On exit, values[k*2 + 0] = scale_k values[k*2 + 1] = sumsq_k where scale_k^2 sumsq_k = sum_{i,j} abs( A^(k)_(i, j) )^2 for 0 &lt;= k &lt; batch_count.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of values array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets tiles_maxima[k] = max_{i, j}( abs( A^(k)_(i, j) )), for each tile A^(k), where A^(k) = Aarray[k], k = 0, ..., blockDim.x-1, i = 0, ..., n-1, j = 0, ..., n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows and columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an n-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= n.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Array in GPU memory, dimension batch_count * ldv.<ul>
<li>Norm::Max: ldv = 1. On exit, values[k] = max_{i, j} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count.</li>
<li>Norm::One: ldv &gt;= n. On exit, values[k*ldv + j] = sum_{i} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count, 0 &lt;= j &lt; n.</li>
<li>Norm::Inf: for symmetric, same as Norm::One</li>
<li>Norm::Max: ldv = 2. On exit, values[k*2 + 0] = scale_k values[k*2 + 1] = sumsq_k where scale_k^2 sumsq_k = sum_{i,j} abs( A^(k)_(i, j) )^2 for 0 &lt;= k &lt; batch_count.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of tiles_sums (values) array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>GPU device to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7475b89a28a56c93b480c5d612e93369" name="a7475b89a28a56c93b480c5d612e93369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7475b89a28a56c93b480c5d612e93369">&#9670;&#160;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t , int NX&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::transpose </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>dAT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Physically transpose a rectangular matrix out-of-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of columns of tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows of tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA</td><td>A rectangular m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of dA. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dAT</td><td>A rectangular m-by-n matrix stored in an ldat-by-m array in GPU memory. On output, dAT is the transpose of dA.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldat</td><td>Leading dimension of dAT. ldat &gt;= n.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of columns of tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows of tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA</td><td>A rectangular m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of dA. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dAT</td><td>A rectangular m-by-n matrix stored in an ldat-by-m array in GPU memory. On output, dAT is the transpose of dA.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldat</td><td>Leading dimension of dAT. ldat &gt;= n.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b58c06cfb7511c5ae533fcb05b7c431" name="a0b58c06cfb7511c5ae533fcb05b7c431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b58c06cfb7511c5ae533fcb05b7c431">&#9670;&#160;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::transpose </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Physically transpose a square matrix in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows and columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>A square n-by-n matrix stored in an lda-by-n array in GPU memory. On output, A is transposed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of A. lda &gt;= n.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5903fb3d604edbe6ab667d2aab5f931e" name="a5903fb3d604edbe6ab667d2aab5f931e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5903fb3d604edbe6ab667d2aab5f931e">&#9670;&#160;</a></span>transpose_batch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t , int NX&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::transpose_batch </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>dAT_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Physically transpose a batch of rectangular matrices out-of-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of columns of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array in GPU memory of dimension batch_count, containing pointers to matrices, where each dA_array[k] is a rectangular m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each dA_array[k] tile. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dAT_array</td><td>Array in GPU memory of dimension batch_count, containing pointers to matrices, where each dAT_array[k] is a rectangular m-by-n matrix stored in an ldat-by-m array in GPU memory. On output, each dAT_array[k] is the transpose of dA_array[k].</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldat</td><td>Leading dimension of each dAT_array[k] tile. ldat &gt;= n.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of columns of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array in GPU memory of dimension batch_count, containing pointers to matrices, where each dA_array[k] is a rectangular m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each dA_array[k] tile. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dAT_array</td><td>Array in GPU memory of dimension batch_count, containing pointers to matrices, where each dAT_array[k] is a rectangular m-by-n matrix stored in an ldat-by-m array in GPU memory. On output, each dAT_array[k] is the transpose of dA_array[k].</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each dAT_array[k] tile. ldat &gt;= n.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a1666cc690ea5c2abe2df7494b3d7bc" name="a4a1666cc690ea5c2abe2df7494b3d7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1666cc690ea5c2abe2df7494b3d7bc">&#9670;&#160;</a></span>transpose_batch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::transpose_batch </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Physically transpose a batch of square matrices in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows and columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to matrices, where each Aarray[k] is a square n-by-n matrix stored in an lda-by-n array in GPU memory. On output, each Aarray[k] is transposed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= n.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7883ab588ea7cf8c633afe2c4875c087" name="a7883ab588ea7cf8c633afe2c4875c087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7883ab588ea7cf8c633afe2c4875c087">&#9670;&#160;</a></span>transpose_func() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t , int NX&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void slate::device::transpose_func </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>AT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tile M-by-N matrix with ceil(M/NB) by ceil(N/NB) tiles sized NB-by-NB. </p>
<p>uses NX-by-NY threads, where NB/NX, NB/NY, NX/NY evenly. subtile each NB-by-NB tile with (NB/NX) subtiles sized NX-by-NB for each subtile load NX-by-NB subtile transposed from A into sA, as (NB/NY) blocks sized NX-by-NY save NB-by-NX subtile from sA into AT, as (NB/NX)*(NX/NY) blocks sized NX-by-NY A += NX AT += NX*ldat</p>
<p>e.g., with NB=32, NX=32, NY=8 ([sdc] precisions) load 32x32 subtile as 4 blocks of 32x8 columns: (A11 A12 A13 A14 ) save 32x32 subtile as 1*4 blocks of 32x8 columns: (AT11 AT12 AT13 AT14)</p>
<p>e.g., with NB=32, NX=16, NY=8 (z precision) load 16x32 subtile as 4 blocks of 16x8 columns: (A11 A12 A13 A14) save 32x16 subtile as 2*2 blocks of 16x8 columns: (AT11 AT12) (AT21 AT22) </p>

</div>
</div>
<a id="abd88f594f98e1adb985d0eb4de6c4e13" name="abd88f594f98e1adb985d0eb4de6c4e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd88f594f98e1adb985d0eb4de6c4e13">&#9670;&#160;</a></span>transpose_func() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void slate::device::transpose_func </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Device routine handles one matrix. </p>
<p>Thread block grid: x = batch index (ignored here; see batch kernel), y = block row index, z = block col index. Each thread block is ib-by-ib threads and does one ib-by-ib block of an n-by-n matrix.</p>
<p>Let nt = ceildiv( n, ib ) be the number of blocks for one n-by-n matrix. An even number of blocks uses an (nt + 1) by (nt/2) grid. Example: for nt = 4 blocks, y by z = 5 by 2 grid: [ A00 A01 ] [-&mdash;. A11 ] [ A10 . | . . ] [ A10 '-&mdash;] [ A20 A21 | . . ] [ A20 A21 ] covers matrix as [ A30 A31 | A00 . ] [ A30 A31 ] [ A40 A41 | A01 A11 ] [ A40 A41 ]</p>
<p>An odd number of blocks uses an (nt) by (nt + 1)/2 grid. Example: for nt = 5 blocks, y by z = 5 by 3 grid: [ A00 | A01 A02 ] [ '-&mdash;. ] [ A00 . . | . . ] [ A10 A11 | A12 ] [ A10 A11 . | . . ] [ '--&mdash;] covers matrix as [ A20 A21 A22 | . . ] [ A20 A21 A22 ] [ A30 A31 A32 | A01 . ] [ A30 A31 A32 ] [ A40 A41 A42 | A02 A12 ] [ A40 A41 A42 ] </p>

</div>
</div>
<a id="ab8bfe3526c6fa18ab2bfc267024a4202" name="ab8bfe3526c6fa18ab2bfc267024a4202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8bfe3526c6fa18ab2bfc267024a4202">&#9670;&#160;</a></span>transpose_rect_batch_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t , int NX&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::transpose_rect_batch_func </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>dAarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>dATarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Device routine handles batches of rectangular matrices. </p>
<p>The routine loads blocks of data into small NX x NB local storage and then writes the blocks back transposed into the correct location transposed. </p>

</div>
</div>
<a id="a356e9791bd80e453b213f1e99772a16a" name="a356e9791bd80e453b213f1e99772a16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356e9791bd80e453b213f1e99772a16a">&#9670;&#160;</a></span>transpose_rect_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t , int NX&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::transpose_rect_func </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>dAT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Device routine handles single rectangular matrox. </p>
<p>The routine loads blocks of data into small NX x NB local storage and then writes the blocks back transposed into the correct location transposed. </p>

</div>
</div>
<a id="a0a0faa116a8609119c395c84c85d1f95" name="a0a0faa116a8609119c395c84c85d1f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0faa116a8609119c395c84c85d1f95">&#9670;&#160;</a></span>transpose_sqr_batch_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::transpose_sqr_batch_func </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Device routine handles batches of square matrices. </p>
<p>The routine loads blocks of data into small ib x ib local storage and then writes the blocks back transposed into the correct location transposed. </p>

</div>
</div>
<a id="a47790071d4cff993ca95f01e8628da3f" name="a47790071d4cff993ca95f01e8628da3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47790071d4cff993ca95f01e8628da3f">&#9670;&#160;</a></span>transpose_sqr_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::transpose_sqr_func </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Device routine handles single square matrix. </p>
<p>The routine loads blocks of data into small ib x ib local storage and then writes the blocks back transposed into the correct location transposed. </p>

</div>
</div>
<a id="a8b5c5e6316ae5a420ca9a1edd340e9aa" name="a8b5c5e6316ae5a420ca9a1edd340e9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5c5e6316ae5a420ca9a1edd340e9aa">&#9670;&#160;</a></span>trnorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::trnorm </td>
          <td>(</td>
          <td class="paramtype">lapack::Norm&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lapack::Diag&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Batched routine that computes a partial norm for each trapezoidal tile. </p>
<p>Batched routine that returns the largest absolute value of elements for each tile in Aarray.</p>
<p>todo: rename to tznorm for consistency with other tz routines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">norm</td><td>Norm to compute. See values for description.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>Whether each Aarray[k] is upper or lower trapezoidal.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diag</td><td>Whether or not each Aarray[k] has unit diagonal.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Array in GPU memory, dimension batch_count * ldv.<ul>
<li>Norm::Max: ldv = 1. On exit, values[k] = max_{i, j} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count.</li>
<li>Norm::One: ldv &gt;= n. On exit, values[k*ldv + j] = sum_{i} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count, 0 &lt;= j &lt; n.</li>
<li>Norm::Inf: ldv &gt;= m. On exit, values[k*ldv + i] = sum_{j} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count, 0 &lt;= i &lt; m.</li>
<li>Norm::Max: ldv = 2. On exit, values[k*2 + 0] = scale_k values[k*2 + 1] = sumsq_k where scale_k^2 sumsq_k = sum_{i,j} abs( A^(k)_(i, j) )^2 for 0 &lt;= k &lt; batch_count.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of values array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets tiles_maxima[k] = max_{i, j}( abs( A^(k)_(i, j) )), for each tile A^(k), where A^(k) = Aarray[k], k = 0, ..., blockDim.x-1, i = 0, ..., m-1, j = 0, ..., n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>Array in GPU memory, dimension batch_count * ldv.<ul>
<li>Norm::Max: ldv = 1. On exit, values[k] = max_{i, j} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count.</li>
<li>Norm::One: ldv &gt;= n. On exit, values[k*ldv + j] = sum_{i} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count, 0 &lt;= j &lt; n.</li>
<li>Norm::Inf: ldv &gt;= m. On exit, values[k*ldv + i] = sum_{j} abs( A^(k)_(i, j) ) for 0 &lt;= k &lt; batch_count, 0 &lt;= i &lt; m.</li>
<li>Norm::Max: ldv = 2. On exit, values[k*2 + 0] = scale_k values[k*2 + 1] = sumsq_k where scale_k^2 sumsq_k = sum_{i,j} abs( A^(k)_(i, j) )^2 for 0 &lt;= k &lt; batch_count.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of tiles_sums (values) array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>device to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fe21fef28e458d9538708fe79fa7dfd" name="a7fe21fef28e458d9538708fe79fa7dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe21fef28e458d9538708fe79fa7dfd">&#9670;&#160;</a></span>trnorm_fro_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::trnorm_fro_kernel </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lapack::Diag&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>tiles_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of squares, in scaled representation, for each tile in Aarray. </p>
<p>Each thread block deals with one tile. Each thread deals with one row, followed by a reduction. Kernel assumes non-trivial tiles (m, n &gt;= 1). Launched by trnorm().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1. Also the number of threads per block, hence,</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension blockDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tiles_values</td><td>Array of dimension 2 * blockDim.x. On exit, tiles_values[2*k + 0] = scale tiles_values[2*k + 1] = sumsq such that scale^2 * sumsq = sum_{i,j} abs( A^(k)_{i,j} )^2 for tile A^(k). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41493b5e18928a25fcf0e0302a873b2d" name="a41493b5e18928a25fcf0e0302a873b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41493b5e18928a25fcf0e0302a873b2d">&#9670;&#160;</a></span>trnorm_inf_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::trnorm_inf_kernel </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lapack::Diag&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>tiles_sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of absolute values of each row of elements, for each tile in Aarray. </p>
<p>Each thread block deals with one tile. Each thread deals with one row. Kernel assumes non-trivial tiles (m, n &gt;= 1). Launched by trnorm().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1. Also the number of threads per block, hence,</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tiles_sums</td><td>Array of dimension gridDim.x * ldv. On exit, tiles_sums[k*ldv + i] = sum_{j} abs( A^(k)_(i, j) ) for row i of tile A^(k).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of tiles_sums (values) array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13aa86014eb77b3e6ae027aea47ae547" name="a13aa86014eb77b3e6ae027aea47ae547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13aa86014eb77b3e6ae027aea47ae547">&#9670;&#160;</a></span>trnorm_max_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::trnorm_max_kernel </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lapack::Diag&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>tiles_maxima</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the largest absolute value of elements, for each tile in Aarray. </p>
<p>Each thread block deals with one tile. Each thread deals with one row, followed by a reduction. Uses dynamic shared memory array of length sizeof(real_t) * m. Kernel assumes non-trivial tiles (m, n &gt;= 1). Launched by trnorm().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1. Also the number of threads per block (blockDim.x), hence,</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tiles_maxima</td><td>Array of dimension gridDim.x. On exit, tiles_maxima[k] = max_{i, j} abs( A^(k)_(i, j) ) for tile A^(k). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab254e30979d820251eb98eafe9b148d9" name="ab254e30979d820251eb98eafe9b148d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab254e30979d820251eb98eafe9b148d9">&#9670;&#160;</a></span>trnorm_one_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::trnorm_one_kernel </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lapack::Diag&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt; *&#160;</td>
          <td class="paramname"><em>tiles_sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of absolute values of each column of elements, for each tile in Aarray. </p>
<p>Each thread block deals with one tile. Each thread deals with one column. Kernel assumes non-trivial tiles (m, n &gt;= 1). Launched by trnorm().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1. Also the number of threads per block (blockDim.x), hence,</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tiles_sums</td><td>Array of dimension gridDim.x * ldv. On exit, tiles_sums[k*ldv + j] = max_{i} abs( A^(k)_(i, j) ) for row j of tile A^(k).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldv</td><td>Leading dimension of tiles_sums (values) array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b3c62d83c449f2a5db05830408bbe1c" name="a7b3c62d83c449f2a5db05830408bbe1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3c62d83c449f2a5db05830408bbe1c">&#9670;&#160;</a></span>tzadd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::tzadd </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Barray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Batched routine for element-wise trapezoidal tile addition. </p>
<p>Sets upper or lower part of  </p><p class="formulaDsp">
\[
    Barray[k] = \alpha Aarray[k] + \beta Barray[k].
\]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>Whether each Aarray[k] is upper or lower trapezoidal.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar alpha.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The scalar beta.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Barray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Barray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>Leading dimension of each tile in B. ldb &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray and Barray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets upper or lower part of  </p><p class="formulaDsp">
\[
    Barray[k] = \alpha Aarray[k] + \beta Barray[k].
\]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>Whether each Aarray[k] is upper or lower trapezoidal.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The scalar alpha.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The scalar beta.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Barray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Barray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>Leading dimension of each tile in B. ldb &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray and Barray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7a0fd92f889ac508798ae309591293b" name="ad7a0fd92f889ac508798ae309591293b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a0fd92f889ac508798ae309591293b">&#9670;&#160;</a></span>tzadd_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::tzadd_kernel </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Barray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing element-wise tile addition. </p>
<p>Each thread block deals with one tile. Each thread deals with one row. Launched by tzadd().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in Aarray. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Barray</td><td>Array of tiles of dimension gridDim.x, where each Barray[k] is an m-by-n matrix stored in an ldb-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>Leading dimension of each tile in Barray. ldb &gt;= m. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad25ee70776f04b7cb79473c1517a2cbd" name="ad25ee70776f04b7cb79473c1517a2cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25ee70776f04b7cb79473c1517a2cbd">&#9670;&#160;</a></span>tzcopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename src_scalar_t , typename dst_scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::tzcopy </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">src_scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dst_scalar_t **&#160;</td>
          <td class="paramname"><em>Barray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Batched routine for element-wise trapezoidal copy and precision conversion, copying A to B. </p>
<p>Batched routine for element-wise copy and precision conversion.</p>
<p>Sets upper or lower part of  </p><p class="formulaDsp">
\[
    Barray[k] = Aarray[k].
\]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>Whether each Aarray[k] is upper or lower trapezoidal.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Barray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Barray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>Leading dimension of each tile in B. ldb &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray and Barray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Barray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Barray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>Leading dimension of each tile in B. ldb &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray and Barray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>Device to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb09bc25625cd9248b7e585dabd9276d" name="acb09bc25625cd9248b7e585dabd9276d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb09bc25625cd9248b7e585dabd9276d">&#9670;&#160;</a></span>tzcopy_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename src_scalar_t , typename dst_scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::tzcopy_kernel </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">src_scalar_t const *const *&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dst_scalar_t **&#160;</td>
          <td class="paramname"><em>Barray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing copy and precision conversions, copying A to B. </p>
<p>Each thread block deals with one tile. Each thread deals with one row. Launched by tzcopy().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in Aarray. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Barray</td><td>Array of tiles of dimension gridDim.x, where each Barray[k] is an m-by-n matrix stored in an ldb-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>Leading dimension of each tile in Barray. ldb &gt;= m. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adce04468574ec9f6bfee77eb0538e7a2" name="adce04468574ec9f6bfee77eb0538e7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce04468574ec9f6bfee77eb0538e7a2">&#9670;&#160;</a></span>tzscale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::tzscale </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt;&#160;</td>
          <td class="paramname"><em>numer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt;&#160;</td>
          <td class="paramname"><em>denom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Batched routine for element-wise trapezoidal tile scale. </p>
<p>Sets upper or lower part of  </p><p class="formulaDsp">
\[
    Aarray[k] *= (numer / denom).
\]
</p>
<p> This does NOT currently take extra care to avoid over/underflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>Whether each Aarray[k] is upper or lower trapezoidal.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numer</td><td>Scale value numerator.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">denom</td><td>Scale value denominator.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets upper or lower part of  </p><p class="formulaDsp">
\[
    Aarray[k] *= (numer / denom).
\]
</p>
<p> This does NOT currently take extra care to avoid over/underflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>Whether each Aarray[k] is upper or lower trapezoidal.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numer</td><td>Scale value numerator.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">denom</td><td>Scale value denominator.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Aarray</td><td>Array in GPU memory of dimension batch_count, containing pointers to tiles, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_count</td><td>Size of Aarray. batch_count &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac927241272af627bf54b354ae155a396" name="ac927241272af627bf54b354ae155a396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac927241272af627bf54b354ae155a396">&#9670;&#160;</a></span>tzscale_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::tzscale_kernel </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt;&#160;</td>
          <td class="paramname"><em>numer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt;&#160;</td>
          <td class="paramname"><em>denom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing element-wise tile scale. </p>
<p>Each thread block deals with one tile. Each thread deals with one row. Launched by <a class="el" href="namespaceslate_1_1device.html#aaab550834c570e124e7b51d20e0d8447" title="Kernel implementing element-wise tile scale.">gescale()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of each tile. m &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of each tile. n &gt;= 1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numer</td><td>Scale value numerator.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">denom</td><td>Scale value denominator.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Aarray</td><td>Array of tiles of dimension gridDim.x, where each Aarray[k] is an m-by-n matrix stored in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of each tile in Aarray. lda &gt;= m. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec4251f42f05687393d25133b908ec12" name="aec4251f42f05687393d25133b908ec12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4251f42f05687393d25133b908ec12">&#9670;&#160;</a></span>tzset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::device::tzset </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const &amp;&#160;</td>
          <td class="paramname"><em>offdiag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t const &amp;&#160;</td>
          <td class="paramname"><em>diag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise trapezoidal tile set. </p>
<p>Sets upper or lower part of Aarray[k] to diag_value on the diagonal and offdiag_value on the off-diagonals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>Whether each Aarray[k] is upper or lower trapezoidal.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of A. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offdiag_value</td><td>Constant to set offdiagonal entries to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diag_value</td><td>Constant to set diagonal entries to.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>An m-by-n matrix stored in an lda-by-n array in GPU memory.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>Leading dimension of A. lda &gt;= m.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>BLAS++ queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bbb6a459a998511b0fe71915a488879" name="a3bbb6a459a998511b0fe71915a488879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbb6a459a998511b0fe71915a488879">&#9670;&#160;</a></span>tzset_batch_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::tzset_batch_kernel </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>offdiag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>diag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t **&#160;</td>
          <td class="paramname"><em>Aarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing element-wise tile set. </p>

</div>
</div>
<a id="a2289398e7d5eaaa3b418fe8eb99e6d93" name="a2289398e7d5eaaa3b418fe8eb99e6d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2289398e7d5eaaa3b418fe8eb99e6d93">&#9670;&#160;</a></span>tzset_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void slate::device::tzset_func </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>offdiag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>diag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Device function implementing element-wise tile set. </p>
<p>Each thread block deals with one tile. gridDim.x == batch_count. Each thread deals with one row. Called by tzset_kernel and tzset_batch_kernel.</p>

</div>
</div>
<a id="a62ad3ce98a1ad71b7f91e954e3d6cb45" name="a62ad3ce98a1ad71b7f91e954e3d6cb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ad3ce98a1ad71b7f91e954e3d6cb45">&#9670;&#160;</a></span>tzset_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void slate::device::tzset_kernel </td>
          <td>(</td>
          <td class="paramtype">lapack::Uplo&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>offdiag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t&#160;</td>
          <td class="paramname"><em>diag_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementing element-wise tile set. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a055f04b11eeed2104bbb8ad7b18c579e" name="a055f04b11eeed2104bbb8ad7b18c579e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055f04b11eeed2104bbb8ad7b18c579e">&#9670;&#160;</a></span>ib</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const int slate::device::ib = 32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>block size for genorm_one_kernel </p>
<p>internal blocking 16 x 16 thread block = 256 threads 32 x 32 thread block = 1024 threads </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceslate.html">slate</a></li><li class="navelem"><a class="el" href="namespaceslate_1_1device.html">device</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
