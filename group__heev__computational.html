<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SLATE: Computational</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
// see https://stackoverflow.com/questions/40270302/latex-newcommand-in-doxgygen-html-output
// see http://docs.mathjax.org/en/latest/tex.html#defining-tex-macros
MathJax.Hub.Config({
    TeX: {
        Macros: {
            abs: ["\\left| #1 \\right|", 1],
            norm: ["\\left\\lVert #1 \\right\\rVert", 1],
        }
    }
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SLATE<span id="projectnumber">&#160;2023.08.25</span>
   </div>
   <div id="projectbrief">Software for Linear Algebra Targeting Exascale</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__heev__computational.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Computational<div class="ingroups"><a class="el" href="group__group__heev.html">Symmetric/Hermitian eigenvalues</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga89078c3a9b4dd5ef6ef5dae463b21855"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:ga89078c3a9b4dd5ef6ef5dae463b21855"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#ga89078c3a9b4dd5ef6ef5dae463b21855">slate::hb2st</a> (<a class="el" href="classslate_1_1_hermitian_band_matrix.html">HermitianBandMatrix</a>&lt; scalar_t &gt; &amp;A, <a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; scalar_t &gt; &amp;V, Options const  &amp;opts)</td></tr>
<tr class="memdesc:ga89078c3a9b4dd5ef6ef5dae463b21855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces a band Hermitian matrix to a bidiagonal matrix using bulge chasing.  <br /></td></tr>
<tr class="separator:ga89078c3a9b4dd5ef6ef5dae463b21855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5dec51e8d1d19a22fa8b44c6f800fb1"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:gac5dec51e8d1d19a22fa8b44c6f800fb1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#gac5dec51e8d1d19a22fa8b44c6f800fb1">slate::he2hb</a> (<a class="el" href="classslate_1_1_hermitian_matrix.html">HermitianMatrix</a>&lt; scalar_t &gt; &amp;A, TriangularFactors&lt; scalar_t &gt; &amp;T, Options const  &amp;opts)</td></tr>
<tr class="memdesc:gac5dec51e8d1d19a22fa8b44c6f800fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed parallel reduction to band for 3-stage SVD.  <br /></td></tr>
<tr class="separator:gac5dec51e8d1d19a22fa8b44c6f800fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2267e02a3aa0bdd691278b13c747d324"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:ga2267e02a3aa0bdd691278b13c747d324"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#ga2267e02a3aa0bdd691278b13c747d324">slate::internal::herf</a> (int64_t n, scalar_t *v, <a class="el" href="classslate_1_1_hermitian_matrix.html">HermitianMatrix</a>&lt; scalar_t &gt; &amp;A)</td></tr>
<tr class="memdesc:ga2267e02a3aa0bdd691278b13c747d324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a Householder reflector \(H = I - \tau v v^H\) to the Hermitian matrix \(A\) on the left and right.  <br /></td></tr>
<tr class="separator:ga2267e02a3aa0bdd691278b13c747d324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad7e048be2043b00662414d1493d6f3f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target, typename scalar_t &gt; </td></tr>
<tr class="memitem:gaad7e048be2043b00662414d1493d6f3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#gaad7e048be2043b00662414d1493d6f3f">slate::internal::hebr1</a> (int64_t n, scalar_t *v, <a class="el" href="classslate_1_1_hermitian_matrix.html">HermitianMatrix</a>&lt; scalar_t &gt; &amp;&amp;A, int priority)</td></tr>
<tr class="memdesc:gaad7e048be2043b00662414d1493d6f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements task type 1 in the tridiagonal bulge chasing algorithm.  <br /></td></tr>
<tr class="separator:gaad7e048be2043b00662414d1493d6f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19c3ec03abcaab3b804d8034227fa003"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target, typename scalar_t &gt; </td></tr>
<tr class="memitem:ga19c3ec03abcaab3b804d8034227fa003"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#ga19c3ec03abcaab3b804d8034227fa003">slate::internal::hebr2</a> (int64_t n1, scalar_t *v1, int64_t n2, scalar_t *v2, <a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; scalar_t &gt; &amp;&amp;A, int priority)</td></tr>
<tr class="memdesc:ga19c3ec03abcaab3b804d8034227fa003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements task type 2 in the tridiagonal bulge chasing algorithm.  <br /></td></tr>
<tr class="separator:ga19c3ec03abcaab3b804d8034227fa003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37159bcd02f6d5374f67d299f16bdb6e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target, typename scalar_t &gt; </td></tr>
<tr class="memitem:ga37159bcd02f6d5374f67d299f16bdb6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#ga37159bcd02f6d5374f67d299f16bdb6e">slate::internal::hebr3</a> (int64_t n, scalar_t *v, <a class="el" href="classslate_1_1_hermitian_matrix.html">HermitianMatrix</a>&lt; scalar_t &gt; &amp;&amp;A, int priority)</td></tr>
<tr class="memdesc:ga37159bcd02f6d5374f67d299f16bdb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements task type 3 in the tridiagonal bulge chasing algorithm.  <br /></td></tr>
<tr class="separator:ga37159bcd02f6d5374f67d299f16bdb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa640da0ee8dfbda9f4b89c48f67499a"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:gafa640da0ee8dfbda9f4b89c48f67499a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#gafa640da0ee8dfbda9f4b89c48f67499a">slate::internal::hebr3</a> (<a class="el" href="classslate_1_1internal_1_1_target_type.html">internal::TargetType</a>&lt; <a class="el" href="group__enum.html#ggaf84c73d5e2cf203effad4b6cb3f96fb8a2b490f62685eb7600e1f4c96b361392d">Target::HostTask</a> &gt;, int64_t n, scalar_t *v, <a class="el" href="classslate_1_1_hermitian_matrix.html">HermitianMatrix</a>&lt; scalar_t &gt; &amp;A, int priority)</td></tr>
<tr class="memdesc:gafa640da0ee8dfbda9f4b89c48f67499a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements task type 3 in the tridiagonal bulge chasing algorithm, updating a diagonal block with a 2-sided Householder transformation.  <br /></td></tr>
<tr class="separator:gafa640da0ee8dfbda9f4b89c48f67499a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b5bc5ffa7a232de750cbc65f5363e37"><td class="memTemplParams" colspan="2">template&lt;typename real_t &gt; </td></tr>
<tr class="memitem:ga1b5bc5ffa7a232de750cbc65f5363e37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#ga1b5bc5ffa7a232de750cbc65f5363e37">slate::stedc</a> (std::vector&lt; real_t &gt; &amp;D, std::vector&lt; real_t &gt; &amp;E, <a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;Q, Options const  &amp;opts)</td></tr>
<tr class="memdesc:ga1b5bc5ffa7a232de750cbc65f5363e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all eigenvalues and eigenvectors of a real symmetric tridiagonal matrix in parallel, using the divide and conquer algorithm.  <br /></td></tr>
<tr class="separator:ga1b5bc5ffa7a232de750cbc65f5363e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7994337c6aff4414bbe101abe07d61c7"><td class="memTemplParams" colspan="2">template&lt;typename real_t &gt; </td></tr>
<tr class="memitem:ga7994337c6aff4414bbe101abe07d61c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#ga7994337c6aff4414bbe101abe07d61c7">slate::stedc_deflate</a> (int64_t n, int64_t n1, real_t &amp;rho, real_t *D, real_t *Dsecular, real_t *z, real_t *zsecular, <a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;Q, <a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;Qtype, int64_t *itype, int64_t &amp;nsecular, int64_t &amp;Qtype12_begin, int64_t &amp;Qtype12_end, int64_t &amp;Qtype23_begin, int64_t &amp;Qtype23_end, Options const  &amp;opts)</td></tr>
<tr class="memdesc:ga7994337c6aff4414bbe101abe07d61c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the two sets of eigenvalues together into a single sorted set, then deflates eigenvalues, which both resolves stability issues (division by zero) and reduces the size of the problem.  <br /></td></tr>
<tr class="separator:ga7994337c6aff4414bbe101abe07d61c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4bed6d7d0e924b53f87612f2e428829"><td class="memTemplParams" colspan="2">template&lt;typename real_t &gt; </td></tr>
<tr class="memitem:gae4bed6d7d0e924b53f87612f2e428829"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#gae4bed6d7d0e924b53f87612f2e428829">slate::stedc_merge</a> (int64_t n, int64_t n1, real_t rho, real_t *D, <a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;Q, <a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;Qtype, <a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;U, Options const  &amp;opts)</td></tr>
<tr class="memdesc:gae4bed6d7d0e924b53f87612f2e428829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the updated eigensystem of a diagonal matrix after modification by a rank-one symmetric matrix, in parallel.  <br /></td></tr>
<tr class="separator:gae4bed6d7d0e924b53f87612f2e428829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6106751fa9c97975e8c4536a3728705b"><td class="memTemplParams" colspan="2">template&lt;typename real_t &gt; </td></tr>
<tr class="memitem:ga6106751fa9c97975e8c4536a3728705b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#ga6106751fa9c97975e8c4536a3728705b">slate::stedc_secular</a> (int64_t nsecular, int64_t n, real_t rho, real_t *D, real_t *z, real_t *Lambda, <a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;U, int64_t *itype, Options const  &amp;opts)</td></tr>
<tr class="memdesc:ga6106751fa9c97975e8c4536a3728705b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the nsecular roots of the secular equation, as defined by the values in rho, D, z, and computes the corresponding eigenvectors in U.  <br /></td></tr>
<tr class="separator:ga6106751fa9c97975e8c4536a3728705b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4e92522c5bc066bcd4a0c79e9e3affa"><td class="memTemplParams" colspan="2">template&lt;typename real_t &gt; </td></tr>
<tr class="memitem:gae4e92522c5bc066bcd4a0c79e9e3affa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#gae4e92522c5bc066bcd4a0c79e9e3affa">slate::stedc_solve</a> (std::vector&lt; real_t &gt; &amp;D, std::vector&lt; real_t &gt; &amp;E, <a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;Q, <a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;W, <a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;U, Options const  &amp;opts)</td></tr>
<tr class="memdesc:gae4e92522c5bc066bcd4a0c79e9e3affa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all eigenvalues and eigenvectors of a symmetric tridiagonal matrix in parallel, using the divide and conquer algorithm.  <br /></td></tr>
<tr class="separator:gae4e92522c5bc066bcd4a0c79e9e3affa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35100da638a52cdb53358b36f4264456"><td class="memTemplParams" colspan="2">template&lt;typename real_t &gt; </td></tr>
<tr class="memitem:ga35100da638a52cdb53358b36f4264456"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#ga35100da638a52cdb53358b36f4264456">slate::stedc_z_vector</a> (<a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;Q, std::vector&lt; real_t &gt; &amp;z, Options const  &amp;opts)</td></tr>
<tr class="memdesc:ga35100da638a52cdb53358b36f4264456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Communicates the z vector to all ranks.  <br /></td></tr>
<tr class="separator:ga35100da638a52cdb53358b36f4264456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedff964a438ef68caa9f42c0257be488"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:gaedff964a438ef68caa9f42c0257be488"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#gaedff964a438ef68caa9f42c0257be488">slate::steqr2</a> (Job jobz, std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;D, std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;E, <a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; scalar_t &gt; &amp;Z, Options const  &amp;opts)</td></tr>
<tr class="memdesc:gaedff964a438ef68caa9f42c0257be488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all eigenvalues/eigenvectors of a symmetric tridiagonal matrix using the Pal-Walker-Kahan variant of the QL or QR algorithm.  <br /></td></tr>
<tr class="separator:gaedff964a438ef68caa9f42c0257be488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01f4056da8aa73fc5b41cef0f712ee53"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:ga01f4056da8aa73fc5b41cef0f712ee53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#ga01f4056da8aa73fc5b41cef0f712ee53">slate::sterf</a> (std::vector&lt; scalar_t &gt; &amp;D, std::vector&lt; scalar_t &gt; &amp;E, Options const  &amp;opts)</td></tr>
<tr class="memdesc:ga01f4056da8aa73fc5b41cef0f712ee53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all eigenvalues of a symmetric tridiagonal matrix using the Pal-Walker-Kahan variant of the QL or QR algorithm.  <br /></td></tr>
<tr class="separator:ga01f4056da8aa73fc5b41cef0f712ee53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d27d43054b13d11d65ca431df25cd75"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:ga4d27d43054b13d11d65ca431df25cd75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#ga4d27d43054b13d11d65ca431df25cd75">slate::unmtr_hb2st</a> (Side side, Op op, <a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; scalar_t &gt; &amp;V, <a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; scalar_t &gt; &amp;C, const std::map&lt; <a class="el" href="group__enum.html#gac97a2c5045464e6949b9a65a059b196a">Option</a>, <a class="el" href="namespaceslate.html#a465030a77a3e6068e26371eb16c51927">Value</a> &gt; &amp;opts)</td></tr>
<tr class="memdesc:ga4d27d43054b13d11d65ca431df25cd75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the general m-by-n matrix C by Q from <code><a class="el" href="group__heev__computational.html#ga89078c3a9b4dd5ef6ef5dae463b21855" title="Reduces a band Hermitian matrix to a bidiagonal matrix using bulge chasing.">slate::hb2st</a></code> as follows:  <br /></td></tr>
<tr class="separator:ga4d27d43054b13d11d65ca431df25cd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cd32768b1b35b377a1f2f478b072dde"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:ga9cd32768b1b35b377a1f2f478b072dde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__heev__computational.html#ga9cd32768b1b35b377a1f2f478b072dde">slate::unmtr_he2hb</a> (Side side, Op op, <a class="el" href="classslate_1_1_hermitian_matrix.html">HermitianMatrix</a>&lt; scalar_t &gt; &amp;A, TriangularFactors&lt; scalar_t &gt; T, <a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; scalar_t &gt; &amp;C, Options const  &amp;opts)</td></tr>
<tr class="memdesc:ga9cd32768b1b35b377a1f2f478b072dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the general m-by-n matrix C by Q from <code><a class="el" href="group__heev__computational.html#gac5dec51e8d1d19a22fa8b44c6f800fb1" title="Distributed parallel reduction to band for 3-stage SVD.">slate::he2hb</a></code> as follows:  <br /></td></tr>
<tr class="separator:ga9cd32768b1b35b377a1f2f478b072dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga89078c3a9b4dd5ef6ef5dae463b21855" name="ga89078c3a9b4dd5ef6ef5dae463b21855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89078c3a9b4dd5ef6ef5dae463b21855">&#9670;&#160;</a></span>hb2st()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::hb2st </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslate_1_1_hermitian_band_matrix.html">HermitianBandMatrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces a band Hermitian matrix to a bidiagonal matrix using bulge chasing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">scalar_t</td><td>One of float, double, std::complex&lt;float&gt;, std::complex&lt;double&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>The band Hermitian matrix A.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td><a class="el" href="classslate_1_1_matrix.html" title="General non-symmetric, m-by-n, distributed, tiled matrices.">Matrix</a> of Householder reflectors produced in the process. Dimension 2*band-by-XYZ todo</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Additional options, as map of name = value pairs. Possible options:<ul>
<li><a class="el" href="group__enum.html#ggac97a2c5045464e6949b9a65a059b196aac41a31890959544c6523af684561abe5" title="computation method (">Option::Target</a>: Implementation to target. Possible values:<ul>
<li>HostTask: OpenMP tasks on CPU host [default].</li>
<li>HostNest: nested OpenMP parallel for loop on CPU host.</li>
<li>HostBatch: batched BLAS on CPU host.</li>
<li>Devices: batched BLAS on GPU device. </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5dec51e8d1d19a22fa8b44c6f800fb1" name="gac5dec51e8d1d19a22fa8b44c6f800fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5dec51e8d1d19a22fa8b44c6f800fb1">&#9670;&#160;</a></span>he2hb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::he2hb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslate_1_1_hermitian_matrix.html">HermitianMatrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TriangularFactors&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distributed parallel reduction to band for 3-stage SVD. </p>
<p>Reduces an n-by-n Hermitian matrix \(A\) to band form using unitary transformations. The factorization has the form  </p><p class="formulaDsp">
\[
    A = Q B Q^H
\]
</p>
<p> where \(Q\) is unitary and \(B\) is Hermitian band with nb sub and superdiagonals. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">scalar_t</td><td>One of float, double, std::complex&lt;float&gt;, std::complex&lt;double&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>On entry, the n-by-n Hermitian matrix \(A\). On exit:<ul>
<li>[upper is not yet implemented] If A is upper, the elements Aij for j = i, ..., i+nb, represent the Hermitian band matrix B. The elements above the nb-th superdiagonal, along with T, represent the unitary matrix \(Q\) as a product of elementary reflectors.</li>
<li>If A is lower, the elements Aij for j = i-nb, ..., i, represent the Hermitian band matrix B. The elements below the nb-th subdiagonal, along with T, represent the unitary matrix \(Q\) as a product of elementary reflectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>On exit, triangular matrices of the block reflectors for Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Additional options, as map of name = value pairs. Possible options:<ul>
<li><a class="el" href="group__enum.html#ggac97a2c5045464e6949b9a65a059b196aa78fc353d89080d549ffd917ff688a3c9" title="inner blocking size, &gt;= 1">Option::InnerBlocking</a>: Inner blocking to use for panel. Default 16.</li>
<li><a class="el" href="group__enum.html#ggac97a2c5045464e6949b9a65a059b196aaae6f02dd2c1fd23a8f149de7afed2a87" title="max number of threads for panel, &gt;= 1">Option::MaxPanelThreads</a>: Number of threads to use for panel. Default omp_get_max_threads()/2.</li>
<li><a class="el" href="group__enum.html#ggac97a2c5045464e6949b9a65a059b196aac41a31890959544c6523af684561abe5" title="computation method (">Option::Target</a>: Implementation to target. Possible values:<ul>
<li>HostTask: OpenMP tasks on CPU host [default].</li>
<li>HostNest: not implemented.</li>
<li>HostBatch: not implemented.</li>
<li>Devices: batched BLAS on GPU device. Note a lookahead is not possible with he2hb due to dependencies from updating on both left and right sides. </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaad7e048be2043b00662414d1493d6f3f" name="gaad7e048be2043b00662414d1493d6f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad7e048be2043b00662414d1493d6f3f">&#9670;&#160;</a></span>hebr1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target, typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::internal::hebr1 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_hermitian_matrix.html">HermitianMatrix</a>&lt; scalar_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements task type 1 in the tridiagonal bulge chasing algorithm. </p>
<p>Dispatches to target implementations. </p>

</div>
</div>
<a id="ga19c3ec03abcaab3b804d8034227fa003" name="ga19c3ec03abcaab3b804d8034227fa003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19c3ec03abcaab3b804d8034227fa003">&#9670;&#160;</a></span>hebr2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target, typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::internal::hebr2 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; scalar_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements task type 2 in the tridiagonal bulge chasing algorithm. </p>
<p>Dispatches to target implementations. </p>

</div>
</div>
<a id="ga37159bcd02f6d5374f67d299f16bdb6e" name="ga37159bcd02f6d5374f67d299f16bdb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37159bcd02f6d5374f67d299f16bdb6e">&#9670;&#160;</a></span>hebr3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target, typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::internal::hebr3 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_hermitian_matrix.html">HermitianMatrix</a>&lt; scalar_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements task type 3 in the tridiagonal bulge chasing algorithm. </p>
<p>Dispatches to target implementations. </p>

</div>
</div>
<a id="gafa640da0ee8dfbda9f4b89c48f67499a" name="gafa640da0ee8dfbda9f4b89c48f67499a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa640da0ee8dfbda9f4b89c48f67499a">&#9670;&#160;</a></span>hebr3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::internal::hebr3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslate_1_1internal_1_1_target_type.html">internal::TargetType</a>&lt; <a class="el" href="group__enum.html#ggaf84c73d5e2cf203effad4b6cb3f96fb8a2b490f62685eb7600e1f4c96b361392d">Target::HostTask</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_hermitian_matrix.html">HermitianMatrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements task type 3 in the tridiagonal bulge chasing algorithm, updating a diagonal block with a 2-sided Householder transformation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Length of vector v.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The Householder reflector produced by task type 2.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>A diagonal block in a sweep. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2267e02a3aa0bdd691278b13c747d324" name="ga2267e02a3aa0bdd691278b13c747d324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2267e02a3aa0bdd691278b13c747d324">&#9670;&#160;</a></span>herf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::internal::herf </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_hermitian_matrix.html">HermitianMatrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a Householder reflector \(H = I - \tau v v^H\) to the Hermitian matrix \(A\) on the left and right. </p>
<p>Takes the \(\tau\) factor from \(v[0]\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Length of vector v.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The vector v in the representation of H. Modified but restored on exit.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>The n-by-n Hermitian matrix A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b5bc5ffa7a232de750cbc65f5363e37" name="ga1b5bc5ffa7a232de750cbc65f5363e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b5bc5ffa7a232de750cbc65f5363e37">&#9670;&#160;</a></span>stedc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::stedc </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes all eigenvalues and eigenvectors of a real symmetric tridiagonal matrix in parallel, using the divide and conquer algorithm. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_t</td><td>One of float, double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td>On entry, the diagonal elements of the tridiagonal matrix. On exit, the eigenvalues in ascending order. D is duplicated on all MPI ranks.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E</td><td>On entry, the subdiagonal elements of the tridiagonal matrix. On exit, E has been destroyed. E is duplicated on all MPI ranks.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>On exit, Q contains the orthonormal eigenvectors of the symmetric tridiagonal matrix. Code currently requires that Q has a 2D block-cyclic distribution, with column-major grid order, which is the default for a SLATE <a class="el" href="classslate_1_1_matrix.html" title="General non-symmetric, m-by-n, distributed, tiled matrices.">Matrix</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Additional options, as map of name = value pairs. Possible options:<ul>
<li><a class="el" href="group__enum.html#ggac97a2c5045464e6949b9a65a059b196aac41a31890959544c6523af684561abe5" title="computation method (">Option::Target</a>: Implementation to target. Possible values:<ul>
<li>HostTask: OpenMP tasks on CPU host [default].</li>
<li>HostNest: nested OpenMP parallel for loop on CPU host.</li>
<li>HostBatch: batched BLAS on CPU host.</li>
<li>Devices: batched BLAS on GPU device. </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7994337c6aff4414bbe101abe07d61c7" name="ga7994337c6aff4414bbe101abe07d61c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7994337c6aff4414bbe101abe07d61c7">&#9670;&#160;</a></span>stedc_deflate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::stedc_deflate </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t *&#160;</td>
          <td class="paramname"><em>Dsecular</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t *&#160;</td>
          <td class="paramname"><em>zsecular</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Qtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>nsecular</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>Qtype12_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>Qtype12_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>Qtype23_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>Qtype23_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the two sets of eigenvalues together into a single sorted set, then deflates eigenvalues, which both resolves stability issues (division by zero) and reduces the size of the problem. </p>
<p>There are two ways in which deflation can occur: 1) There is a zero or tiny entry in the z vector, indicating an eigenvalue of the subproblems is already converged to an eigenvalue of the merged problem, so it can be deflated. 2) Two eigenvalues are (nearly) identical. In this case, a Givens rotation is applied to zero an entry of z, and the corresponding eigenvalue can be deflated. For each such occurrence the order of the related secular equation problem is reduced by one.</p>
<p>Corresponds to ScaLAPACK pdlaed2. (Was: indicates ScaLAPACK names.) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_t</td><td>One of float, double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Size of merged system. n = n1 + n2.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n1</td><td>Size of first subproblem, D1. Note that n2, the size of second subproblem, D2, is not passed and is computed as n2 = n - n1.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rho</td><td>On entry, the off-diagonal element associated with the rank-1 cut that originally split the two submatrices to be merged. On exit, rho has been scaled to be positive and make \(z\) unit norm, as required by stedc_secular.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td>Real vector of dimension n. On entry, D1 = D[ 0 : n1-1 ] contains eigenvalues of the first subproblem, D2 = D[ n1 : n-1 ] contains eigenvalues of the second subproblem. On exit, deflated eigenvalues are in decreasing order at the <em>local</em> end within a process column (pcol) per the 2D block cyclic distribution of Q. Example on 2 ranks with nb = 4. To easily track values, let D1 be multiples of 3, and D2 be even numbers. Deflate arbitrary values 6, 9, 21, 4, 12 (see ^ marks). Value 6 is type 2 deflation since it is repeated; the rest are type 1 deflation. Note 9, 6, 4 stay on pcol 0, and 21, 12 stay on pcol 1. pcol = [ 0 0 0 0 | 1 1 1 1 | 0 0 0 0 | 1 1 1 1 ] D_in = [ 3 6 9 12 | 15 18 21 24 | 2 4 6 8 | 10 12 14 16 ] [ ^ ^ | ^ | ^ | ^ ] D_out = [ # # # # | # # # # | # 9 6 4 | # # 21 12 ] [ | | ^ ^ ^ | ^ ^ ] Dsecular = [ 2 3 6 8 | 10 12 14 15 | 16 18 24 # | # # # # ] where | separate blocks, and # values are not set.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Dsecular</td><td>Real vector of dimension n. On exit, Dsecular[ 0 : nsecular-1 ] contains non-deflated eigenvalues, sorted in increasing order. (Was: dlamda)</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">z</td><td>Real vector of dimension n. On entry, z is the updating vector, z = Q^T v = [ Q1^T 0 ] [ e_n1 ], [ 0 Q2^T ] [ e_1 ] which is the last row of Q1 and the first row of Q2. On exit, the contents of z are destroyed.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">zsecular</td><td>Real vector of dimension n. On exit, zsecular[ 0 : nsecular-1 ] has non-deflated entries of z, as updated by normalizing and applying Givens rotations in deflation, for use by stedc_secular. (Was: w)</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>Real n-by-n matrix. On entry, the eigenvectors of the two subproblems, Q = [ Q1 0 ]. [ 0 Q2 ] On exit, eigenvectors associated with type 2 deflation have been modified.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qtype</td><td>Real n-by-n matrix. A copy of all the eigenvectors locally ordered by column type such that Qtype(:, itype) = Q(:, ideflate). Non-deflated eigenvectors will be used by stedc_merge in a matrix multiply (gemm) to solve for the new eigenvectors; deflated eigenvectors will be copied back to Q in the correct place.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ct_count</td><td>Integer npcol-by-5 array. On exit, ct_count( pcol, ctype ) is the number of columns of column type ctype on process column pcol. ctype = 1:4, column ctype = 0 is unused.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">itype</td><td>Integer vector of dimension n. On exit, permutation to arrange columns of Qtype locally into 4 column types based on block structure: 1: non-zero in upper half only (rows 0 : n1-1). 2: non-zero in all rows; non-deflated eigenvector from type 2 deflation when one vector is from Q1 and the other vector is from Q2. 3: non-zero in lower half only (rows n1 : n-1). 4: may be non-zero in all rows; deflated eigenvectors. (Was: indx)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nsecular</td><td>On exit, number of non-deflated eigenvalues. (Was: k)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Qtype12_begin</td><td>On exit, index of first column in Qtype sub-matrix spanning column types 1 and 2. Because of local permutation, this may include columns of types 3 and 4. (Was: ib1)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Qtype12_end</td><td>On exit, index of last column + 1 in Qtype sub-matrix spanning column types 1 and 2. (Was: ib1 + nn1)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Qtype23_begin</td><td>On exit, index of first column in Qtype sub-matrix spanning column types 2 and 3. Because of local permutation, this may include columns of types 1 and 4. (Was: ib2)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Qtype23_end</td><td>On exit, index of last column + 1 in Qtype sub-matrix spanning column types 2 and 3. (Was: ib2 + nn2)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Additional options, as map of name = value pairs. Possible options:<ul>
<li><a class="el" href="group__enum.html#ggac97a2c5045464e6949b9a65a059b196aac41a31890959544c6523af684561abe5" title="computation method (">Option::Target</a>: Implementation to target. Possible values:<ul>
<li>HostTask: OpenMP tasks on CPU host [default].</li>
<li>HostNest: nested OpenMP parallel for loop on CPU host.</li>
<li>HostBatch: batched BLAS on CPU host.</li>
<li>Devices: batched BLAS on GPU device. </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae4bed6d7d0e924b53f87612f2e428829" name="gae4bed6d7d0e924b53f87612f2e428829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4bed6d7d0e924b53f87612f2e428829">&#9670;&#160;</a></span>stedc_merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::stedc_merge </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Qtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the updated eigensystem of a diagonal matrix after modification by a rank-one symmetric matrix, in parallel. </p>
<p class="formulaDsp">
\[
    T = Q_{in} ( D_{in} + \rho Z Z^H ) Q_{in}^H = Q_{out} D_{out} Q_{out}^H
\]
</p>
<p> where \(z = Q^H v\) and \(v = [ e_{n1} e_1 ]\) is a vector of length \(n\) with ones in the \(n1\) and \(n1 + 1\) elements and zeros elsewhere.</p>
<p>The eigenvectors of the original matrix are stored in Q, and the eigenvalues are in D. The algorithm consists of three stages:</p>
<p>The first stage consists of deflating the size of the problem when there are multiple eigenvalues or if there is a zero in the \(z\) vector. For each such occurence, the dimension of the secular equation problem is reduced by one. This stage is performed by the routine stedc_deflate.</p>
<p>The second stage consists of calculating the updated eigenvalues. This is done by finding the roots of the secular equation via the LAPACK routine laed4, called by stedc_secular. This routine also calculates the eigenvectors of the current problem.</p>
<p>The final stage consists of computing the updated eigenvectors directly using the updated eigenvalues. The eigenvectors for the current problem are multiplied with the eigenvectors from the overall problem.</p>
<p>Corresponds to ScaLAPACK pdlaed1. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_t</td><td>One of float, double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Size of merged system. n = n1 + n2.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n1</td><td>Size of first subproblem, D1. Size of second subproblem, D2, is n2 = n - n1.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rho</td><td>On entry, the off-diagonal element associated with the rank-1 cut that originally split the two submatrices to be merged. On exit, updated by deflation process.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td>On entry, the eigenvalues of two subproblems. On exit, the eigenvalues of the merged problem, not sorted.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>On entry, Q contains eigenvectors of subproblems. On exit, Q contains the orthonormal eigenvectors of the merged problem.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Qtype</td><td>Qtype is a workspace, the same size as Q.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>U is a workspace, the same size as Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Additional options, as map of name = value pairs. Possible options:<ul>
<li><a class="el" href="group__enum.html#ggac97a2c5045464e6949b9a65a059b196aac41a31890959544c6523af684561abe5" title="computation method (">Option::Target</a>: Implementation to target. Possible values:<ul>
<li>HostTask: OpenMP tasks on CPU host [default].</li>
<li>HostNest: nested OpenMP parallel for loop on CPU host.</li>
<li>HostBatch: batched BLAS on CPU host.</li>
<li>Devices: batched BLAS on GPU device. </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6106751fa9c97975e8c4536a3728705b" name="ga6106751fa9c97975e8c4536a3728705b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6106751fa9c97975e8c4536a3728705b">&#9670;&#160;</a></span>stedc_secular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::stedc_secular </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nsecular</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t *&#160;</td>
          <td class="paramname"><em>Lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the nsecular roots of the secular equation, as defined by the values in rho, D, z, and computes the corresponding eigenvectors in U. </p>
<p>Corresponds to ScaLAPACK pdlaed3. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_t</td><td>One of float, double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nsecular</td><td>The number of non-deflated eigenvalues, and the order of the related secular equation. 0 &lt;= nsecular &lt;= n.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of rows and columns in the U matrix. n &gt;= nsecular (deflation may result in n &gt; nsecular).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rho</td><td>The off-diagonal element associated with the rank-1 cut that originally split the two submatrices to be merged, as modified by stedc_deflate to be positive and make \(z\) unit norm.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>The nsecular non-deflated eigenvalues of the two sub-problems, as output by stedc_deflate in Dsecular, which will be used by laed4 to form the secular equation.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>The nsecular entries of the deflation-adjusted z vector, as output by stedc_deflate in zsecular.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Lambda</td><td>On entry, Lambda contains the (n - nsecular) deflated eigenvalues, as output by stedc_deflate in D. On exit, Lambda contains all n eigenvalues, permuted by itype.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>On exit, U contains the orthonormal eigenvectors from the secular equation, permuted by itype.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itype</td><td>Permutation that arranged Qtype locally into 4 groups by column type, Qtype = [ Q11 Q12 Q14 ], [ Q22 Q23 Q24 ] as output by stedc_deflate. Used to permute Lambda and U to match Qtype.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Additional options, as map of name = value pairs. Possible options:<ul>
<li><a class="el" href="group__enum.html#ggac97a2c5045464e6949b9a65a059b196aac41a31890959544c6523af684561abe5" title="computation method (">Option::Target</a>: Implementation to target. Possible values:<ul>
<li>HostTask: OpenMP tasks on CPU host [default].</li>
<li>HostNest: nested OpenMP parallel for loop on CPU host.</li>
<li>HostBatch: batched BLAS on CPU host.</li>
<li>Devices: batched BLAS on GPU device. </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae4e92522c5bc066bcd4a0c79e9e3affa" name="gae4e92522c5bc066bcd4a0c79e9e3affa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4e92522c5bc066bcd4a0c79e9e3affa">&#9670;&#160;</a></span>stedc_solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::stedc_solve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes all eigenvalues and eigenvectors of a symmetric tridiagonal matrix in parallel, using the divide and conquer algorithm. </p>
<p>Corresponds to ScaLAPACK pdlaed0. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_t</td><td>One of float, double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td>On entry, the diagonal elements of the tridiagonal matrix. On exit, the eigenvalues, not sorted.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E</td><td>On entry, the subdiagonal elements of the tridiagonal matrix. On exit, E has been destroyed.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>On entry, Q is the Identity. On exit, Q contains the orthonormal eigenvectors of the symmetric tridiagonal matrix.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>W is a workspace, the same size as Q.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>U is a workspace, the same size as Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Additional options, as map of name = value pairs. Possible options:<ul>
<li><a class="el" href="group__enum.html#ggac97a2c5045464e6949b9a65a059b196aac41a31890959544c6523af684561abe5" title="computation method (">Option::Target</a>: Implementation to target. Possible values:<ul>
<li>HostTask: OpenMP tasks on CPU host [default].</li>
<li>HostNest: nested OpenMP parallel for loop on CPU host.</li>
<li>HostBatch: batched BLAS on CPU host.</li>
<li>Devices: batched BLAS on GPU device. </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga35100da638a52cdb53358b36f4264456" name="ga35100da638a52cdb53358b36f4264456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35100da638a52cdb53358b36f4264456">&#9670;&#160;</a></span>stedc_z_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::stedc_z_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Communicates the z vector to all ranks. </p>
<p>Corresponds to ScaLAPACK pdlaedz. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_t</td><td>One of float, double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td>On entry, matrix of eigenvectors for 2 sub-problems being merged, Q = [ Q1 0 ]. [ 0 Q2 ] If Q is nt-by-nt tiles, then: Q1 is nt1-by-nt1 tiles with nt1 = floor( nt / 2 ), Q2 is nt2-by-nt2 tiles with nt2 = ceil( nt / 2 ).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">z</td><td>On exit, z vector in divide-and-conquer algorithm, consisting of the last row of Q1 and the first row of Q2: z = Q^T [ e_{n_1} ] = [ Q1^T e_{n_1} ]. [ e_1 ] [ Q2^T e_1 ] z is duplicated on all MPI ranks.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Additional options, as map of name = value pairs. Possible options:<ul>
<li>Currently none </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaedff964a438ef68caa9f42c0257be488" name="gaedff964a438ef68caa9f42c0257be488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedff964a438ef68caa9f42c0257be488">&#9670;&#160;</a></span>steqr2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::steqr2 </td>
          <td>(</td>
          <td class="paramtype">Job&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes all eigenvalues/eigenvectors of a symmetric tridiagonal matrix using the Pal-Walker-Kahan variant of the QL or QR algorithm. </p>
<p>ATTENTION: only host computation supported for now </p>

</div>
</div>
<a id="ga01f4056da8aa73fc5b41cef0f712ee53" name="ga01f4056da8aa73fc5b41cef0f712ee53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01f4056da8aa73fc5b41cef0f712ee53">&#9670;&#160;</a></span>sterf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::sterf </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes all eigenvalues of a symmetric tridiagonal matrix using the Pal-Walker-Kahan variant of the QL or QR algorithm. </p>
<p>ATTENTION: only host computation supported for now </p>

</div>
</div>
<a id="ga4d27d43054b13d11d65ca431df25cd75" name="ga4d27d43054b13d11d65ca431df25cd75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d27d43054b13d11d65ca431df25cd75">&#9670;&#160;</a></span>unmtr_hb2st()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::unmtr_hb2st </td>
          <td>(</td>
          <td class="paramtype">Side&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="group__enum.html#gac97a2c5045464e6949b9a65a059b196a">Option</a>, <a class="el" href="namespaceslate.html#a465030a77a3e6068e26371eb16c51927">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies the general m-by-n matrix C by Q from <code><a class="el" href="group__heev__computational.html#ga89078c3a9b4dd5ef6ef5dae463b21855" title="Reduces a band Hermitian matrix to a bidiagonal matrix using bulge chasing.">slate::hb2st</a></code> as follows: </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">op   </th><th class="markdownTableHeadNone">side = Left   </th><th class="markdownTableHeadNone">side = Right (not supported)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">op = NoTrans   </td><td class="markdownTableBodyNone">\(Q C  \)   </td><td class="markdownTableBodyNone">\(C Q  \)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">op = ConjTrans   </td><td class="markdownTableBodyNone">\(Q^H C\)   </td><td class="markdownTableBodyNone">\(C Q^H\)   </td></tr>
</table>
<p>where \(Q\) is a unitary matrix defined as the product of k elementary reflectors  </p><p class="formulaDsp">
\[
    Q = H(1) H(2) . . . H(k)
\]
</p>
 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">scalar_t</td><td>One of float, double, std::complex&lt;float&gt;, std::complex&lt;double&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td><ul>
<li>Side::Left: apply \(Q\) or \(Q^H\) from the left;</li>
<li>Side::Right: apply \(Q\) or \(Q^H\) from the right (not supported).</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td><ul>
<li>Op::NoTrans apply \(Q\);</li>
<li>Op::ConjTrans: apply \(Q^H\);</li>
<li>Op::Trans: apply \(Q^T\) (only if real). In the real case, Op::Trans is equivalent to Op::ConjTrans. In the complex case, Op::Trans is not allowed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>Householder vectors as returned by <code><a class="el" href="group__heev__computational.html#ga89078c3a9b4dd5ef6ef5dae463b21855" title="Reduces a band Hermitian matrix to a bidiagonal matrix using bulge chasing.">slate::hb2st</a></code>.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>On entry, the m-by-n matrix \(C\). On exit, \(C\) is overwritten by \(Q C\), \(Q^H C\), \(C Q\), or \(C Q^H\). C must be distributed 1D block column (cyclic or non-cyclic).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Additional options, as map of name = value pairs. Possible options:<ul>
<li><a class="el" href="group__enum.html#ggac97a2c5045464e6949b9a65a059b196aac41a31890959544c6523af684561abe5" title="computation method (">Option::Target</a>: Implementation to target. Possible values:<ul>
<li>HostTask: OpenMP tasks on CPU host [default].</li>
<li>HostNest: nested OpenMP parallel for loop on CPU host.</li>
<li>HostBatch: batched BLAS on CPU host.</li>
<li>Devices: batched BLAS on GPU device. </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9cd32768b1b35b377a1f2f478b072dde" name="ga9cd32768b1b35b377a1f2f478b072dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cd32768b1b35b377a1f2f478b072dde">&#9670;&#160;</a></span>unmtr_he2hb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::unmtr_he2hb </td>
          <td>(</td>
          <td class="paramtype">Side&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_hermitian_matrix.html">HermitianMatrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TriangularFactors&lt; scalar_t &gt;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">Matrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies the general m-by-n matrix C by Q from <code><a class="el" href="group__heev__computational.html#gac5dec51e8d1d19a22fa8b44c6f800fb1" title="Distributed parallel reduction to band for 3-stage SVD.">slate::he2hb</a></code> as follows: </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">op   </th><th class="markdownTableHeadNone">side = Left   </th><th class="markdownTableHeadNone">side = Right    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">op = NoTrans   </td><td class="markdownTableBodyNone">\(Q C  \)   </td><td class="markdownTableBodyNone">\(C Q  \)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">op = ConjTrans   </td><td class="markdownTableBodyNone">\(Q^H C\)   </td><td class="markdownTableBodyNone">\(C Q^H\)   </td></tr>
</table>
<p>where \(Q\) is a unitary matrix defined as the product of k elementary reflectors  </p><p class="formulaDsp">
\[
    Q = H(1) H(2) . . . H(k)
\]
</p>
 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">scalar_t</td><td>One of float, double, std::complex&lt;float&gt;, std::complex&lt;double&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td><ul>
<li>Side::Left: apply \(Q\) or \(Q^H\) from the left;</li>
<li>Side::Right: apply \(Q\) or \(Q^H\) from the right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td><ul>
<li>Op::NoTrans apply \(Q\);</li>
<li>Op::ConjTrans: apply \(Q^H\);</li>
<li>Op::Trans: apply \(Q^T\) (only if real). In the real case, Op::Trans is equivalent to Op::ConjTrans. In the complex case, Op::Trans is not allowed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>On entry, the n-by-n Hermitian matrix \(A\), as returned by <code><a class="el" href="group__heev__computational.html#gac5dec51e8d1d19a22fa8b44c6f800fb1" title="Distributed parallel reduction to band for 3-stage SVD.">slate::he2hb</a></code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>On entry, triangular matrices of the elementary reflector H(i), as returned by <code><a class="el" href="group__heev__computational.html#gac5dec51e8d1d19a22fa8b44c6f800fb1" title="Distributed parallel reduction to band for 3-stage SVD.">slate::he2hb</a></code>.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>On entry, the m-by-n matrix \(C\). On exit, \(C\) is overwritten by \(Q C\), \(Q^H C\), \(C Q\), or \(C Q^H\).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opts</td><td>Additional options, as map of name = value pairs. Possible options:<ul>
<li><a class="el" href="group__enum.html#ggac97a2c5045464e6949b9a65a059b196aac41a31890959544c6523af684561abe5" title="computation method (">Option::Target</a>: Implementation to target. Possible values:<ul>
<li>HostTask: OpenMP tasks on CPU host [default].</li>
<li>HostNest: nested OpenMP parallel for loop on CPU host.</li>
<li>HostBatch: batched BLAS on CPU host.</li>
<li>Devices: batched BLAS on GPU device. </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
