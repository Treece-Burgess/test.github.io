<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SLATE: slate::BaseMatrix&lt; scalar_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
// see https://stackoverflow.com/questions/40270302/latex-newcommand-in-doxgygen-html-output
// see http://docs.mathjax.org/en/latest/tex.html#defining-tex-macros
MathJax.Hub.Config({
    TeX: {
        Macros: {
            abs: ["\\left| #1 \\right|", 1],
            norm: ["\\left\\lVert #1 \\right\\rVert", 1],
        }
    }
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SLATE<span id="projectnumber">&#160;2023.08.25</span>
   </div>
   <div id="projectbrief">Software for Linear Algebra Targeting Exascale</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classslate_1_1_base_matrix.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classslate_1_1_base_matrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">slate::BaseMatrix&lt; scalar_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Base class for all SLATE distributed, tiled matrices.  
 <a href="classslate_1_1_base_matrix.html#details">More...</a></p>

<p><code>#include &lt;BaseMatrix.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for slate::BaseMatrix&lt; scalar_t &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classslate_1_1_base_matrix.png" usemap="#slate::BaseMatrix_3C_20scalar_5Ft_20_3E_map" alt=""/>
  <map id="slate::BaseMatrix_3C_20scalar_5Ft_20_3E_map" name="slate::BaseMatrix_3C_20scalar_5Ft_20_3E_map">
<area href="classslate_1_1_base_band_matrix.html" title="Base class for all SLATE distributed, tiled banded storage matrices." alt="slate::BaseBandMatrix&lt; scalar_t &gt;" shape="rect" coords="136,56,399,80"/>
<area href="classslate_1_1_base_trapezoid_matrix.html" title="Base class for all SLATE distributed, tiled trapezoidal storage matrices." alt="slate::BaseTrapezoidMatrix&lt; scalar_t &gt;" shape="rect" coords="819,56,1082,80"/>
<area href="classslate_1_1_matrix.html" title="General non-symmetric, m-by-n, distributed, tiled matrices." alt="slate::Matrix&lt; scalar_t &gt;" shape="rect" coords="1092,56,1355,80"/>
<area href="classslate_1_1_band_matrix.html" title="General banded, non-symmetric, m-by-n, distributed, tiled matrices." alt="slate::BandMatrix&lt; scalar_t &gt;" shape="rect" coords="0,112,263,136"/>
<area href="classslate_1_1_base_triangular_band_matrix.html" title="Triangular banded, n-by-n, distributed, tiled matrices." alt="slate::BaseTriangularBandMatrix&lt; scalar_t &gt;" shape="rect" coords="273,112,536,136"/>
<area href="classslate_1_1_hermitian_matrix.html" title="Hermitian, n-by-n, distributed, tiled matrices." alt="slate::HermitianMatrix&lt; scalar_t &gt;" shape="rect" coords="546,112,809,136"/>
<area href="classslate_1_1_symmetric_matrix.html" title="Symmetric, n-by-n, distributed, tiled matrices." alt="slate::SymmetricMatrix&lt; scalar_t &gt;" shape="rect" coords="819,112,1082,136"/>
<area href="classslate_1_1_trapezoid_matrix.html" title="Trapezoid, n-by-n, distributed, tiled matrices." alt="slate::TrapezoidMatrix&lt; scalar_t &gt;" shape="rect" coords="1092,112,1355,136"/>
<area href="classslate_1_1_hermitian_band_matrix.html" title="Hermitian banded, n-by-n, distributed, tiled matrices." alt="slate::HermitianBandMatrix&lt; scalar_t &gt;" shape="rect" coords="136,168,399,192"/>
<area href="classslate_1_1_triangular_band_matrix.html" title="Triangular banded, n-by-n, distributed, tiled matrices." alt="slate::TriangularBandMatrix&lt; scalar_t &gt;" shape="rect" coords="409,168,672,192"/>
<area href="classslate_1_1_triangular_matrix.html" title="Triangular, n-by-n, distributed, tiled matrices." alt="slate::TriangularMatrix&lt; scalar_t &gt;" shape="rect" coords="1092,168,1355,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2d8c14af3433f33ed38d6899b0def857"><td class="memItemLeft" align="right" valign="top"><a id="a2d8c14af3433f33ed38d6899b0def857" name="a2d8c14af3433f33ed38d6899b0def857"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BcastList</b> = std::vector&lt; std::tuple&lt; int64_t, int64_t, std::list&lt; <a class="el" href="classslate_1_1_base_matrix.html">BaseMatrix</a>&lt; scalar_t &gt; &gt; &gt; &gt;</td></tr>
<tr class="separator:a2d8c14af3433f33ed38d6899b0def857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d4ca716fc0e86fffd7d0b96191ece5"><td class="memItemLeft" align="right" valign="top"><a id="a88d4ca716fc0e86fffd7d0b96191ece5" name="a88d4ca716fc0e86fffd7d0b96191ece5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BcastListTag</b> = std::vector&lt; std::tuple&lt; int64_t, int64_t, std::list&lt; <a class="el" href="classslate_1_1_base_matrix.html">BaseMatrix</a>&lt; scalar_t &gt; &gt;, int64_t &gt; &gt;</td></tr>
<tr class="separator:a88d4ca716fc0e86fffd7d0b96191ece5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfe7678099172e526eff35296daeae8"><td class="memItemLeft" align="right" valign="top"><a id="afcfe7678099172e526eff35296daeae8" name="afcfe7678099172e526eff35296daeae8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ReduceList</b> = std::vector&lt; std::tuple&lt; int64_t, int64_t, <a class="el" href="classslate_1_1_base_matrix.html">BaseMatrix</a>&lt; scalar_t &gt;, std::list&lt; <a class="el" href="classslate_1_1_base_matrix.html">BaseMatrix</a>&lt; scalar_t &gt; &gt; &gt; &gt;</td></tr>
<tr class="separator:afcfe7678099172e526eff35296daeae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3feb8c93d7f5bdd8f3f75919baf9eb12"><td class="memItemLeft" align="right" valign="top"><a id="a3feb8c93d7f5bdd8f3f75919baf9eb12" name="a3feb8c93d7f5bdd8f3f75919baf9eb12"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ij_tuple</b> = typename <a class="el" href="classslate_1_1_matrix_storage.html">MatrixStorage</a>&lt; scalar_t &gt;::ij_tuple</td></tr>
<tr class="separator:a3feb8c93d7f5bdd8f3f75919baf9eb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38afea38b24b6c1626c0afcec8b00eef"><td class="memItemLeft" align="right" valign="top"><a id="a38afea38b24b6c1626c0afcec8b00eef" name="a38afea38b24b6c1626c0afcec8b00eef"></a>
typedef scalar_t&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a38afea38b24b6c1626c0afcec8b00eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afc36a7c41528288126a264744ca7a406"><td class="memTemplParams" colspan="2"><a id="afc36a7c41528288126a264744ca7a406" name="afc36a7c41528288126a264744ca7a406"></a>
template&lt;typename out_scalar_t &gt; </td></tr>
<tr class="memitem:afc36a7c41528288126a264744ca7a406"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classslate_1_1_base_matrix.html">BaseMatrix</a>&lt; out_scalar_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>baseEmptyLike</b> (int64_t mb, int64_t nb, Op deepOp)</td></tr>
<tr class="memdesc:afc36a7c41528288126a264744ca7a406"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] <br /></td></tr>
<tr class="separator:afc36a7c41528288126a264744ca7a406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22b4342b5ab0970871d49d7d2392e64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#aa22b4342b5ab0970871d49d7d2392e64">operator()</a> (int64_t i, int64_t j, int device=HostNum)</td></tr>
<tr class="memdesc:aa22b4342b5ab0970871d49d7d2392e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get shallow copy of tile {i, j} of op(A) on given device, with the tile's op flag set to match the matrix's.  <br /></td></tr>
<tr class="separator:aa22b4342b5ab0970871d49d7d2392e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86858ae4f6a65915569d783e50d44a7"><td class="memItemLeft" align="right" valign="top"><a id="ad86858ae4f6a65915569d783e50d44a7" name="ad86858ae4f6a65915569d783e50d44a7"></a>
<a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (int64_t i, int64_t j, int device=HostNum)</td></tr>
<tr class="memdesc:ad86858ae4f6a65915569d783e50d44a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of operator(). <br /></td></tr>
<tr class="separator:ad86858ae4f6a65915569d783e50d44a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cbb624048d8843d54fde8b5050c915"><td class="memItemLeft" align="right" valign="top"><a id="a81cbb624048d8843d54fde8b5050c915" name="a81cbb624048d8843d54fde8b5050c915"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>num_devices</b> () const</td></tr>
<tr class="memdesc:a81cbb624048d8843d54fde8b5050c915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of devices (per MPI process) to distribute matrix to. <br /></td></tr>
<tr class="separator:a81cbb624048d8843d54fde8b5050c915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5fa2d7251e7216de3f4ea931e5c958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#aba5fa2d7251e7216de3f4ea931e5c958">gridinfo</a> (<a class="el" href="group__enum.html#gaeaac89d42194c5055ca23d59bb9c4dee">GridOrder</a> *order, int *nprow, int *npcol, int *myrow, int *mycol) const</td></tr>
<tr class="memdesc:aba5fa2d7251e7216de3f4ea931e5c958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nprow, npcol, myrow, mycol for 2D block cyclic (2DBC) distribution.  <br /></td></tr>
<tr class="separator:aba5fa2d7251e7216de3f4ea931e5c958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f358cc929e5e527f033e01f725c1c09"><td class="memItemLeft" align="right" valign="top">std::function&lt; int64_t(int64_t i)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a5f358cc929e5e527f033e01f725c1c09">tileMbFunc</a> () const</td></tr>
<tr class="memdesc:a5f358cc929e5e527f033e01f725c1c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns tileMb function.  <br /></td></tr>
<tr class="separator:a5f358cc929e5e527f033e01f725c1c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d613f3ed706655d6234333e84d21fa1"><td class="memItemLeft" align="right" valign="top">std::function&lt; int64_t(int64_t j)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a9d613f3ed706655d6234333e84d21fa1">tileNbFunc</a> () const</td></tr>
<tr class="memdesc:a9d613f3ed706655d6234333e84d21fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns tileNb function.  <br /></td></tr>
<tr class="separator:a9d613f3ed706655d6234333e84d21fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba23dff11c9ab0ea4ef90bfc635a109"><td class="memItemLeft" align="right" valign="top">std::function&lt; int(ij_tuple ij)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a7ba23dff11c9ab0ea4ef90bfc635a109">tileRankFunc</a> () const</td></tr>
<tr class="memdesc:a7ba23dff11c9ab0ea4ef90bfc635a109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns tileRank function.  <br /></td></tr>
<tr class="separator:a7ba23dff11c9ab0ea4ef90bfc635a109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b6ce07cb3b4efba889ff4e08e28e65"><td class="memItemLeft" align="right" valign="top">std::function&lt; int(ij_tuple ij)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a44b6ce07cb3b4efba889ff4e08e28e65">tileDeviceFunc</a> () const</td></tr>
<tr class="memdesc:a44b6ce07cb3b4efba889ff4e08e28e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns tileDevice function.  <br /></td></tr>
<tr class="separator:a44b6ce07cb3b4efba889ff4e08e28e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ec7abd391d722be9c37d0fd8cd52b4"><td class="memItemLeft" align="right" valign="top"><a id="a92ec7abd391d722be9c37d0fd8cd52b4" name="a92ec7abd391d722be9c37d0fd8cd52b4"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>m</b> () const</td></tr>
<tr class="memdesc:a92ec7abd391d722be9c37d0fd8cd52b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of rows in op(A). <br /></td></tr>
<tr class="separator:a92ec7abd391d722be9c37d0fd8cd52b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f464ed58763b8ed640a46132a37d5b3"><td class="memItemLeft" align="right" valign="top"><a id="a6f464ed58763b8ed640a46132a37d5b3" name="a6f464ed58763b8ed640a46132a37d5b3"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>n</b> () const</td></tr>
<tr class="memdesc:a6f464ed58763b8ed640a46132a37d5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of columns in op(A). <br /></td></tr>
<tr class="separator:a6f464ed58763b8ed640a46132a37d5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24573a0a2165ae126eb71c4f33edcad3"><td class="memItemLeft" align="right" valign="top"><a id="a24573a0a2165ae126eb71c4f33edcad3" name="a24573a0a2165ae126eb71c4f33edcad3"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>mt</b> () const</td></tr>
<tr class="memdesc:a24573a0a2165ae126eb71c4f33edcad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of block rows in op(A). <br /></td></tr>
<tr class="separator:a24573a0a2165ae126eb71c4f33edcad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a04b6a9565a341b75c1de9c075be37"><td class="memItemLeft" align="right" valign="top"><a id="a48a04b6a9565a341b75c1de9c075be37" name="a48a04b6a9565a341b75c1de9c075be37"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>nt</b> () const</td></tr>
<tr class="memdesc:a48a04b6a9565a341b75c1de9c075be37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of block cols in op(A). <br /></td></tr>
<tr class="separator:a48a04b6a9565a341b75c1de9c075be37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9fb6bf0a730a63fed13fef7f6f9dea"><td class="memItemLeft" align="right" valign="top"><a id="a0f9fb6bf0a730a63fed13fef7f6f9dea" name="a0f9fb6bf0a730a63fed13fef7f6f9dea"></a>
Op&#160;</td><td class="memItemRight" valign="bottom"><b>op</b> () const</td></tr>
<tr class="memdesc:a0f9fb6bf0a730a63fed13fef7f6f9dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns transposition operation op(A) as NoTrans, Trans, or ConjTrans. <br /></td></tr>
<tr class="separator:a0f9fb6bf0a730a63fed13fef7f6f9dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb5261358a04dbf81af32c98f08ad84"><td class="memItemLeft" align="right" valign="top"><a id="aefb5261358a04dbf81af32c98f08ad84" name="aefb5261358a04dbf81af32c98f08ad84"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>tileExists</b> (int64_t i, int64_t j, int device=HostNum)</td></tr>
<tr class="memdesc:aefb5261358a04dbf81af32c98f08ad84"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if tile exists on specified device <br /></td></tr>
<tr class="separator:aefb5261358a04dbf81af32c98f08ad84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5aebb8b0c75efdd23f3bbea67cdd9b"><td class="memItemLeft" align="right" valign="top"><a id="adb5aebb8b0c75efdd23f3bbea67cdd9b" name="adb5aebb8b0c75efdd23f3bbea67cdd9b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>tileRank</b> (int64_t i, int64_t j) const</td></tr>
<tr class="memdesc:adb5aebb8b0c75efdd23f3bbea67cdd9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns MPI rank of tile {i, j} of op(A). <br /></td></tr>
<tr class="separator:adb5aebb8b0c75efdd23f3bbea67cdd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6114405527a27de180dcd5cf82b8a19"><td class="memItemLeft" align="right" valign="top"><a id="ad6114405527a27de180dcd5cf82b8a19" name="ad6114405527a27de180dcd5cf82b8a19"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>tileDevice</b> (int64_t i, int64_t j) const</td></tr>
<tr class="memdesc:ad6114405527a27de180dcd5cf82b8a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns device of tile {i, j} of op(A). <br /></td></tr>
<tr class="separator:ad6114405527a27de180dcd5cf82b8a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63ffceab77c36deba4bfab21c130a8c"><td class="memItemLeft" align="right" valign="top"><a id="ad63ffceab77c36deba4bfab21c130a8c" name="ad63ffceab77c36deba4bfab21c130a8c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>tileIsLocal</b> (int64_t i, int64_t j) const</td></tr>
<tr class="memdesc:ad63ffceab77c36deba4bfab21c130a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether tile {i, j} of op(A) is local. <br /></td></tr>
<tr class="separator:ad63ffceab77c36deba4bfab21c130a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc85b5db2dc6a56b7d2207bbb8f762ac"><td class="memItemLeft" align="right" valign="top"><a id="afc85b5db2dc6a56b7d2207bbb8f762ac" name="afc85b5db2dc6a56b7d2207bbb8f762ac"></a>
Uplo&#160;</td><td class="memItemRight" valign="bottom"><b>uplo</b> () const</td></tr>
<tr class="memdesc:afc85b5db2dc6a56b7d2207bbb8f762ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether op(A) is logically Lower, Upper, or General. <br /></td></tr>
<tr class="separator:afc85b5db2dc6a56b7d2207bbb8f762ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47c993e47a396329de5d952f8c983d7"><td class="memItemLeft" align="right" valign="top"><a id="ab47c993e47a396329de5d952f8c983d7" name="ab47c993e47a396329de5d952f8c983d7"></a>
Uplo&#160;</td><td class="memItemRight" valign="bottom"><b>uploLogical</b> () const</td></tr>
<tr class="memdesc:ab47c993e47a396329de5d952f8c983d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether op(A) is logically Lower, Upper, or General storage, taking the transposition operation into account. <br /></td></tr>
<tr class="separator:ab47c993e47a396329de5d952f8c983d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef695d0804b1bd45c9e541d1e2bf26ba"><td class="memItemLeft" align="right" valign="top"><a id="aef695d0804b1bd45c9e541d1e2bf26ba" name="aef695d0804b1bd45c9e541d1e2bf26ba"></a>
Uplo&#160;</td><td class="memItemRight" valign="bottom"><b>uploPhysical</b> () const</td></tr>
<tr class="memdesc:aef695d0804b1bd45c9e541d1e2bf26ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether A is physically Lower, Upper, or General storage, ignoring the transposition operation. <br /></td></tr>
<tr class="separator:aef695d0804b1bd45c9e541d1e2bf26ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0760782b4221ca74b0a4a286e4b2016b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a0760782b4221ca74b0a4a286e4b2016b">originTile</a> (int64_t i, int64_t j)</td></tr>
<tr class="memdesc:a0760782b4221ca74b0a4a286e4b2016b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the origin tile instance of tile(i, j)  <br /></td></tr>
<tr class="separator:a0760782b4221ca74b0a4a286e4b2016b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11a341c9b074364da1a024a33e907ed"><td class="memItemLeft" align="right" valign="top"><a id="aa11a341c9b074364da1a024a33e907ed" name="aa11a341c9b074364da1a024a33e907ed"></a>
<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><b>origin</b> () const</td></tr>
<tr class="memdesc:aa11a341c9b074364da1a024a33e907ed"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a> origin. <br /></td></tr>
<tr class="separator:aa11a341c9b074364da1a024a33e907ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066013a2f281b1cc301b5472f7a0b468"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a066013a2f281b1cc301b5472f7a0b468">tileMb</a> (int64_t i) const</td></tr>
<tr class="memdesc:a066013a2f281b1cc301b5472f7a0b468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of rows (mb) in block row i of op(A).  <br /></td></tr>
<tr class="separator:a066013a2f281b1cc301b5472f7a0b468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1a1741c272f3e89a1d1f3e6691f35d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a7f1a1741c272f3e89a1d1f3e6691f35d">tileNb</a> (int64_t j) const</td></tr>
<tr class="memdesc:a7f1a1741c272f3e89a1d1f3e6691f35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of cols (nb) in block col j of op(A).  <br /></td></tr>
<tr class="separator:a7f1a1741c272f3e89a1d1f3e6691f35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c53893af0d3cb537b78e85125cd25e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a31c53893af0d3cb537b78e85125cd25e">tileInsert</a> (int64_t i, int64_t j, int device=HostNum)</td></tr>
<tr class="memdesc:a31c53893af0d3cb537b78e85125cd25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert tile {i, j} of op(A) and allocate its data.  <br /></td></tr>
<tr class="separator:a31c53893af0d3cb537b78e85125cd25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c573dc6ec466ff3bccb3917d27b92a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a69c573dc6ec466ff3bccb3917d27b92a">tileInsert</a> (int64_t i, int64_t j, int device, scalar_t *A, int64_t ld)</td></tr>
<tr class="memdesc:a69c573dc6ec466ff3bccb3917d27b92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert tile {i, j} of op(A) with existing data.  <br /></td></tr>
<tr class="separator:a69c573dc6ec466ff3bccb3917d27b92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505bd06d71fd58f184ee15d5295eb47c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a505bd06d71fd58f184ee15d5295eb47c">tileInsert</a> (int64_t i, int64_t j, scalar_t *A, int64_t ld)</td></tr>
<tr class="memdesc:a505bd06d71fd58f184ee15d5295eb47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert tile with default device=HostNum.  <br /></td></tr>
<tr class="separator:a505bd06d71fd58f184ee15d5295eb47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5f8d73d1127a1c602db66946668b9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a1b5f8d73d1127a1c602db66946668b9c">tileInsertWorkspace</a> (int64_t i, int64_t j, int device, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:a1b5f8d73d1127a1c602db66946668b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a workspace tile {i, j} of op(A) and allocate its data.  <br /></td></tr>
<tr class="separator:a1b5f8d73d1127a1c602db66946668b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99eaef55b765809a8df5d462ab82a19"><td class="memItemLeft" align="right" valign="top"><a id="aa99eaef55b765809a8df5d462ab82a19" name="aa99eaef55b765809a8df5d462ab82a19"></a>
<a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>tileInsertWorkspace</b> (int64_t i, int64_t j, int device)</td></tr>
<tr class="separator:aa99eaef55b765809a8df5d462ab82a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27aff8781e1c36d62a30a7fa0958f452"><td class="memItemLeft" align="right" valign="top"><a id="a27aff8781e1c36d62a30a7fa0958f452" name="a27aff8781e1c36d62a30a7fa0958f452"></a>
<a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>tileInsertWorkspace</b> (int64_t i, int64_t j, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="separator:a27aff8781e1c36d62a30a7fa0958f452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed152ede370d69ab0b69cbc3b28ee23e"><td class="memItemLeft" align="right" valign="top"><a id="aed152ede370d69ab0b69cbc3b28ee23e" name="aed152ede370d69ab0b69cbc3b28ee23e"></a>
<a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>tileInsertWorkspace</b> (int64_t i, int64_t j)</td></tr>
<tr class="separator:aed152ede370d69ab0b69cbc3b28ee23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a719a6a86959964bb8198cf4f71452"><td class="memItemLeft" align="right" valign="top">scalar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#af5a719a6a86959964bb8198cf4f71452">allocWorkspaceBuffer</a> (int device, int64_t size)</td></tr>
<tr class="memdesc:af5a719a6a86959964bb8198cf4f71452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a workspace buffer using the matrix's memory pool.  <br /></td></tr>
<tr class="separator:af5a719a6a86959964bb8198cf4f71452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaae0356663ba2a557346dcb25edda6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#afaae0356663ba2a557346dcb25edda6e">freeWorkspaceBuffer</a> (int device, scalar_t *buffer)</td></tr>
<tr class="memdesc:afaae0356663ba2a557346dcb25edda6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a workspace buffer allocated with <a class="el" href="classslate_1_1_base_matrix.html#af5a719a6a86959964bb8198cf4f71452" title="Allocates a workspace buffer using the matrix&#39;s memory pool.">BaseMatrix::allocWorkspaceBuffer</a>.  <br /></td></tr>
<tr class="separator:afaae0356663ba2a557346dcb25edda6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb059bd32953340001b400279956d9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082">MOSI</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#adcb059bd32953340001b400279956d9d">tileState</a> (int64_t i, int64_t j, int device=HostNum)</td></tr>
<tr class="memdesc:adcb059bd32953340001b400279956d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns tile(i, j)'s state on device (defaults to host).  <br /></td></tr>
<tr class="separator:adcb059bd32953340001b400279956d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05212fdeb68f7548740207b85f389598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a05212fdeb68f7548740207b85f389598">tileState</a> (int64_t i, int64_t j, int device, <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082">MOSI</a> mosi)</td></tr>
<tr class="memdesc:a05212fdeb68f7548740207b85f389598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets tile(i, j)'s state on device.  <br /></td></tr>
<tr class="separator:a05212fdeb68f7548740207b85f389598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3785a13873ce57db3edef14f9ab917"><td class="memItemLeft" align="right" valign="top"><a id="a5c3785a13873ce57db3edef14f9ab917" name="a5c3785a13873ce57db3edef14f9ab917"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tileState</b> (int64_t i, int64_t j, <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082">MOSI</a> mosi)</td></tr>
<tr class="memdesc:a5c3785a13873ce57db3edef14f9ab917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets tile(i, j)'s state on host. <br /></td></tr>
<tr class="separator:a5c3785a13873ce57db3edef14f9ab917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36a577f0a6bb5b7c4053e83127921e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#af36a577f0a6bb5b7c4053e83127921e4">tileOnHold</a> (int64_t i, int64_t j, int device=HostNum)</td></tr>
<tr class="memdesc:af36a577f0a6bb5b7c4053e83127921e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether tile(i, j) is OnHold on device (defaults to host).  <br /></td></tr>
<tr class="separator:af36a577f0a6bb5b7c4053e83127921e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7761fa8df57612c3a5c08c39e62f510"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#ae7761fa8df57612c3a5c08c39e62f510">tileUnsetHold</a> (int64_t i, int64_t j, int device=HostNum)</td></tr>
<tr class="memdesc:ae7761fa8df57612c3a5c08c39e62f510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the hold of tile(i, j) on device (defaults to host) if it was OnHold.  <br /></td></tr>
<tr class="separator:ae7761fa8df57612c3a5c08c39e62f510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9978416be77ada7c0a2576bae568838"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#ad9978416be77ada7c0a2576bae568838">tileUnsetHoldAll</a> (int device=HostNum)</td></tr>
<tr class="memdesc:ad9978416be77ada7c0a2576bae568838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets all local tiles' hold on device.  <br /></td></tr>
<tr class="separator:ad9978416be77ada7c0a2576bae568838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dcbe8e9d08eeb144491d1f1851a44a"><td class="memItemLeft" align="right" valign="top"><a id="ac1dcbe8e9d08eeb144491d1f1851a44a" name="ac1dcbe8e9d08eeb144491d1f1851a44a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tileUnsetHoldAllOnDevices</b> ()</td></tr>
<tr class="memdesc:ac1dcbe8e9d08eeb144491d1f1851a44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets all local tiles' hold on all devices. <br /></td></tr>
<tr class="separator:ac1dcbe8e9d08eeb144491d1f1851a44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05219997eb4aae0de1e7697d30cde712"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a05219997eb4aae0de1e7697d30cde712">tileModified</a> (int64_t i, int64_t j, int device=HostNum, bool permissive=false)</td></tr>
<tr class="memdesc:a05219997eb4aae0de1e7697d30cde712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks tile(i, j) as Modified on device.  <br /></td></tr>
<tr class="separator:a05219997eb4aae0de1e7697d30cde712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc03c645e5d2be01784fd10a36cd3a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#afbc03c645e5d2be01784fd10a36cd3a9">tileAcquire</a> (int64_t i, int64_t j, int device, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:afbc03c645e5d2be01784fd10a36cd3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire tile(i, j) on device without copying data if not already exists.  <br /></td></tr>
<tr class="separator:afbc03c645e5d2be01784fd10a36cd3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb72156a5de894971ce54c98c701aa3"><td class="memItemLeft" align="right" valign="top"><a id="a2cb72156a5de894971ce54c98c701aa3" name="a2cb72156a5de894971ce54c98c701aa3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tileAcquire</b> (int64_t i, int64_t j, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="separator:a2cb72156a5de894971ce54c98c701aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca68e8a280321ed5d472a2d08df04fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a6ca68e8a280321ed5d472a2d08df04fc">tileGetForReading</a> (int64_t i, int64_t j, int device, <a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:a6ca68e8a280321ed5d472a2d08df04fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets tile(i, j) for reading on device.  <br /></td></tr>
<tr class="separator:a6ca68e8a280321ed5d472a2d08df04fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae895295a7cda60e541088c5d0c444d26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#ae895295a7cda60e541088c5d0c444d26">tileGetForReading</a> (std::set&lt; ij_tuple &gt; &amp;tile_set, int device, <a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:ae895295a7cda60e541088c5d0c444d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a set of tiles for reading on device.  <br /></td></tr>
<tr class="separator:ae895295a7cda60e541088c5d0c444d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e10a515c998f1ab5487220f3f2f491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a52e10a515c998f1ab5487220f3f2f491">tileGetForReading</a> (int64_t i, int64_t j, <a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:a52e10a515c998f1ab5487220f3f2f491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets tile(i, j) for reading on host.  <br /></td></tr>
<tr class="separator:a52e10a515c998f1ab5487220f3f2f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9146c688a4b7897e09d517d126a28d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#ae9146c688a4b7897e09d517d126a28d9">tileGetForReading</a> (std::set&lt; ij_tuple &gt; &amp;tile_set, <a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:ae9146c688a4b7897e09d517d126a28d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a set of tiles for reading on host.  <br /></td></tr>
<tr class="separator:ae9146c688a4b7897e09d517d126a28d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92b260ccc7af7166b0237fa8b9ae77f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#ae92b260ccc7af7166b0237fa8b9ae77f">tileGetForReading</a> (std::set&lt; ij_tuple &gt; &amp;tile_set, <a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>, int from_device)</td></tr>
<tr class="memdesc:ae92b260ccc7af7166b0237fa8b9ae77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a set of tiles for reading on host from a specific device.  <br /></td></tr>
<tr class="separator:ae92b260ccc7af7166b0237fa8b9ae77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fb93003ea1a28b02b39694dee88ac0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#af7fb93003ea1a28b02b39694dee88ac0">tileGetAllForReading</a> (int device, <a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:af7fb93003ea1a28b02b39694dee88ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all local tiles for reading on device.  <br /></td></tr>
<tr class="separator:af7fb93003ea1a28b02b39694dee88ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8923f0054bbd38fa275eceedeec0fa56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a8923f0054bbd38fa275eceedeec0fa56">tileGetAllForReadingOnDevices</a> (<a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:a8923f0054bbd38fa275eceedeec0fa56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all local tiles for reading on corresponding devices.  <br /></td></tr>
<tr class="separator:a8923f0054bbd38fa275eceedeec0fa56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae513ef48ca11afd69289f9328f2ca00c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#ae513ef48ca11afd69289f9328f2ca00c">tileGetForWriting</a> (int64_t i, int64_t j, int device, <a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:ae513ef48ca11afd69289f9328f2ca00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets tile(i, j) for writing on device.  <br /></td></tr>
<tr class="separator:ae513ef48ca11afd69289f9328f2ca00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa543f9875a1cda6f3d24c120054850cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#aa543f9875a1cda6f3d24c120054850cd">tileGetForWriting</a> (std::set&lt; ij_tuple &gt; &amp;tile_set, int device, <a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:aa543f9875a1cda6f3d24c120054850cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a set of tiles for writing on device.  <br /></td></tr>
<tr class="separator:aa543f9875a1cda6f3d24c120054850cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687d53fdd1179f8ff9d5b3d9c6350553"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a687d53fdd1179f8ff9d5b3d9c6350553">tileGetForWriting</a> (int64_t i, int64_t j, <a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:a687d53fdd1179f8ff9d5b3d9c6350553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets tile(i, j) for writing on host.  <br /></td></tr>
<tr class="separator:a687d53fdd1179f8ff9d5b3d9c6350553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b5ab7e19bb1560a115799e884129da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a56b5ab7e19bb1560a115799e884129da">tileGetForWriting</a> (std::set&lt; ij_tuple &gt; &amp;tile_set, <a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:a56b5ab7e19bb1560a115799e884129da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a set of tiles for writing on host.  <br /></td></tr>
<tr class="separator:a56b5ab7e19bb1560a115799e884129da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50a8aa6fe3788187ad99d60c075feb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#af50a8aa6fe3788187ad99d60c075feb8">tileGetAllForWriting</a> (int device, <a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:af50a8aa6fe3788187ad99d60c075feb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all local tiles for writing on device.  <br /></td></tr>
<tr class="separator:af50a8aa6fe3788187ad99d60c075feb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc5cb671c2366e9bb0a84863c06df57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a6dc5cb671c2366e9bb0a84863c06df57">tileGetAllForWritingOnDevices</a> (<a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:a6dc5cb671c2366e9bb0a84863c06df57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all local tiles for writing on corresponding devices.  <br /></td></tr>
<tr class="separator:a6dc5cb671c2366e9bb0a84863c06df57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e48c08c22d0a29d866c86c2bbbbff8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#ac8e48c08c22d0a29d866c86c2bbbbff8">tileGetAndHold</a> (int64_t i, int64_t j, int device, <a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:ac8e48c08c22d0a29d866c86c2bbbbff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets tile(i, j) on device for reading and marks it as <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082a20258d782bac93be37b78fe807b4aa1d" title="a hold is placed on this tile instance, cannot be purged">MOSI::OnHold</a>.  <br /></td></tr>
<tr class="separator:ac8e48c08c22d0a29d866c86c2bbbbff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184b49ca45a346ffb2c4eb5aa6af55e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a184b49ca45a346ffb2c4eb5aa6af55e5">tileGetAndHold</a> (int64_t i, int64_t j, <a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:a184b49ca45a346ffb2c4eb5aa6af55e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets tile(i, j) on host for reading and marks it as <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082a20258d782bac93be37b78fe807b4aa1d" title="a hold is placed on this tile instance, cannot be purged">MOSI::OnHold</a>.  <br /></td></tr>
<tr class="separator:a184b49ca45a346ffb2c4eb5aa6af55e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac932dab839b071f15ff52d3b1bc4d0cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#ac932dab839b071f15ff52d3b1bc4d0cd">tileGetAndHold</a> (std::set&lt; ij_tuple &gt; &amp;tile_set, int device, <a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:ac932dab839b071f15ff52d3b1bc4d0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a set of tiles for reading on device and marks them as <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082a20258d782bac93be37b78fe807b4aa1d" title="a hold is placed on this tile instance, cannot be purged">MOSI::OnHold</a>.  <br /></td></tr>
<tr class="separator:ac932dab839b071f15ff52d3b1bc4d0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14222e26f0ed9936a199ef15b5076dc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a14222e26f0ed9936a199ef15b5076dc7">tileGetAndHold</a> (std::set&lt; ij_tuple &gt; &amp;tile_set, <a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:a14222e26f0ed9936a199ef15b5076dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a set of tiles for reading on host and marks them as <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082a20258d782bac93be37b78fe807b4aa1d" title="a hold is placed on this tile instance, cannot be purged">MOSI::OnHold</a>.  <br /></td></tr>
<tr class="separator:a14222e26f0ed9936a199ef15b5076dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446b1f5c09fb5a3a8f98f063b2df805c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a446b1f5c09fb5a3a8f98f063b2df805c">tileGetAndHoldAll</a> (int device, <a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:a446b1f5c09fb5a3a8f98f063b2df805c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all local tiles on device and marks them as <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082a20258d782bac93be37b78fe807b4aa1d" title="a hold is placed on this tile instance, cannot be purged">MOSI::OnHold</a>.  <br /></td></tr>
<tr class="separator:a446b1f5c09fb5a3a8f98f063b2df805c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ca07e10465c729ef629c7299569feb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a30ca07e10465c729ef629c7299569feb">tileGetAndHoldAllOnDevices</a> (<a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a> <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:a30ca07e10465c729ef629c7299569feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all local tiles on corresponding devices and marks them as <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082a20258d782bac93be37b78fe807b4aa1d" title="a hold is placed on this tile instance, cannot be purged">MOSI::OnHold</a>.  <br /></td></tr>
<tr class="separator:a30ca07e10465c729ef629c7299569feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0649df9666eb89f813440347aad13be7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a0649df9666eb89f813440347aad13be7">tileUpdateOrigin</a> (int64_t i, int64_t j)</td></tr>
<tr class="memdesc:a0649df9666eb89f813440347aad13be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the origin instance of tile(i, j) if <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082ade601238c67d62b1890cd32616018e3f" title="tile data is obsolete, other instances may be Modified, Shared, or Invalid, may be purged">MOSI::Invalid</a> tile must be local.  <br /></td></tr>
<tr class="separator:a0649df9666eb89f813440347aad13be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ef8cdf327939fdc284b1bdf3f4c8cb"><td class="memItemLeft" align="right" valign="top"><a id="ab4ef8cdf327939fdc284b1bdf3f4c8cb" name="ab4ef8cdf327939fdc284b1bdf3f4c8cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tileUpdateAllOrigin</b> ()</td></tr>
<tr class="memdesc:ab4ef8cdf327939fdc284b1bdf3f4c8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates all origin instances of local tiles if <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082ade601238c67d62b1890cd32616018e3f" title="tile data is obsolete, other instances may be Modified, Shared, or Invalid, may be purged">MOSI::Invalid</a>. <br /></td></tr>
<tr class="separator:ab4ef8cdf327939fdc284b1bdf3f4c8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb923263d0a76b7d4bc83e568ebf2330"><td class="memItemLeft" align="right" valign="top"><a id="adb923263d0a76b7d4bc83e568ebf2330" name="adb923263d0a76b7d4bc83e568ebf2330"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>tileLife</b> (int64_t i, int64_t j) const</td></tr>
<tr class="memdesc:adb923263d0a76b7d4bc83e568ebf2330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns life counter of tile {i, j} of op(A). <br /></td></tr>
<tr class="separator:adb923263d0a76b7d4bc83e568ebf2330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451a0d84120dd1f9745e2251f4c51bf9"><td class="memItemLeft" align="right" valign="top"><a id="a451a0d84120dd1f9745e2251f4c51bf9" name="a451a0d84120dd1f9745e2251f4c51bf9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tileLife</b> (int64_t i, int64_t j, int64_t life)</td></tr>
<tr class="memdesc:a451a0d84120dd1f9745e2251f4c51bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set life counter of tile {i, j} of op(A). <br /></td></tr>
<tr class="separator:a451a0d84120dd1f9745e2251f4c51bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682995e23692709ce243a987babb172d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a682995e23692709ce243a987babb172d">tileTick</a> (int64_t i, int64_t j)</td></tr>
<tr class="memdesc:a682995e23692709ce243a987babb172d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements life counter of workspace tile {i, j} of op(A).  <br /></td></tr>
<tr class="separator:a682995e23692709ce243a987babb172d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a364ce568ff323df4a79644ce89b852"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a9a364ce568ff323df4a79644ce89b852">tileReceiveCount</a> (int64_t i, int64_t j) const</td></tr>
<tr class="memdesc:a9a364ce568ff323df4a79644ce89b852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many times the tile {i, j} is received through MPI.  <br /></td></tr>
<tr class="separator:a9a364ce568ff323df4a79644ce89b852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab751b0600d35c86e5dc239515037c936"><td class="memItemLeft" align="right" valign="top"><a id="ab751b0600d35c86e5dc239515037c936" name="ab751b0600d35c86e5dc239515037c936"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tileIncrementReceiveCount</b> (int64_t i, int64_t j)</td></tr>
<tr class="memdesc:ab751b0600d35c86e5dc239515037c936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the number of times the tile {i, j} is received through MPI. <br /></td></tr>
<tr class="separator:ab751b0600d35c86e5dc239515037c936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4346f77034a3192b15ef664f18ea7e9"><td class="memItemLeft" align="right" valign="top"><a id="af4346f77034a3192b15ef664f18ea7e9" name="af4346f77034a3192b15ef664f18ea7e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tileDecrementReceiveCount</b> (int64_t i, int64_t j)</td></tr>
<tr class="memdesc:af4346f77034a3192b15ef664f18ea7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the number of times the tile {i, j} is received through MPI. <br /></td></tr>
<tr class="separator:af4346f77034a3192b15ef664f18ea7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e29d10f356ac39c84d048c37f49192c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a2e29d10f356ac39c84d048c37f49192c">tileErase</a> (int64_t i, int64_t j, int device=HostNum)</td></tr>
<tr class="memdesc:a2e29d10f356ac39c84d048c37f49192c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase tile {i, j} of op(A) on device (host, one device or all devices).  <br /></td></tr>
<tr class="separator:a2e29d10f356ac39c84d048c37f49192c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadca36fe7517359afa9c1c534f5a24ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#aadca36fe7517359afa9c1c534f5a24ee">tileRelease</a> (int64_t i, int64_t j, int device=HostNum)</td></tr>
<tr class="memdesc:aadca36fe7517359afa9c1c534f5a24ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the tile {i, j}'s instance on device if it is a workspace tile that is not modified and no hold is set on it.  <br /></td></tr>
<tr class="separator:aadca36fe7517359afa9c1c534f5a24ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d82299f56915257fa8f16e77a0f9fc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target = Target::Host&gt; </td></tr>
<tr class="memitem:a51d82299f56915257fa8f16e77a0f9fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a51d82299f56915257fa8f16e77a0f9fc">tileSend</a> (int64_t i, int64_t j, int dst_rank, int tag=0)</td></tr>
<tr class="memdesc:a51d82299f56915257fa8f16e77a0f9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send tile {i, j} of op(A) to the given MPI rank.  <br /></td></tr>
<tr class="separator:a51d82299f56915257fa8f16e77a0f9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77ee84b16b1b2e4c8b5ac8e5c9f14f7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target = Target::Host&gt; </td></tr>
<tr class="memitem:ab77ee84b16b1b2e4c8b5ac8e5c9f14f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#ab77ee84b16b1b2e4c8b5ac8e5c9f14f7">tileRecv</a> (int64_t i, int64_t j, int dst_rank, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>, int tag=0)</td></tr>
<tr class="memdesc:ab77ee84b16b1b2e4c8b5ac8e5c9f14f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive tile {i, j} of op(A) to the given MPI rank.  <br /></td></tr>
<tr class="separator:ab77ee84b16b1b2e4c8b5ac8e5c9f14f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2bdefd118b5649d6f9585a98e0af00"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target = Target::Host&gt; </td></tr>
<tr class="memitem:a8f2bdefd118b5649d6f9585a98e0af00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a8f2bdefd118b5649d6f9585a98e0af00">tileBcast</a> (int64_t i, int64_t j, <a class="el" href="classslate_1_1_base_matrix.html">BaseMatrix</a> const &amp;B, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>, int tag=0, int64_t life_factor=1)</td></tr>
<tr class="memdesc:a8f2bdefd118b5649d6f9585a98e0af00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send tile {i, j} of op(A) to all MPI ranks in matrix B.  <br /></td></tr>
<tr class="separator:a8f2bdefd118b5649d6f9585a98e0af00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4ef408193cac8b5bd8633f8a519052"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target = Target::Host&gt; </td></tr>
<tr class="memitem:a7f4ef408193cac8b5bd8633f8a519052"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a7f4ef408193cac8b5bd8633f8a519052">listBcast</a> (BcastList &amp;bcast_list, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>, int tag=0, int64_t life_factor=1, bool is_shared=false)</td></tr>
<tr class="memdesc:a7f4ef408193cac8b5bd8633f8a519052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send tile {i, j} of op(A) to all MPI ranks in the list of submatrices bcast_list.  <br /></td></tr>
<tr class="separator:a7f4ef408193cac8b5bd8633f8a519052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7389a85ce34c5675b794dee569d03d63"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target = Target::Host&gt; </td></tr>
<tr class="memitem:a7389a85ce34c5675b794dee569d03d63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a7389a85ce34c5675b794dee569d03d63">listBcastMT</a> (BcastListTag &amp;bcast_list, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>, int64_t life_factor=1, bool is_shared=false)</td></tr>
<tr class="memdesc:a7389a85ce34c5675b794dee569d03d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send tile {i, j} of op(A) to all MPI ranks in the list of submatrices bcast_list (using OpenMP tasksloop and multi-threaded MPI).  <br /></td></tr>
<tr class="separator:a7389a85ce34c5675b794dee569d03d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a9537f88f766cdaff27f5e47287dd8"><td class="memTemplParams" colspan="2"><a id="a12a9537f88f766cdaff27f5e47287dd8" name="a12a9537f88f766cdaff27f5e47287dd8"></a>
template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target = Target::Host&gt; </td></tr>
<tr class="memitem:a12a9537f88f766cdaff27f5e47287dd8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>listReduce</b> (ReduceList &amp;reduce_list, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>, int tag=0)</td></tr>
<tr class="separator:a12a9537f88f766cdaff27f5e47287dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07b5530001b56d21fbc66824fa9e9f5"><td class="memItemLeft" align="right" valign="top"><a id="ac07b5530001b56d21fbc66824fa9e9f5" name="ac07b5530001b56d21fbc66824fa9e9f5"></a>
Layout&#160;</td><td class="memItemRight" valign="bottom"><b>layout</b> () const</td></tr>
<tr class="memdesc:ac07b5530001b56d21fbc66824fa9e9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns matrix layout flag. <br /></td></tr>
<tr class="separator:ac07b5530001b56d21fbc66824fa9e9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af281850449421a04e6778f1761b2ab96"><td class="memItemLeft" align="right" valign="top"><a id="af281850449421a04e6778f1761b2ab96" name="af281850449421a04e6778f1761b2ab96"></a>
Layout&#160;</td><td class="memItemRight" valign="bottom"><b>tileLayout</b> (int64_t i, int64_t j, int device=HostNum)</td></tr>
<tr class="memdesc:af281850449421a04e6778f1761b2ab96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Layout of tile(i, j, device) <br /></td></tr>
<tr class="separator:af281850449421a04e6778f1761b2ab96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803a070a576c61715851951a6e643928"><td class="memItemLeft" align="right" valign="top"><a id="a803a070a576c61715851951a6e643928" name="a803a070a576c61715851951a6e643928"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tileLayout</b> (int64_t i, int64_t j, int device, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:a803a070a576c61715851951a6e643928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Layout of tile(i, j, device) <br /></td></tr>
<tr class="separator:a803a070a576c61715851951a6e643928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbcd24d405ccf9ee4d55a63b3ec7ed3"><td class="memItemLeft" align="right" valign="top"><a id="adcbcd24d405ccf9ee4d55a63b3ec7ed3" name="adcbcd24d405ccf9ee4d55a63b3ec7ed3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tileLayout</b> (int64_t i, int64_t j, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:adcbcd24d405ccf9ee4d55a63b3ec7ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Layout of tile(i, j, host) <br /></td></tr>
<tr class="separator:adcbcd24d405ccf9ee4d55a63b3ec7ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd94a32330dcd78ac3542d9997dc802"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a8bd94a32330dcd78ac3542d9997dc802">tileLayoutIsConvertible</a> (int64_t i, int64_t j, int device=HostNum)</td></tr>
<tr class="memdesc:a8bd94a32330dcd78ac3542d9997dc802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether tile(i, j, device) can be safely transposed.  <br /></td></tr>
<tr class="separator:a8bd94a32330dcd78ac3542d9997dc802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e6ea31cd523d79eb349e60a1d0b1c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#aa0e6ea31cd523d79eb349e60a1d0b1c4">tileLayoutConvert</a> (int64_t i, int64_t j, int device, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>, bool reset=false, bool async=false)</td></tr>
<tr class="memdesc:aa0e6ea31cd523d79eb349e60a1d0b1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts tile(i, j, device) into 'layout'.  <br /></td></tr>
<tr class="separator:aa0e6ea31cd523d79eb349e60a1d0b1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32020eb3015b7bfa8bc9c5a3b05cc6a"><td class="memItemLeft" align="right" valign="top"><a id="ac32020eb3015b7bfa8bc9c5a3b05cc6a" name="ac32020eb3015b7bfa8bc9c5a3b05cc6a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tileLayoutConvert</b> (int64_t i, int64_t j, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>, bool reset=false, bool async=false)</td></tr>
<tr class="memdesc:ac32020eb3015b7bfa8bc9c5a3b05cc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert layout of tile(i, j) to layout on host, optionally reset. <br /></td></tr>
<tr class="separator:ac32020eb3015b7bfa8bc9c5a3b05cc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e742f106d1dbc715f4486ce0e5464b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a2e742f106d1dbc715f4486ce0e5464b2">tileLayoutConvert</a> (std::set&lt; ij_tuple &gt; &amp;tile_set, int device, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>, bool reset=false)</td></tr>
<tr class="memdesc:a2e742f106d1dbc715f4486ce0e5464b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts tiles indicated in 'tile_set' that exist on 'device' into 'layout' if not already in 'layout' major.  <br /></td></tr>
<tr class="separator:a2e742f106d1dbc715f4486ce0e5464b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f4f252b1a2a731511ada2420a87c92"><td class="memItemLeft" align="right" valign="top"><a id="a08f4f252b1a2a731511ada2420a87c92" name="a08f4f252b1a2a731511ada2420a87c92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tileLayoutConvert</b> (std::set&lt; ij_tuple &gt; &amp;tile_set, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>, bool reset=false)</td></tr>
<tr class="memdesc:a08f4f252b1a2a731511ada2420a87c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert layout of a set of tiles to layout on host, optionally reset. <br /></td></tr>
<tr class="separator:a08f4f252b1a2a731511ada2420a87c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd8162aa2a1e7bcf119f27aa1b07be2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a4fd8162aa2a1e7bcf119f27aa1b07be2">tileLayoutConvert</a> (int device, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>, bool reset=false)</td></tr>
<tr class="memdesc:a4fd8162aa2a1e7bcf119f27aa1b07be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts all existing tile instances on 'device' into 'layout' Operates in batch mode.  <br /></td></tr>
<tr class="separator:a4fd8162aa2a1e7bcf119f27aa1b07be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c2540386635f7af9a615cdd0e5875c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#ab1c2540386635f7af9a615cdd0e5875c">tileLayoutConvertOnDevices</a> (Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>, bool reset=false)</td></tr>
<tr class="memdesc:ab1c2540386635f7af9a615cdd0e5875c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts all existing tile instances on available devices into 'layout'.  <br /></td></tr>
<tr class="separator:ab1c2540386635f7af9a615cdd0e5875c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bf3d4bc49e2da615760ce7ad9dc169"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a65bf3d4bc49e2da615760ce7ad9dc169">tileLayoutReset</a> (int64_t i, int64_t j, int device, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:a65bf3d4bc49e2da615760ce7ad9dc169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts tile(i, j) into current layout and resets its extended buffer.  <br /></td></tr>
<tr class="separator:a65bf3d4bc49e2da615760ce7ad9dc169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09902c09ab6d539aac9dc133b695d44"><td class="memItemLeft" align="right" valign="top"><a id="ac09902c09ab6d539aac9dc133b695d44" name="ac09902c09ab6d539aac9dc133b695d44"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tileLayoutReset</b> (int64_t i, int64_t j, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="separator:ac09902c09ab6d539aac9dc133b695d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87fd153af7f4c3e1cfe218454ba19e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#ae87fd153af7f4c3e1cfe218454ba19e3">tileLayoutReset</a> (std::set&lt; ij_tuple &gt; &amp;tile_set, int device, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:ae87fd153af7f4c3e1cfe218454ba19e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts set of tiles into current layout and resets their extended buffers.  <br /></td></tr>
<tr class="separator:ae87fd153af7f4c3e1cfe218454ba19e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7b2fc811970a4a82c08c1bd4e00480"><td class="memItemLeft" align="right" valign="top"><a id="add7b2fc811970a4a82c08c1bd4e00480" name="add7b2fc811970a4a82c08c1bd4e00480"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tileLayoutReset</b> (std::set&lt; ij_tuple &gt; &amp;tile_set, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="separator:add7b2fc811970a4a82c08c1bd4e00480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b6f930f52ce72d421ebc019decf135"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a88b6f930f52ce72d421ebc019decf135">tileLayoutReset</a> ()</td></tr>
<tr class="memdesc:a88b6f930f52ce72d421ebc019decf135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts all origin tiles into current matrix-layout.  <br /></td></tr>
<tr class="separator:a88b6f930f52ce72d421ebc019decf135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d07481e4d175541e6a43d1e1384f083"><td class="memItemLeft" align="right" valign="top"><a id="a2d07481e4d175541e6a43d1e1384f083" name="a2d07481e4d175541e6a43d1e1384f083"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tileReduceFromSet</b> (int64_t i, int64_t j, int root_rank, std::set&lt; int &gt; &amp;reduce_set, int radix, int tag, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>)</td></tr>
<tr class="memdesc:a2d07481e4d175541e6a43d1e1384f083"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] WARNING: Sent and Recevied tiles are converted to 'layout' major. <br /></td></tr>
<tr class="separator:a2d07481e4d175541e6a43d1e1384f083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960ca0bee46df8dfc563efbbbe21aad8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a960ca0bee46df8dfc563efbbbe21aad8">getRanks</a> (std::set&lt; int &gt; *bcast_set) const</td></tr>
<tr class="memdesc:a960ca0bee46df8dfc563efbbbe21aad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts all MPI ranks that have tiles in the matrix into the set.  <br /></td></tr>
<tr class="separator:a960ca0bee46df8dfc563efbbbe21aad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30581c7a93c522c84a5217d6085669b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#af30581c7a93c522c84a5217d6085669b">getLocalDevices</a> (std::set&lt; int &gt; *dev_set) const</td></tr>
<tr class="memdesc:af30581c7a93c522c84a5217d6085669b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts all devices that have local tiles in the matrix into the set.  <br /></td></tr>
<tr class="separator:af30581c7a93c522c84a5217d6085669b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c12448b4b436e2de67d1f8af50a154f"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a3c12448b4b436e2de67d1f8af50a154f">numLocalTiles</a> () const</td></tr>
<tr class="memdesc:a3c12448b4b436e2de67d1f8af50a154f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of local tiles in this matrix.  <br /></td></tr>
<tr class="separator:a3c12448b4b436e2de67d1f8af50a154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cfe539b2c94f3e8685b43c5c51953d"><td class="memItemLeft" align="right" valign="top"><a id="a61cfe539b2c94f3e8685b43c5c51953d" name="a61cfe539b2c94f3e8685b43c5c51953d"></a>
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><b>mpiComm</b> () const</td></tr>
<tr class="separator:a61cfe539b2c94f3e8685b43c5c51953d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad302938eea76df3d89613a0e6357fe42"><td class="memItemLeft" align="right" valign="top"><a id="ad302938eea76df3d89613a0e6357fe42" name="ad302938eea76df3d89613a0e6357fe42"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mpiRank</b> () const</td></tr>
<tr class="separator:ad302938eea76df3d89613a0e6357fe42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775fa9365955b05df5828e5f33dd6114"><td class="memItemLeft" align="right" valign="top"><a id="a775fa9365955b05df5828e5f33dd6114" name="a775fa9365955b05df5828e5f33dd6114"></a>
MPI_Group&#160;</td><td class="memItemRight" valign="bottom"><b>mpiGroup</b> () const</td></tr>
<tr class="separator:a775fa9365955b05df5828e5f33dd6114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e29a4044be9dfc9e923bd34af9152b"><td class="memItemLeft" align="right" valign="top"><a id="ae2e29a4044be9dfc9e923bd34af9152b" name="ae2e29a4044be9dfc9e923bd34af9152b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>hostNum</b> () const</td></tr>
<tr class="separator:ae2e29a4044be9dfc9e923bd34af9152b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6865d27cb1116bbda45effcc18a5ab3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#ab6865d27cb1116bbda45effcc18a5ab3">clear</a> ()</td></tr>
<tr class="memdesc:ab6865d27cb1116bbda45effcc18a5ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all tiles from matrix.  <br /></td></tr>
<tr class="separator:ab6865d27cb1116bbda45effcc18a5ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923bea803ea11a6c1eb61d0f1a34d9af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a923bea803ea11a6c1eb61d0f1a34d9af">releaseWorkspace</a> ()</td></tr>
<tr class="memdesc:a923bea803ea11a6c1eb61d0f1a34d9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all workspace tiles that are not on hold or modified.  <br /></td></tr>
<tr class="separator:a923bea803ea11a6c1eb61d0f1a34d9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd01ad08aaf80aa63f7aecf7398dbd92"><td class="memItemLeft" align="right" valign="top"><a id="abd01ad08aaf80aa63f7aecf7398dbd92" name="abd01ad08aaf80aa63f7aecf7398dbd92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>releaseLocalWorkspaceTile</b> (int64_t i, int64_t j)</td></tr>
<tr class="memdesc:abd01ad08aaf80aa63f7aecf7398dbd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases a given local workspace tile, if not on hold or modified. <br /></td></tr>
<tr class="separator:abd01ad08aaf80aa63f7aecf7398dbd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ece95658629db6d7d4727c17f21faa"><td class="memItemLeft" align="right" valign="top"><a id="a32ece95658629db6d7d4727c17f21faa" name="a32ece95658629db6d7d4727c17f21faa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>releaseLocalWorkspace</b> ()</td></tr>
<tr class="memdesc:a32ece95658629db6d7d4727c17f21faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all local workspace tiles, if not on hold or modified. <br /></td></tr>
<tr class="separator:a32ece95658629db6d7d4727c17f21faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b411fce1b2c48a0e3ea0e0f351ce5d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a4b411fce1b2c48a0e3ea0e0f351ce5d0">releaseLocalWorkspace</a> (std::set&lt; ij_tuple &gt; &amp;tile_set)</td></tr>
<tr class="memdesc:a4b411fce1b2c48a0e3ea0e0f351ce5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases a given set of local workspace tiles from all devices including host, if not on hold or modified.  <br /></td></tr>
<tr class="separator:a4b411fce1b2c48a0e3ea0e0f351ce5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6feea89692d711519e8a2d342651f946"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a6feea89692d711519e8a2d342651f946">releaseRemoteWorkspaceTile</a> (int64_t i, int64_t j)</td></tr>
<tr class="memdesc:a6feea89692d711519e8a2d342651f946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases a given tile that is not local to node from all devices including host, if not on hold or modified.  <br /></td></tr>
<tr class="separator:a6feea89692d711519e8a2d342651f946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094df29653a4a0e9c0f1fd8446750f06"><td class="memItemLeft" align="right" valign="top"><a id="a094df29653a4a0e9c0f1fd8446750f06" name="a094df29653a4a0e9c0f1fd8446750f06"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>releaseRemoteWorkspace</b> ()</td></tr>
<tr class="memdesc:a094df29653a4a0e9c0f1fd8446750f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases tiles that are not local to node from all devices including host, if not on hold or modified. <br /></td></tr>
<tr class="separator:a094df29653a4a0e9c0f1fd8446750f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab448cbd84c11a7118d2885ae1ee69bf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#ab448cbd84c11a7118d2885ae1ee69bf3">releaseRemoteWorkspace</a> (std::set&lt; ij_tuple &gt; &amp;tile_set)</td></tr>
<tr class="memdesc:ab448cbd84c11a7118d2885ae1ee69bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases a given set of tiles that are not local to node from all devices including host, if not on hold or modified.  <br /></td></tr>
<tr class="separator:ab448cbd84c11a7118d2885ae1ee69bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea931e74caaeece38306b39d99be855"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#aaea931e74caaeece38306b39d99be855">clearWorkspace</a> ()</td></tr>
<tr class="memdesc:aaea931e74caaeece38306b39d99be855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all temporary host and device workspace tiles from matrix.  <br /></td></tr>
<tr class="separator:aaea931e74caaeece38306b39d99be855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcaf44311decdbee6eaf8bb331ead7b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#afcaf44311decdbee6eaf8bb331ead7b5">allocateBatchArrays</a> (int64_t batch_size, int64_t num_arrays)</td></tr>
<tr class="memdesc:afcaf44311decdbee6eaf8bb331ead7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates batch arrays and BLAS++ queues for all devices.  <br /></td></tr>
<tr class="separator:afcaf44311decdbee6eaf8bb331ead7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96382eae6e0b92b244f9f52f47c8a126"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a96382eae6e0b92b244f9f52f47c8a126">clearBatchArrays</a> ()</td></tr>
<tr class="memdesc:a96382eae6e0b92b244f9f52f47c8a126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes batch arrays from matrix for all devices.  <br /></td></tr>
<tr class="separator:a96382eae6e0b92b244f9f52f47c8a126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9994f56aa0ea29352c7580b88868e70a"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a9994f56aa0ea29352c7580b88868e70a">batchArraySize</a> ()</td></tr>
<tr class="separator:a9994f56aa0ea29352c7580b88868e70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71605d21463b093ab433fd5afcda4a4b"><td class="memItemLeft" align="right" valign="top">scalar_t **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a71605d21463b093ab433fd5afcda4a4b">array_host</a> (int device, int64_t batch_arrays_index=0)</td></tr>
<tr class="separator:a71605d21463b093ab433fd5afcda4a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e02c3db580ab809a44bca9de86e8d7"><td class="memItemLeft" align="right" valign="top">scalar_t **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a07e02c3db580ab809a44bca9de86e8d7">array_device</a> (int device, int64_t batch_arrays_index=0)</td></tr>
<tr class="separator:a07e02c3db580ab809a44bca9de86e8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa2219e2d23735b7908edac52419d85"><td class="memItemLeft" align="right" valign="top">lapack::Queue *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a2aa2219e2d23735b7908edac52419d85">comm_queue</a> (int device)</td></tr>
<tr class="separator:a2aa2219e2d23735b7908edac52419d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc7acb5301ecb41e5084b173179cbcf"><td class="memItemLeft" align="right" valign="top">lapack::Queue *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#abdc7acb5301ecb41e5084b173179cbcf">compute_queue</a> (int device, int queue_index=0)</td></tr>
<tr class="separator:abdc7acb5301ecb41e5084b173179cbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fdf59a05379c28984cca03dc2ddc0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a29fdf59a05379c28984cca03dc2ddc0b">numComputeQueues</a> ()</td></tr>
<tr class="separator:a29fdf59a05379c28984cca03dc2ddc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7fa2969840be9666e4124bb9abbe7030"><td class="memItemLeft" align="right" valign="top"><a id="a7fa2969840be9666e4124bb9abbe7030" name="a7fa2969840be9666e4124bb9abbe7030"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_complex</b> = <a class="el" href="structslate_1_1is__complex.html">slate::is_complex</a>&lt;scalar_t&gt;::value</td></tr>
<tr class="separator:a7fa2969840be9666e4124bb9abbe7030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d33953f70b25b1fd578a3beba0d9af"><td class="memItemLeft" align="right" valign="top"><a id="a49d33953f70b25b1fd578a3beba0d9af" name="a49d33953f70b25b1fd578a3beba0d9af"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_real</b> = ! <a class="el" href="structslate_1_1is__complex.html">is_complex</a></td></tr>
<tr class="separator:a49d33953f70b25b1fd578a3beba0d9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a277939689f41ba24de937c715493c3de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a277939689f41ba24de937c715493c3de">BaseMatrix</a> ()</td></tr>
<tr class="memdesc:a277939689f41ba24de937c715493c3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Default constructor creates an empty matrix.  <br /></td></tr>
<tr class="separator:a277939689f41ba24de937c715493c3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b52abea7eaf3874cfd035b1a78122fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a2b52abea7eaf3874cfd035b1a78122fa">BaseMatrix</a> (int64_t <a class="el" href="classslate_1_1_base_matrix.html#a92ec7abd391d722be9c37d0fd8cd52b4">m</a>, int64_t <a class="el" href="classslate_1_1_base_matrix.html#a6f464ed58763b8ed640a46132a37d5b3">n</a>, std::function&lt; int64_t(int64_t i)&gt; &amp;inTileMb, std::function&lt; int64_t(int64_t j)&gt; &amp;inTileNb, std::function&lt; int(ij_tuple ij)&gt; &amp;inTileRank, std::function&lt; int(ij_tuple ij)&gt; &amp;inTileDevice, MPI_Comm mpi_comm)</td></tr>
<tr class="memdesc:a2b52abea7eaf3874cfd035b1a78122fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Construct matrix with mt block rows and nt block columns, such that sum_{i = 0}^{mt-1} tileMb(i) &gt;= m, sum_{j = 0}^{nt-1} tileNb(j) &gt;= n, where tileMb, tileNb, tileRank, tileDevice are given as functions.  <br /></td></tr>
<tr class="separator:a2b52abea7eaf3874cfd035b1a78122fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad926e9296b7e637b34e9f2d9f31a55e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#ad926e9296b7e637b34e9f2d9f31a55e3">BaseMatrix</a> (int64_t <a class="el" href="classslate_1_1_base_matrix.html#a92ec7abd391d722be9c37d0fd8cd52b4">m</a>, int64_t <a class="el" href="classslate_1_1_base_matrix.html#a6f464ed58763b8ed640a46132a37d5b3">n</a>, int64_t mb, int64_t nb, <a class="el" href="group__enum.html#gaeaac89d42194c5055ca23d59bb9c4dee">GridOrder</a> order, int nprow, int npcol, MPI_Comm mpi_comm)</td></tr>
<tr class="memdesc:ad926e9296b7e637b34e9f2d9f31a55e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Construct matrix with mt = ceil( m / mb ) block rows and nt = ceil( n / nb ) block columns, with fixed mb-by-nb tile size and 2D block cyclic distribution.  <br /></td></tr>
<tr class="separator:ad926e9296b7e637b34e9f2d9f31a55e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae79ad2c7bfc1d67058bbda38df60eb"><td class="memItemLeft" align="right" valign="top"><a id="adae79ad2c7bfc1d67058bbda38df60eb" name="adae79ad2c7bfc1d67058bbda38df60eb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BaseMatrix</b> (int64_t <a class="el" href="classslate_1_1_base_matrix.html#a92ec7abd391d722be9c37d0fd8cd52b4">m</a>, int64_t <a class="el" href="classslate_1_1_base_matrix.html#a6f464ed58763b8ed640a46132a37d5b3">n</a>, int64_t mb, int64_t nb, int nprow, int npcol, MPI_Comm mpi_comm)</td></tr>
<tr class="memdesc:adae79ad2c7bfc1d67058bbda38df60eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">With order = Col. <br /></td></tr>
<tr class="separator:adae79ad2c7bfc1d67058bbda38df60eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d876f78f2f911d35f718d9e9bce68f"><td class="memItemLeft" align="right" valign="top"><a id="a82d876f78f2f911d35f718d9e9bce68f" name="a82d876f78f2f911d35f718d9e9bce68f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BaseMatrix</b> (int64_t <a class="el" href="classslate_1_1_base_matrix.html#a92ec7abd391d722be9c37d0fd8cd52b4">m</a>, int64_t <a class="el" href="classslate_1_1_base_matrix.html#a6f464ed58763b8ed640a46132a37d5b3">n</a>, int64_t nb, int nprow, int npcol, MPI_Comm mpi_comm)</td></tr>
<tr class="memdesc:a82d876f78f2f911d35f718d9e9bce68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">With mb = nb, order = Col. <br /></td></tr>
<tr class="separator:a82d876f78f2f911d35f718d9e9bce68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773755fa8ae8149ac515473225cd8a99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a773755fa8ae8149ac515473225cd8a99">BaseMatrix</a> (<a class="el" href="classslate_1_1_base_matrix.html">BaseMatrix</a> &amp;orig, int64_t i1, int64_t i2, int64_t j1, int64_t j2)</td></tr>
<tr class="memdesc:a773755fa8ae8149ac515473225cd8a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Sub-matrix constructor creates shallow copy view of parent matrix, B[ i1:i2, j1:j2 ].  <br /></td></tr>
<tr class="separator:a773755fa8ae8149ac515473225cd8a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d76cd757dadec0b839440b21f286605"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a9d76cd757dadec0b839440b21f286605">BaseMatrix</a> (<a class="el" href="classslate_1_1_base_matrix.html">BaseMatrix</a> &amp;orig, Slice slice)</td></tr>
<tr class="memdesc:a9d76cd757dadec0b839440b21f286605"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Sliced matrix constructor creates shallow copy view of parent matrix, B[ row1:row2, col1:col2 ].  <br /></td></tr>
<tr class="separator:a9d76cd757dadec0b839440b21f286605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7973e264252321a7061f4c12072d6029"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a7973e264252321a7061f4c12072d6029">tileBcastToSet</a> (int64_t i, int64_t j, std::set&lt; int &gt; const &amp;bcast_set)</td></tr>
<tr class="separator:a7973e264252321a7061f4c12072d6029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93cd06440e69363483a5f4845c23af8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#ab93cd06440e69363483a5f4845c23af8">tileBcastToSet</a> (int64_t i, int64_t j, std::set&lt; int &gt; const &amp;bcast_set, int radix, int tag, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>, <a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target)</td></tr>
<tr class="memdesc:ab93cd06440e69363483a5f4845c23af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Broadcast tile {i, j} to all MPI ranks in the bcast_set.  <br /></td></tr>
<tr class="separator:ab93cd06440e69363483a5f4845c23af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba59438277b90026ad4bd5a0d72861dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#aba59438277b90026ad4bd5a0d72861dc">tileIbcastToSet</a> (int64_t i, int64_t j, std::set&lt; int &gt; const &amp;bcast_set, int radix, int tag, Layout <a class="el" href="classslate_1_1_base_matrix.html#ac07b5530001b56d21fbc66824fa9e9f5">layout</a>, std::vector&lt; MPI_Request &gt; &amp;send_requests, <a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target)</td></tr>
<tr class="memdesc:aba59438277b90026ad4bd5a0d72861dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Broadcast tile {i, j} to all MPI ranks in the bcast_set.  <br /></td></tr>
<tr class="separator:aba59438277b90026ad4bd5a0d72861dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a65f76f20d2dd0d9c3b46dd6a021f3"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; int64_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a80a65f76f20d2dd0d9c3b46dd6a021f3">globalIndex</a> (int64_t i, int64_t j) const</td></tr>
<tr class="memdesc:a80a65f76f20d2dd0d9c3b46dd6a021f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Returns index {i, j} in global matrix as a tuple, taking into account the local offset and transpose.  <br /></td></tr>
<tr class="separator:a80a65f76f20d2dd0d9c3b46dd6a021f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a6c1f652f05d2ceeae8936319d915d"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; int64_t, int64_t, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a10a6c1f652f05d2ceeae8936319d915d">globalIndex</a> (int64_t i, int64_t j, int device) const</td></tr>
<tr class="memdesc:a10a6c1f652f05d2ceeae8936319d915d"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Returns index {i, j, dev} in global matrix as a tuple, taking into account the local offset and transpose.  <br /></td></tr>
<tr class="separator:a10a6c1f652f05d2ceeae8936319d915d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebe04b7301b465cfe059e1cc0e18972"><td class="memItemLeft" align="right" valign="top"><a id="a7ebe04b7301b465cfe059e1cc0e18972" name="a7ebe04b7301b465cfe059e1cc0e18972"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>row0_offset</b> () const</td></tr>
<tr class="memdesc:a7ebe04b7301b465cfe059e1cc0e18972"><td class="mdescLeft">&#160;</td><td class="mdescRight">row offset of first block row. <br /></td></tr>
<tr class="separator:a7ebe04b7301b465cfe059e1cc0e18972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa140fa03910771503e384d371456b69b"><td class="memItemLeft" align="right" valign="top"><a id="aa140fa03910771503e384d371456b69b" name="aa140fa03910771503e384d371456b69b"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>col0_offset</b> () const</td></tr>
<tr class="memdesc:aa140fa03910771503e384d371456b69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">col offset of first block col. <br /></td></tr>
<tr class="separator:aa140fa03910771503e384d371456b69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39710a5a93cf4884d65c1af47d4bc550"><td class="memItemLeft" align="right" valign="top"><a id="a39710a5a93cf4884d65c1af47d4bc550" name="a39710a5a93cf4884d65c1af47d4bc550"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>last_mb</b> () const</td></tr>
<tr class="memdesc:a39710a5a93cf4884d65c1af47d4bc550"><td class="mdescLeft">&#160;</td><td class="mdescRight">rows in last block row. <br /></td></tr>
<tr class="separator:a39710a5a93cf4884d65c1af47d4bc550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e339e6baf1d6613c6f505647a9edaf"><td class="memItemLeft" align="right" valign="top"><a id="a15e339e6baf1d6613c6f505647a9edaf" name="a15e339e6baf1d6613c6f505647a9edaf"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>last_nb</b> () const</td></tr>
<tr class="memdesc:a15e339e6baf1d6613c6f505647a9edaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">cols in last block col. <br /></td></tr>
<tr class="separator:a15e339e6baf1d6613c6f505647a9edaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf6eecff76b22a1bbc56e68966bd9a6"><td class="memItemLeft" align="right" valign="top"><a id="a2bf6eecff76b22a1bbc56e68966bd9a6" name="a2bf6eecff76b22a1bbc56e68966bd9a6"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>ioffset</b> () const</td></tr>
<tr class="memdesc:a2bf6eecff76b22a1bbc56e68966bd9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">block row offset with respect to original matrix <br /></td></tr>
<tr class="separator:a2bf6eecff76b22a1bbc56e68966bd9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa709265bd13cf4fb973e34dded1889c8"><td class="memItemLeft" align="right" valign="top"><a id="aa709265bd13cf4fb973e34dded1889c8" name="aa709265bd13cf4fb973e34dded1889c8"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>joffset</b> () const</td></tr>
<tr class="memdesc:aa709265bd13cf4fb973e34dded1889c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">block col offset with respect to original matrix <br /></td></tr>
<tr class="separator:aa709265bd13cf4fb973e34dded1889c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa65222c4308d64b28e85e2c905477900"><td class="memItemLeft" align="right" valign="top"><a id="aa65222c4308d64b28e85e2c905477900" name="aa65222c4308d64b28e85e2c905477900"></a>
Uplo&#160;</td><td class="memItemRight" valign="bottom"><b>uplo_</b></td></tr>
<tr class="memdesc:aa65222c4308d64b28e85e2c905477900"><td class="mdescLeft">&#160;</td><td class="mdescRight">upper or lower storage <br /></td></tr>
<tr class="separator:aa65222c4308d64b28e85e2c905477900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b56d582da9cc25eb18e47b237b19d2"><td class="memItemLeft" align="right" valign="top"><a id="a83b56d582da9cc25eb18e47b237b19d2" name="a83b56d582da9cc25eb18e47b237b19d2"></a>
Op&#160;</td><td class="memItemRight" valign="bottom"><b>op_</b></td></tr>
<tr class="memdesc:a83b56d582da9cc25eb18e47b237b19d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">transpose operation with respect to original matrix <br /></td></tr>
<tr class="separator:a83b56d582da9cc25eb18e47b237b19d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c06deb056691c876d79814ce804936"><td class="memItemLeft" align="right" valign="top"><a id="a14c06deb056691c876d79814ce804936" name="a14c06deb056691c876d79814ce804936"></a>
Layout&#160;</td><td class="memItemRight" valign="bottom"><b>layout_</b></td></tr>
<tr class="memdesc:a14c06deb056691c876d79814ce804936"><td class="mdescLeft">&#160;</td><td class="mdescRight">intended layout of the matrix. defaults to ColMajor. <br /></td></tr>
<tr class="separator:a14c06deb056691c876d79814ce804936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accceb10928676c076aa2e7bff52fbb3d"><td class="memItemLeft" align="right" valign="top"><a id="accceb10928676c076aa2e7bff52fbb3d" name="accceb10928676c076aa2e7bff52fbb3d"></a>
<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><b>origin_</b></td></tr>
<tr class="memdesc:accceb10928676c076aa2e7bff52fbb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a> origins. defaults to Host. <br /></td></tr>
<tr class="separator:accceb10928676c076aa2e7bff52fbb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af023f4216e896e6b10c1a056f8a521da"><td class="memItemLeft" align="right" valign="top"><a id="af023f4216e896e6b10c1a056f8a521da" name="af023f4216e896e6b10c1a056f8a521da"></a>
std::shared_ptr&lt; <a class="el" href="classslate_1_1_matrix_storage.html">MatrixStorage</a>&lt; scalar_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>storage_</b></td></tr>
<tr class="memdesc:af023f4216e896e6b10c1a056f8a521da"><td class="mdescLeft">&#160;</td><td class="mdescRight">shared storage of tiles and buffers <br /></td></tr>
<tr class="separator:af023f4216e896e6b10c1a056f8a521da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393cfbd043e3e41f87fcb84cc891596e"><td class="memItemLeft" align="right" valign="top"><a id="a393cfbd043e3e41f87fcb84cc891596e" name="a393cfbd043e3e41f87fcb84cc891596e"></a>
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_comm_</b></td></tr>
<tr class="separator:a393cfbd043e3e41f87fcb84cc891596e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058da67010a263e8bc1d0ebce833a9cf"><td class="memItemLeft" align="right" valign="top"><a id="a058da67010a263e8bc1d0ebce833a9cf" name="a058da67010a263e8bc1d0ebce833a9cf"></a>
MPI_Group&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_group_</b></td></tr>
<tr class="separator:a058da67010a263e8bc1d0ebce833a9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81b4c27d8896a6513357a9ed76362e1"><td class="memItemLeft" align="right" valign="top"><a id="aa81b4c27d8896a6513357a9ed76362e1" name="aa81b4c27d8896a6513357a9ed76362e1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_rank_</b></td></tr>
<tr class="separator:aa81b4c27d8896a6513357a9ed76362e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a1eee2ac91086d4133f1262326c73dff7"><td class="memItemLeft" align="right" valign="top"><a id="a1eee2ac91086d4133f1262326c73dff7" name="a1eee2ac91086d4133f1262326c73dff7"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>num_devices_</b> = 0</td></tr>
<tr class="separator:a1eee2ac91086d4133f1262326c73dff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2bbda38dab973ea67b9b9dfbf7001640"><td class="memItemLeft" align="right" valign="top"><a id="a2bbda38dab973ea67b9b9dfbf7001640" name="a2bbda38dab973ea67b9b9dfbf7001640"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Debug</b></td></tr>
<tr class="separator:a2bbda38dab973ea67b9b9dfbf7001640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee9c9d5847c3975520665d70777db57"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a7ee9c9d5847c3975520665d70777db57"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#a7ee9c9d5847c3975520665d70777db57">transpose</a> (MatrixType &amp;A)</td></tr>
<tr class="memdesc:a7ee9c9d5847c3975520665d70777db57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns shallow copy of op(A) that is transposed.  <br /></td></tr>
<tr class="separator:a7ee9c9d5847c3975520665d70777db57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad281d356456e5d851cbf8d60a555f887"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:ad281d356456e5d851cbf8d60a555f887"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#ad281d356456e5d851cbf8d60a555f887">conj_transpose</a> (MatrixType &amp;A)</td></tr>
<tr class="memdesc:ad281d356456e5d851cbf8d60a555f887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns shallow copy of op(A) that is conjugate-transpose.  <br /></td></tr>
<tr class="separator:ad281d356456e5d851cbf8d60a555f887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00082b5710e18f42206b010a2185f2f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:aa00082b5710e18f42206b010a2185f2f"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classslate_1_1_base_matrix.html#aa00082b5710e18f42206b010a2185f2f">conjTranspose</a> (MatrixType &amp;A)</td></tr>
<tr class="memdesc:aa00082b5710e18f42206b010a2185f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conjugate-transpose a <a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a> or any type of <a class="el" href="classslate_1_1_matrix.html" title="General non-symmetric, m-by-n, distributed, tiled matrices.">Matrix</a> object, changing op flag from NoTrans to ConjTrans, or from ConjTrans to NoTrans.  <br /></td></tr>
<tr class="separator:aa00082b5710e18f42206b010a2185f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefa43692c910b58df839217a648bcf7"><td class="memTemplParams" colspan="2"><a id="afefa43692c910b58df839217a648bcf7" name="afefa43692c910b58df839217a648bcf7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afefa43692c910b58df839217a648bcf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classslate_1_1_base_matrix.html">BaseMatrix</a>&lt; T &gt; &amp;A, <a class="el" href="classslate_1_1_base_matrix.html">BaseMatrix</a>&lt; T &gt; &amp;B)</td></tr>
<tr class="separator:afefa43692c910b58df839217a648bcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename scalar_t&gt;<br />
class slate::BaseMatrix&lt; scalar_t &gt;</div><p>Base class for all SLATE distributed, tiled matrices. </p>
<p>In general, the documentation refers to the current matrix object as op(A), to emphasize that it may be transposed with respect to its parent matrix. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a277939689f41ba24de937c715493c3de" name="a277939689f41ba24de937c715493c3de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277939689f41ba24de937c715493c3de">&#9670;&#160;</a></span>BaseMatrix() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::BaseMatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[internal] Default constructor creates an empty matrix. </p>
<p>Does not allocate any memory. </p>

</div>
</div>
<a id="a2b52abea7eaf3874cfd035b1a78122fa" name="a2b52abea7eaf3874cfd035b1a78122fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b52abea7eaf3874cfd035b1a78122fa">&#9670;&#160;</a></span>BaseMatrix() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::BaseMatrix </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int64_t(int64_t i)&gt; &amp;&#160;</td>
          <td class="paramname"><em>inTileMb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int64_t(int64_t j)&gt; &amp;&#160;</td>
          <td class="paramname"><em>inTileNb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int(ij_tuple ij)&gt; &amp;&#160;</td>
          <td class="paramname"><em>inTileRank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int(ij_tuple ij)&gt; &amp;&#160;</td>
          <td class="paramname"><em>inTileDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[internal] Construct matrix with mt block rows and nt block columns, such that sum_{i = 0}^{mt-1} tileMb(i) &gt;= m, sum_{j = 0}^{nt-1} tileNb(j) &gt;= n, where tileMb, tileNb, tileRank, tileDevice are given as functions. </p>
<p>No tiles are allocated. Creates empty matrix storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of the matrix. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of the matrix. n &gt;= 0</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inTileMb</td><td>Function that takes block-row index, returns block-row size.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inTileNb</td><td>Function that takes block-col index, returns block-col size.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inTileRank</td><td>Function that takes tuple of { block-row, block-col } indices, returns MPI rank for that tile.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inTileDevice</td><td>Function that takes tuple of { block-row, block-col } indices, returns local GPU device ID for that tile.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpi_comm</td><td>MPI communicator to distribute matrix across. nprow * npcol &lt;= MPI_Comm_size( mpi_comm ). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad926e9296b7e637b34e9f2d9f31a55e3" name="ad926e9296b7e637b34e9f2d9f31a55e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad926e9296b7e637b34e9f2d9f31a55e3">&#9670;&#160;</a></span>BaseMatrix() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::BaseMatrix </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaeaac89d42194c5055ca23d59bb9c4dee">GridOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nprow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[internal] Construct matrix with mt = ceil( m / mb ) block rows and nt = ceil( n / nb ) block columns, with fixed mb-by-nb tile size and 2D block cyclic distribution. </p>
<p>No tiles are allocated. Creates empty matrix storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Number of rows of the matrix. m &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of columns of the matrix. n &gt;= 0</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mb</td><td>Row block size in 2D block-cyclic distribution. mb &gt; 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>Column block size in 2D block-cyclic distribution. nb &gt; 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order to map MPI processes to tile grid, GridOrder::ColMajor (default) or GridOrder::RowMajor.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nprow</td><td>Number of process rows in 2D block-cyclic distribution. nprow &gt; 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">npcol</td><td>Number of process cols of 2D block-cyclic distribution. npcol &gt; 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpi_comm</td><td>MPI communicator to distribute matrix across. nprow * npcol &lt;= MPI_Comm_size( mpi_comm ). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a773755fa8ae8149ac515473225cd8a99" name="a773755fa8ae8149ac515473225cd8a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773755fa8ae8149ac515473225cd8a99">&#9670;&#160;</a></span>BaseMatrix() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::BaseMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslate_1_1_base_matrix.html">BaseMatrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[internal] Sub-matrix constructor creates shallow copy view of parent matrix, B[ i1:i2, j1:j2 ]. </p>
<p>B[ 0:mt-1, 0:nt-1 ] is the entire B matrix. If i2 &lt; i1 or j2 &lt; j1, produces empty matrix. See <a class="el" href="classslate_1_1_matrix.html#ab8db247b2ceba7ad15bf0d4b72805b7e" title="Returns sub-matrix that is a shallow copy view of the parent matrix, A[ i1:i2, j1:j2 ].">Matrix::sub()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>Parent matrix B.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i1</td><td>Starting block row index. 0 &lt;= i1 &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i2</td><td>Ending block row index (inclusive). i2 &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j1</td><td>Starting block column index. 0 &lt;= j1 &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j2</td><td>Ending block column index (inclusive). j2 &lt; nt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d76cd757dadec0b839440b21f286605" name="a9d76cd757dadec0b839440b21f286605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d76cd757dadec0b839440b21f286605">&#9670;&#160;</a></span>BaseMatrix() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::BaseMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslate_1_1_base_matrix.html">BaseMatrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Slice&#160;</td>
          <td class="paramname"><em>slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[internal] Sliced matrix constructor creates shallow copy view of parent matrix, B[ row1:row2, col1:col2 ]. </p>
<p>This takes row &amp; col indices instead of block row &amp; block col indices. B[ 0:m-1, 0:n-1 ] is the entire B matrix. If row2 &lt; row1 or col2 &lt; col1, produces empty matrix. See <a class="el" href="classslate_1_1_matrix.html#aee49e615bcb1312f49ec446c17be981d" title="Returns sliced matrix that is a shallow copy view of the parent matrix, A[ row1:row2,...">Matrix::slice()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>Parent matrix B.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slice</td><td>Start and end row and column indices:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>slice.row1: Starting row index. 0 &lt;= row1 &lt; m.</li>
<li>slice.row2: Ending row index (inclusive). row2 &lt; m.</li>
<li>slice.col1: Starting column index. 0 &lt;= col1 &lt; n.</li>
<li>slice.col2: Ending column index (inclusive). col2 &lt; n. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afcaf44311decdbee6eaf8bb331ead7b5" name="afcaf44311decdbee6eaf8bb331ead7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcaf44311decdbee6eaf8bb331ead7b5">&#9670;&#160;</a></span>allocateBatchArrays()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::allocateBatchArrays </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>num_arrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates batch arrays and BLAS++ queues for all devices. </p>
<p><a class="el" href="classslate_1_1_matrix.html" title="General non-symmetric, m-by-n, distributed, tiled matrices.">Matrix</a> classes override this with versions that can also allocate based on the number of local tiles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Allocate batch arrays as needed so that size of each batch array &gt;= batch_size &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_arrays</td><td>Allocate batch arrays as needed so that number of batch arrays per device &gt;= num_arrays &gt;= 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5a719a6a86959964bb8198cf4f71452" name="af5a719a6a86959964bb8198cf4f71452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a719a6a86959964bb8198cf4f71452">&#9670;&#160;</a></span>allocWorkspaceBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">scalar_t * <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::allocWorkspaceBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a workspace buffer using the matrix's memory pool. </p>
<p>The memory must be freed with <a class="el" href="classslate_1_1_base_matrix.html#afaae0356663ba2a557346dcb25edda6e" title="Frees a workspace buffer allocated with BaseMatrix::allocWorkspaceBuffer.">BaseMatrix::freeWorkspaceBuffer</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device ID (GPU or Host) where the memory block is needed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The required allocation size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the buffer </dd></dl>

</div>
</div>
<a id="a07e02c3db580ab809a44bca9de86e8d7" name="a07e02c3db580ab809a44bca9de86e8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e02c3db580ab809a44bca9de86e8d7">&#9670;&#160;</a></span>array_device()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scalar_t ** <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::array_device </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_arrays_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>batch arrays for the A, B, or C matrices, on device </dd></dl>

</div>
</div>
<a id="a71605d21463b093ab433fd5afcda4a4b" name="a71605d21463b093ab433fd5afcda4a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71605d21463b093ab433fd5afcda4a4b">&#9670;&#160;</a></span>array_host()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scalar_t ** <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::array_host </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batch_arrays_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>batch arrays for the A, B, or C matrices, on host, to send to device </dd></dl>

</div>
</div>
<a id="a9994f56aa0ea29352c7580b88868e70a" name="a9994f56aa0ea29352c7580b88868e70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9994f56aa0ea29352c7580b88868e70a">&#9670;&#160;</a></span>batchArraySize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::batchArraySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>currently allocated batch array size </dd></dl>

</div>
</div>
<a id="ab6865d27cb1116bbda45effcc18a5ab3" name="ab6865d27cb1116bbda45effcc18a5ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6865d27cb1116bbda45effcc18a5ab3">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all tiles from matrix. </p>
<p>WARNING: currently this clears the entire parent matrix, not just a sub-matrix. </p>

</div>
</div>
<a id="a96382eae6e0b92b244f9f52f47c8a126" name="a96382eae6e0b92b244f9f52f47c8a126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96382eae6e0b92b244f9f52f47c8a126">&#9670;&#160;</a></span>clearBatchArrays()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::clearBatchArrays </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes batch arrays from matrix for all devices. </p>
<p>WARNING: currently this clears the entire parent matrix, not just a sub-matrix. </p>

</div>
</div>
<a id="aaea931e74caaeece38306b39d99be855" name="aaea931e74caaeece38306b39d99be855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea931e74caaeece38306b39d99be855">&#9670;&#160;</a></span>clearWorkspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::clearWorkspace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all temporary host and device workspace tiles from matrix. </p>
<p>WARNING: currently, this clears the entire parent matrix, not just a sub-matrix. </p>

</div>
</div>
<a id="a2aa2219e2d23735b7908edac52419d85" name="a2aa2219e2d23735b7908edac52419d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa2219e2d23735b7908edac52419d85">&#9670;&#160;</a></span>comm_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lapack::Queue * <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::comm_queue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>BLAS++ communication queues</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdc7acb5301ecb41e5084b173179cbcf" name="abdc7acb5301ecb41e5084b173179cbcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc7acb5301ecb41e5084b173179cbcf">&#9670;&#160;</a></span>compute_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lapack::Queue * <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::compute_queue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>BLAS++ compute queues</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue_index</td><td>The index of a specific set of queues </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afaae0356663ba2a557346dcb25edda6e" name="afaae0356663ba2a557346dcb25edda6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaae0356663ba2a557346dcb25edda6e">&#9670;&#160;</a></span>freeWorkspaceBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::freeWorkspaceBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a workspace buffer allocated with <a class="el" href="classslate_1_1_base_matrix.html#af5a719a6a86959964bb8198cf4f71452" title="Allocates a workspace buffer using the matrix&#39;s memory pool.">BaseMatrix::allocWorkspaceBuffer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device ID (GPU or Host) where the memory block is needed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af30581c7a93c522c84a5217d6085669b" name="af30581c7a93c522c84a5217d6085669b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30581c7a93c522c84a5217d6085669b">&#9670;&#160;</a></span>getLocalDevices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::getLocalDevices </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>dev_set</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts all devices that have local tiles in the matrix into the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dev_set</td><td>On output, set of device IDs that this sub-matrix has local tiles on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a960ca0bee46df8dfc563efbbbe21aad8" name="a960ca0bee46df8dfc563efbbbe21aad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960ca0bee46df8dfc563efbbbe21aad8">&#9670;&#160;</a></span>getRanks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::getRanks </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>bcast_set</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts all MPI ranks that have tiles in the matrix into the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">bcast_set</td><td>On output, set of MPI ranks that this sub-matrix has tiles on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80a65f76f20d2dd0d9c3b46dd6a021f3" name="a80a65f76f20d2dd0d9c3b46dd6a021f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a65f76f20d2dd0d9c3b46dd6a021f3">&#9670;&#160;</a></span>globalIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; int64_t, int64_t &gt; <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::globalIndex </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[internal] Returns index {i, j} in global matrix as a tuple, taking into account the local offset and transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10a6c1f652f05d2ceeae8936319d915d" name="a10a6c1f652f05d2ceeae8936319d915d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a6c1f652f05d2ceeae8936319d915d">&#9670;&#160;</a></span>globalIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; int64_t, int64_t, int &gt; <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::globalIndex </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[internal] Returns index {i, j, dev} in global matrix as a tuple, taking into account the local offset and transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba5fa2d7251e7216de3f4ea931e5c958" name="aba5fa2d7251e7216de3f4ea931e5c958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5fa2d7251e7216de3f4ea931e5c958">&#9670;&#160;</a></span>gridinfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::gridinfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaeaac89d42194c5055ca23d59bb9c4dee">GridOrder</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nprow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>npcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>myrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>mycol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get nprow, npcol, myrow, mycol for 2D block cyclic (2DBC) distribution. </p>
<p>If SLATE doesn't know the distribution, sets all values to -1. todo: Assumes col-major 2D block cyclic distribution, not row-major.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">order</td><td>Order to map MPI processes to tile grid.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nprow</td><td>Number of process rows.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">npcol</td><td>Number of process cols.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">myrow</td><td>Process row for this process (MPI rank).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mycol</td><td>Process col for this process (MPI rank). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f4ef408193cac8b5bd8633f8a519052" name="a7f4ef408193cac8b5bd8633f8a519052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4ef408193cac8b5bd8633f8a519052">&#9670;&#160;</a></span>listBcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::listBcast </td>
          <td>(</td>
          <td class="paramtype">BcastList &amp;&#160;</td>
          <td class="paramname"><em>bcast_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>life_factor</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_shared</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send tile {i, j} of op(A) to all MPI ranks in the list of submatrices bcast_list. </p>
<p>Data received must be in 'layout' (ColMajor/RowMajor) major.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">target</td><td>Destination to target; either Host (default) or Device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bcast_list</td><td>List of submatrices defining the MPI ranks to send to. Usually it is the portion of the matrix to be updated by tile {i, j}.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates the Layout (ColMajor/RowMajor) of the broadcasted data. WARNING: must match the layout of the tile in the sender MPI rank.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>MPI tag, default 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">life_factor</td><td>A multiplier for the life count of the broadcasted tile workspace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_shared</td><td>A flag to get and hold the broadcasted (prefetched) tiles on the devices. This flag prevents any subsequent calls of <a class="el" href="classslate_1_1_base_matrix.html#aadca36fe7517359afa9c1c534f5a24ee" title="Erase the tile {i, j}&#39;s instance on device if it is a workspace tile that is not modified and no hold...">tileRelease()</a> routine to release these tiles (clear up the devices memories). WARNING: must set unhold these tiles before releasing them to free up the allocated memories. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7389a85ce34c5675b794dee569d03d63" name="a7389a85ce34c5675b794dee569d03d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7389a85ce34c5675b794dee569d03d63">&#9670;&#160;</a></span>listBcastMT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::listBcastMT </td>
          <td>(</td>
          <td class="paramtype">BcastListTag &amp;&#160;</td>
          <td class="paramname"><em>bcast_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>life_factor</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_shared</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send tile {i, j} of op(A) to all MPI ranks in the list of submatrices bcast_list (using OpenMP tasksloop and multi-threaded MPI). </p>
<p>Data received must be in 'layout' (ColMajor/RowMajor) major.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">target</td><td>Destination to target; either Host (default) or Device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bcast_list</td><td>List of submatrices defining the MPI ranks to send to. Usually it is the portion of the matrix to be updated by tile {i, j}. Each tile {i, j} to be broadcast has a tag in the bcast_list.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates the Layout (ColMajor/RowMajor) of the broadcasted data. WARNING: must match the layout of the tile in the sender MPI rank.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">life_factor</td><td>A multiplier for the life count of the broadcasted tile workspace.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_shared</td><td>A flag to get and hold the broadcasted (prefetched) tiles on the devices. This flag prevents any subsequent calls of <a class="el" href="classslate_1_1_base_matrix.html#aadca36fe7517359afa9c1c534f5a24ee" title="Erase the tile {i, j}&#39;s instance on device if it is a workspace tile that is not modified and no hold...">tileRelease()</a> routine to release these tiles (clear up the devices memories). WARNING: must set unhold these tiles before releasing them to free up the allocated memories. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29fdf59a05379c28984cca03dc2ddc0b" name="a29fdf59a05379c28984cca03dc2ddc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29fdf59a05379c28984cca03dc2ddc0b">&#9670;&#160;</a></span>numComputeQueues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::numComputeQueues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of allocated BLAS++ compute queues </dd></dl>

</div>
</div>
<a id="a3c12448b4b436e2de67d1f8af50a154f" name="a3c12448b4b436e2de67d1f8af50a154f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c12448b4b436e2de67d1f8af50a154f">&#9670;&#160;</a></span>numLocalTiles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::numLocalTiles</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of local tiles in this matrix. </p>
<p>Used for the lifespan of a temporary tile that updates every tile in the matrix. </p>

</div>
</div>
<a id="aa22b4342b5ab0970871d49d7d2392e64" name="aa22b4342b5ab0970871d49d7d2392e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22b4342b5ab0970871d49d7d2392e64">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em> = <code>HostNum</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get shallow copy of tile {i, j} of op(A) on given device, with the tile's op flag set to match the matrix's. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i1 &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID; default is HostNum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a> {i, j, device}. </dd></dl>

</div>
</div>
<a id="a0760782b4221ca74b0a4a286e4b2016b" name="a0760782b4221ca74b0a4a286e4b2016b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0760782b4221ca74b0a4a286e4b2016b">&#9670;&#160;</a></span>originTile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; * <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::originTile </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the origin tile instance of tile(i, j) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b411fce1b2c48a0e3ea0e0f351ce5d0" name="a4b411fce1b2c48a0e3ea0e0f351ce5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b411fce1b2c48a0e3ea0e0f351ce5d0">&#9670;&#160;</a></span>releaseLocalWorkspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::releaseLocalWorkspace </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; ij_tuple &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases a given set of local workspace tiles from all devices including host, if not on hold or modified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tile_set</td><td>Set of (i, j) tuples indicating indices of tiles to be erased. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab448cbd84c11a7118d2885ae1ee69bf3" name="ab448cbd84c11a7118d2885ae1ee69bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab448cbd84c11a7118d2885ae1ee69bf3">&#9670;&#160;</a></span>releaseRemoteWorkspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::releaseRemoteWorkspace </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; ij_tuple &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases a given set of tiles that are not local to node from all devices including host, if not on hold or modified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tile_set</td><td>Set of (i, j) tuples indicating indices of tiles to be erased. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6feea89692d711519e8a2d342651f946" name="a6feea89692d711519e8a2d342651f946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6feea89692d711519e8a2d342651f946">&#9670;&#160;</a></span>releaseRemoteWorkspaceTile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::releaseRemoteWorkspaceTile </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases a given tile that is not local to node from all devices including host, if not on hold or modified. </p>
<p>The tile's receive count is decremented. If the receive count reaches zero, the tile is erased. Otherwise, tile is not erased. </p>

</div>
</div>
<a id="a923bea803ea11a6c1eb61d0f1a34d9af" name="a923bea803ea11a6c1eb61d0f1a34d9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923bea803ea11a6c1eb61d0f1a34d9af">&#9670;&#160;</a></span>releaseWorkspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::releaseWorkspace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all workspace tiles that are not on hold or modified. </p>
<p>Note that Modified, local tiles are currently not released but that this behavior may change in the future and should not be relied apon. </p>

</div>
</div>
<a id="afbc03c645e5d2be01784fd10a36cd3a9" name="afbc03c645e5d2be01784fd10a36cd3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc03c645e5d2be01784fd10a36cd3a9">&#9670;&#160;</a></span>tileAcquire()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileAcquire </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire tile(i, j) on device without copying data if not already exists. </p>
<p>This is used when the destination tile's data will be overriden. Converts destination Layout to 'layout' param. Assumes the TileNode(i, j) already exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s destination: host or device ID.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates the required Layout of the received tile:<ul>
<li>ColMajor: column major.</li>
<li>RowMajor: row major. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f2bdefd118b5649d6f9585a98e0af00" name="a8f2bdefd118b5649d6f9585a98e0af00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2bdefd118b5649d6f9585a98e0af00">&#9670;&#160;</a></span>tileBcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileBcast </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_base_matrix.html">BaseMatrix</a>&lt; scalar_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>life_factor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send tile {i, j} of op(A) to all MPI ranks in matrix B. </p>
<p>If target is Devices, also copies tile to all devices on each MPI rank. This should be called by at least all ranks with local tiles in B; ones that do not have any local tiles are excluded from the broadcast. Data received must be in 'layout' (ColMajor/RowMajor) major.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">target</td><td>Destination to target; either Host (default) or Device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>Sub-matrix B defines the MPI ranks to send to. Usually it is the portion of the matrix to be updated by tile {i, j}.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates the Layout (ColMajor/RowMajor) of the broadcasted data. WARNING: must match the layout of the tile in the sender MPI rank.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>MPI tag, default 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">life_factor</td><td>A multiplier for the life count of the broadcasted tile workspace. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7973e264252321a7061f4c12072d6029" name="a7973e264252321a7061f4c12072d6029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7973e264252321a7061f4c12072d6029">&#9670;&#160;</a></span>tileBcastToSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileBcastToSet </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bcast_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>[internal] Broadcast tile {i, j} to all MPI ranks in the bcast_set. This should be called by all (and only) ranks that are in bcast_set, as either the root sender or a receiver. This implementation creates a subcommunicator and calls MPI broadcast.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcast_set</td><td>Set of MPI ranks to broadcast to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab93cd06440e69363483a5f4845c23af8" name="ab93cd06440e69363483a5f4845c23af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93cd06440e69363483a5f4845c23af8">&#9670;&#160;</a></span>tileBcastToSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileBcastToSet </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bcast_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[internal] Broadcast tile {i, j} to all MPI ranks in the bcast_set. </p>
<p>This should be called by all (and only) ranks that are in bcast_set, as either the root sender or a receiver. This function implements a custom pattern using sends and receives. Data received must be in 'layout' (ColMajor/RowMajor) major.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcast_set</td><td>Set of MPI ranks to broadcast to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radix</td><td>Radix of the communication pattern.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>MPI tag, default 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates the Layout (ColMajor/RowMajor) of the received data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44b6ce07cb3b4efba889ff4e08e28e65" name="a44b6ce07cb3b4efba889ff4e08e28e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b6ce07cb3b4efba889ff4e08e28e65">&#9670;&#160;</a></span>tileDeviceFunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; int(ij_tuple ij)&gt; <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileDeviceFunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns tileDevice function. </p>
<p>Useful to construct matrices with the same block size. For submatrices, this is of the parent matrix. </p>

</div>
</div>
<a id="a2e29d10f356ac39c84d048c37f49192c" name="a2e29d10f356ac39c84d048c37f49192c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e29d10f356ac39c84d048c37f49192c">&#9670;&#160;</a></span>tileErase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileErase </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em> = <code>HostNum</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase tile {i, j} of op(A) on device (host, one device or all devices). </p>
<p>If tile's memory was allocated by SLATE, via tileInsert(i, j, dev) or tileInsertWorkspace(i, j, dev), then the memory is released to the allocator pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7fb93003ea1a28b02b39694dee88ac0" name="af7fb93003ea1a28b02b39694dee88ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fb93003ea1a28b02b39694dee88ac0">&#9670;&#160;</a></span>tileGetAllForReading()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetAllForReading </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all local tiles for reading on device. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#a6ca68e8a280321ed5d472a2d08df04fc" title="Gets tile(i, j) for reading on device.">tileGetForReading</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s destination: host or device ID, defaults to host.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates whether to convert the Layout of the received data:<ul>
<li>ColMajor: convert layout to column major.</li>
<li>RowMajor: convert layout to row major.</li>
<li>None: do not convert layout. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8923f0054bbd38fa275eceedeec0fa56" name="a8923f0054bbd38fa275eceedeec0fa56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8923f0054bbd38fa275eceedeec0fa56">&#9670;&#160;</a></span>tileGetAllForReadingOnDevices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetAllForReadingOnDevices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all local tiles for reading on corresponding devices. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#a6ca68e8a280321ed5d472a2d08df04fc" title="Gets tile(i, j) for reading on device.">tileGetForReading</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates whether to convert the Layout of the received data:<ul>
<li>ColMajor: convert layout to column major.</li>
<li>RowMajor: convert layout to row major.</li>
<li>None: do not convert layout. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af50a8aa6fe3788187ad99d60c075feb8" name="af50a8aa6fe3788187ad99d60c075feb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50a8aa6fe3788187ad99d60c075feb8">&#9670;&#160;</a></span>tileGetAllForWriting()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetAllForWriting </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all local tiles for writing on device. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#ae513ef48ca11afd69289f9328f2ca00c" title="Gets tile(i, j) for writing on device.">tileGetForWriting</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s destination: host or device ID, defaults to host.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates whether to convert the Layout of the received data:<ul>
<li>ColMajor: convert layout to column major.</li>
<li>RowMajor: convert layout to row major.</li>
<li>None: do not convert layout. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dc5cb671c2366e9bb0a84863c06df57" name="a6dc5cb671c2366e9bb0a84863c06df57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc5cb671c2366e9bb0a84863c06df57">&#9670;&#160;</a></span>tileGetAllForWritingOnDevices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetAllForWritingOnDevices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all local tiles for writing on corresponding devices. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#ae513ef48ca11afd69289f9328f2ca00c" title="Gets tile(i, j) for writing on device.">tileGetForWriting</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates whether to convert the Layout of the received data:<ul>
<li>ColMajor: convert layout to column major.</li>
<li>RowMajor: convert layout to row major.</li>
<li>None: do not convert layout. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8e48c08c22d0a29d866c86c2bbbbff8" name="ac8e48c08c22d0a29d866c86c2bbbbff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e48c08c22d0a29d866c86c2bbbbff8">&#9670;&#160;</a></span>tileGetAndHold() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetAndHold </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets tile(i, j) on device for reading and marks it as <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082a20258d782bac93be37b78fe807b4aa1d" title="a hold is placed on this tile instance, cannot be purged">MOSI::OnHold</a>. </p>
<p>Will copy tile in if it does not exist or its state is <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082ade601238c67d62b1890cd32616018e3f" title="tile data is obsolete, other instances may be Modified, Shared, or Invalid, may be purged">MOSI::Invalid</a>. Updates the source tile's state to <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082ac83f58a160bf2f2d5047f487a7f6626d" title="tile data is up-to-date, other instances may be Shared, or Invalid, may be purged">MOSI::Shared</a> if copied-in. Converts destination Layout based on 'layout' param.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s destination: host or device ID, defaults to host.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates whether to convert the Layout of the received data:<ul>
<li>ColMajor: convert layout to column major.</li>
<li>RowMajor: convert layout to row major.</li>
<li>None: do not convert layout. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a184b49ca45a346ffb2c4eb5aa6af55e5" name="a184b49ca45a346ffb2c4eb5aa6af55e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184b49ca45a346ffb2c4eb5aa6af55e5">&#9670;&#160;</a></span>tileGetAndHold() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetAndHold </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets tile(i, j) on host for reading and marks it as <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082a20258d782bac93be37b78fe807b4aa1d" title="a hold is placed on this tile instance, cannot be purged">MOSI::OnHold</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#ac8e48c08c22d0a29d866c86c2bbbbff8" title="Gets tile(i, j) on device for reading and marks it as MOSI::OnHold.">tileGetAndHold</a> </dd></dl>

</div>
</div>
<a id="ac932dab839b071f15ff52d3b1bc4d0cd" name="ac932dab839b071f15ff52d3b1bc4d0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac932dab839b071f15ff52d3b1bc4d0cd">&#9670;&#160;</a></span>tileGetAndHold() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetAndHold </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; ij_tuple &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a set of tiles for reading on device and marks them as <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082a20258d782bac93be37b78fe807b4aa1d" title="a hold is placed on this tile instance, cannot be purged">MOSI::OnHold</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#ac8e48c08c22d0a29d866c86c2bbbbff8" title="Gets tile(i, j) on device for reading and marks it as MOSI::OnHold.">tileGetAndHold</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tile_set</td><td>Set of (i, j) tuples indicating indices of Tiles' to be acquired.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s destination: host or device ID, defaults to host.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates whether to convert the Layout of the received data:<ul>
<li>ColMajor: convert layout to column major.</li>
<li>RowMajor: convert layout to row major.</li>
<li>None: do not convert layout. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14222e26f0ed9936a199ef15b5076dc7" name="a14222e26f0ed9936a199ef15b5076dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14222e26f0ed9936a199ef15b5076dc7">&#9670;&#160;</a></span>tileGetAndHold() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetAndHold </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; ij_tuple &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a set of tiles for reading on host and marks them as <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082a20258d782bac93be37b78fe807b4aa1d" title="a hold is placed on this tile instance, cannot be purged">MOSI::OnHold</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#ac8e48c08c22d0a29d866c86c2bbbbff8" title="Gets tile(i, j) on device for reading and marks it as MOSI::OnHold.">tileGetAndHold</a> </dd></dl>

</div>
</div>
<a id="a446b1f5c09fb5a3a8f98f063b2df805c" name="a446b1f5c09fb5a3a8f98f063b2df805c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446b1f5c09fb5a3a8f98f063b2df805c">&#9670;&#160;</a></span>tileGetAndHoldAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetAndHoldAll </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all local tiles on device and marks them as <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082a20258d782bac93be37b78fe807b4aa1d" title="a hold is placed on this tile instance, cannot be purged">MOSI::OnHold</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#ac8e48c08c22d0a29d866c86c2bbbbff8" title="Gets tile(i, j) on device for reading and marks it as MOSI::OnHold.">tileGetAndHold</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s destination: host or device ID, defaults to host.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates whether to convert the Layout of the received data:<ul>
<li>ColMajor: convert layout to column major.</li>
<li>RowMajor: convert layout to row major.</li>
<li>None: do not convert layout. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30ca07e10465c729ef629c7299569feb" name="a30ca07e10465c729ef629c7299569feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ca07e10465c729ef629c7299569feb">&#9670;&#160;</a></span>tileGetAndHoldAllOnDevices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetAndHoldAllOnDevices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all local tiles on corresponding devices and marks them as <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082a20258d782bac93be37b78fe807b4aa1d" title="a hold is placed on this tile instance, cannot be purged">MOSI::OnHold</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#ac8e48c08c22d0a29d866c86c2bbbbff8" title="Gets tile(i, j) on device for reading and marks it as MOSI::OnHold.">tileGetAndHold</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates whether to convert the Layout of the received data:<ul>
<li>ColMajor: convert layout to column major.</li>
<li>RowMajor: convert layout to row major.</li>
<li>None: do not convert layout. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ca68e8a280321ed5d472a2d08df04fc" name="a6ca68e8a280321ed5d472a2d08df04fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca68e8a280321ed5d472a2d08df04fc">&#9670;&#160;</a></span>tileGetForReading() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetForReading </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets tile(i, j) for reading on device. </p>
<p>Will copy-in the tile if it does not exist or its state is <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082ade601238c67d62b1890cd32616018e3f" title="tile data is obsolete, other instances may be Modified, Shared, or Invalid, may be purged">MOSI::Invalid</a>. Sets tile state to <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082ac83f58a160bf2f2d5047f487a7f6626d" title="tile data is up-to-date, other instances may be Shared, or Invalid, may be purged">MOSI::Shared</a> if copied-in. Finds a source tile whose state is valid (Modified|Shared) by looping on existing tile instances. Updates source tile's state to shared if copied-in. Converts destination Layout based on 'layout' param.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s destination: host or device ID, defaults to host.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates whether to convert the Layout of the received data:<ul>
<li>ColMajor: convert layout to column major.</li>
<li>RowMajor: convert layout to row major.</li>
<li>None: do not convert layout. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52e10a515c998f1ab5487220f3f2f491" name="a52e10a515c998f1ab5487220f3f2f491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e10a515c998f1ab5487220f3f2f491">&#9670;&#160;</a></span>tileGetForReading() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetForReading </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets tile(i, j) for reading on host. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#a6ca68e8a280321ed5d472a2d08df04fc" title="Gets tile(i, j) for reading on device.">tileGetForReading</a> </dd></dl>

</div>
</div>
<a id="ae895295a7cda60e541088c5d0c444d26" name="ae895295a7cda60e541088c5d0c444d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae895295a7cda60e541088c5d0c444d26">&#9670;&#160;</a></span>tileGetForReading() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetForReading </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; ij_tuple &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a set of tiles for reading on device. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#a6ca68e8a280321ed5d472a2d08df04fc" title="Gets tile(i, j) for reading on device.">tileGetForReading</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tile_set</td><td>Set of (i, j) tuples indicating indices of Tiles' to be acquired.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s destination: host or device ID.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates whether to convert the Layout of the received data:<ul>
<li>ColMajor: convert layout to column major.</li>
<li>RowMajor: convert layout to row major.</li>
<li>None: do not convert layout. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9146c688a4b7897e09d517d126a28d9" name="ae9146c688a4b7897e09d517d126a28d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9146c688a4b7897e09d517d126a28d9">&#9670;&#160;</a></span>tileGetForReading() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetForReading </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; ij_tuple &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a set of tiles for reading on host. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#a6ca68e8a280321ed5d472a2d08df04fc" title="Gets tile(i, j) for reading on device.">tileGetForReading</a> </dd></dl>

</div>
</div>
<a id="ae92b260ccc7af7166b0237fa8b9ae77f" name="ae92b260ccc7af7166b0237fa8b9ae77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92b260ccc7af7166b0237fa8b9ae77f">&#9670;&#160;</a></span>tileGetForReading() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetForReading </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; ij_tuple &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from_device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a set of tiles for reading on host from a specific device. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#a6ca68e8a280321ed5d472a2d08df04fc" title="Gets tile(i, j) for reading on device.">tileGetForReading</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tile_set</td><td>Set of (i, j) tuples indicating indices of Tiles' to be acquired. Tiles should exist on the specified device.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates whether to convert the Layout of the received data:<ul>
<li>ColMajor: convert layout to column major.</li>
<li>RowMajor: convert layout to row major.</li>
<li>None: do not convert layout.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from_device</td><td>Tiles' source device ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae513ef48ca11afd69289f9328f2ca00c" name="ae513ef48ca11afd69289f9328f2ca00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae513ef48ca11afd69289f9328f2ca00c">&#9670;&#160;</a></span>tileGetForWriting() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetForWriting </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets tile(i, j) for writing on device. </p>
<p>Sets destination tile's state to <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082a80f634685ca6e683a9fee49580be6a0a" title="tile data is modified, other instances should be Invalid, cannot be purged">MOSI::Modified</a>. Will copy-in the tile if it does not exist or its state is <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082ade601238c67d62b1890cd32616018e3f" title="tile data is obsolete, other instances may be Modified, Shared, or Invalid, may be purged">MOSI::Invalid</a>. Other instances will be invalidated. Finds a source tile whose state is valid (Modified|Shared) by scanning existing tile instances. Converts destination Layout based on 'layout' param.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s destination: host or device ID, defaults to host.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates whether to convert the Layout of the received data:<ul>
<li>ColMajor: convert layout to column major.</li>
<li>RowMajor: convert layout to row major.</li>
<li>None: do not convert layout. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a687d53fdd1179f8ff9d5b3d9c6350553" name="a687d53fdd1179f8ff9d5b3d9c6350553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687d53fdd1179f8ff9d5b3d9c6350553">&#9670;&#160;</a></span>tileGetForWriting() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetForWriting </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets tile(i, j) for writing on host. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#ae513ef48ca11afd69289f9328f2ca00c" title="Gets tile(i, j) for writing on device.">tileGetForWriting</a> </dd></dl>

</div>
</div>
<a id="aa543f9875a1cda6f3d24c120054850cd" name="aa543f9875a1cda6f3d24c120054850cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa543f9875a1cda6f3d24c120054850cd">&#9670;&#160;</a></span>tileGetForWriting() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetForWriting </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; ij_tuple &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a set of tiles for writing on device. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#ae513ef48ca11afd69289f9328f2ca00c" title="Gets tile(i, j) for writing on device.">tileGetForWriting</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tile_set</td><td>Set of (i, j) tuples indicating indices of Tiles' to be acquired.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s destination: host or device ID, defaults to host.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates whether to convert the Layout of the received data:<ul>
<li>ColMajor: convert layout to column major.</li>
<li>RowMajor: convert layout to row major.</li>
<li>None: do not convert layout. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56b5ab7e19bb1560a115799e884129da" name="a56b5ab7e19bb1560a115799e884129da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b5ab7e19bb1560a115799e884129da">&#9670;&#160;</a></span>tileGetForWriting() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileGetForWriting </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; ij_tuple &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaaee2d0235d47c304b5d8583af314eef4">LayoutConvert</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a set of tiles for writing on host. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#ae513ef48ca11afd69289f9328f2ca00c" title="Gets tile(i, j) for writing on device.">tileGetForWriting</a> </dd></dl>

</div>
</div>
<a id="aba59438277b90026ad4bd5a0d72861dc" name="aba59438277b90026ad4bd5a0d72861dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba59438277b90026ad4bd5a0d72861dc">&#9670;&#160;</a></span>tileIbcastToSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileIbcastToSet </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bcast_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; MPI_Request &gt; &amp;&#160;</td>
          <td class="paramname"><em>send_requests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[internal] Broadcast tile {i, j} to all MPI ranks in the bcast_set. </p>
<p>This should be called by all (and only) ranks that are in bcast_set, as either the root sender or a receiver. This function implements a custom pattern using sends and receives. Data received must be in 'layout' (ColMajor/RowMajor) major. Nonblocking sends are used, with requests appended to the provided vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bcast_set</td><td>Set of MPI ranks to broadcast to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radix</td><td>Radix of the communication pattern.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>MPI tag, default 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates the Layout (ColMajor/RowMajor) of the received data.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">send_requests</td><td>Vector where requests for this bcast are appended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69c573dc6ec466ff3bccb3917d27b92a" name="a69c573dc6ec466ff3bccb3917d27b92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c573dc6ec466ff3bccb3917d27b92a">&#9670;&#160;</a></span>tileInsert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; * <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileInsert </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ld</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert tile {i, j} of op(A) with existing data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID; default is HostNum (provided by overloaded function).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s data. The matrix uses this pointer directly, it does not copy the data, so the data must remain valid while the matrix exists.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ld</td><td>Leading dimension of data; column stride. ld &gt;= tileMb(i).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new tile. </dd></dl>

</div>
</div>
<a id="a31c53893af0d3cb537b78e85125cd25e" name="a31c53893af0d3cb537b78e85125cd25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c53893af0d3cb537b78e85125cd25e">&#9670;&#160;</a></span>tileInsert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; * <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileInsert </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em> = <code>HostNum</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert tile {i, j} of op(A) and allocate its data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID; default is HostNum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new tile. </dd></dl>

</div>
</div>
<a id="a505bd06d71fd58f184ee15d5295eb47c" name="a505bd06d71fd58f184ee15d5295eb47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505bd06d71fd58f184ee15d5295eb47c">&#9670;&#160;</a></span>tileInsert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; * <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileInsert </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_t *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ld</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert tile with default device=HostNum. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#a31c53893af0d3cb537b78e85125cd25e" title="Insert tile {i, j} of op(A) and allocate its data.">tileInsert</a>. </dd></dl>

</div>
</div>
<a id="a1b5f8d73d1127a1c602db66946668b9c" name="a1b5f8d73d1127a1c602db66946668b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5f8d73d1127a1c602db66946668b9c">&#9670;&#160;</a></span>tileInsertWorkspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; * <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileInsertWorkspace </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a workspace tile {i, j} of op(A) and allocate its data. </p>
<p>The tile will be freed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID; default is HostNum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new tile. </dd></dl>

</div>
</div>
<a id="a4fd8162aa2a1e7bcf119f27aa1b07be2" name="a4fd8162aa2a1e7bcf119f27aa1b07be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd8162aa2a1e7bcf119f27aa1b07be2">&#9670;&#160;</a></span>tileLayoutConvert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileLayoutConvert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reset</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts all existing tile instances on 'device' into 'layout' Operates in batch mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Tiles' host or device ID.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Intended Layout of tiles:<ul>
<li>Layout::ColMajor or</li>
<li>Layout::RowMajor.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reset</td><td>Optinally resets the tiles extended buffers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0e6ea31cd523d79eb349e60a1d0b1c4" name="aa0e6ea31cd523d79eb349e60a1d0b1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e6ea31cd523d79eb349e60a1d0b1c4">&#9670;&#160;</a></span>tileLayoutConvert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileLayoutConvert </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reset</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts tile(i, j, device) into 'layout'. </p>
<p><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a> should exist on 'device', will assert otherwise. <a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a> will be made Convertible if it was not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s host or device ID.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Intended Layout of tile:<ul>
<li>Layout::ColMajor or</li>
<li>Layout::RowMajor.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reset</td><td>Optinally resets the tile extended buffers.</td></tr>
  </table>
  </dd>
</dl>
<p>todo: handle op(A), sub-matrix, and sliced-matrix </p>

</div>
</div>
<a id="a2e742f106d1dbc715f4486ce0e5464b2" name="a2e742f106d1dbc715f4486ce0e5464b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e742f106d1dbc715f4486ce0e5464b2">&#9670;&#160;</a></span>tileLayoutConvert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileLayoutConvert </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; ij_tuple &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reset</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts tiles indicated in 'tile_set' that exist on 'device' into 'layout' if not already in 'layout' major. </p>
<p>Tiles should exist on 'device', will throw exception otherwise. Operates in batch mode when tiles are on devices. If device is not Host, will bucket tiles into uniform size and stride batches, then launches each batch transpose.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tile_set</td><td>Set of (i, j) tuples indicating indices of Tiles' to be converted.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Tiles' host or device ID.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Intended Layout of tiles:<ul>
<li>Layout::ColMajor or</li>
<li>Layout::RowMajor.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reset</td><td>Optinally resets the tiles extended buffers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1c2540386635f7af9a615cdd0e5875c" name="ab1c2540386635f7af9a615cdd0e5875c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c2540386635f7af9a615cdd0e5875c">&#9670;&#160;</a></span>tileLayoutConvertOnDevices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileLayoutConvertOnDevices </td>
          <td>(</td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reset</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts all existing tile instances on available devices into 'layout'. </p>
<p>Host tiles are not affected. Tiles should exist already on devices. Operates in batch mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Intended Layout of tiles:<ul>
<li>Layout::ColMajor or</li>
<li>Layout::RowMajor.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reset</td><td>Optinally resets the tile extended buffers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bd94a32330dcd78ac3542d9997dc802" name="a8bd94a32330dcd78ac3542d9997dc802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd94a32330dcd78ac3542d9997dc802">&#9670;&#160;</a></span>tileLayoutIsConvertible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileLayoutIsConvertible </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em> = <code>HostNum</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether tile(i, j, device) can be safely transposed. </p>
<p>based on its 'TileKind', buffer size, Layout, and stride. <a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a> instance on 'device' should exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s host or device ID, defaults to host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88b6f930f52ce72d421ebc019decf135" name="a88b6f930f52ce72d421ebc019decf135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b6f930f52ce72d421ebc019decf135">&#9670;&#160;</a></span>tileLayoutReset() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileLayoutReset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts all origin tiles into current matrix-layout. </p>
<p>Operates in batch mode. </p>

</div>
</div>
<a id="a65bf3d4bc49e2da615760ce7ad9dc169" name="a65bf3d4bc49e2da615760ce7ad9dc169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65bf3d4bc49e2da615760ce7ad9dc169">&#9670;&#160;</a></span>tileLayoutReset() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileLayoutReset </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts tile(i, j) into current layout and resets its extended buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID; default is HostNum.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Intended Layout of tiles:<ul>
<li>Layout::ColMajor or</li>
<li>Layout::RowMajor. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae87fd153af7f4c3e1cfe218454ba19e3" name="ae87fd153af7f4c3e1cfe218454ba19e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87fd153af7f4c3e1cfe218454ba19e3">&#9670;&#160;</a></span>tileLayoutReset() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileLayoutReset </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; ij_tuple &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts set of tiles into current layout and resets their extended buffers. </p>
<p>Operates in batch mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tile_set</td><td>Set of (i, j) indices of tiles to be converted and reset.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID; default is HostNum.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Intended Layout of tiles:<ul>
<li>Layout::ColMajor or</li>
<li>Layout::RowMajor. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a066013a2f281b1cc301b5472f7a0b468" name="a066013a2f281b1cc301b5472f7a0b468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066013a2f281b1cc301b5472f7a0b468">&#9670;&#160;</a></span>tileMb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileMb </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of rows (mb) in block row i of op(A). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f358cc929e5e527f033e01f725c1c09" name="a5f358cc929e5e527f033e01f725c1c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f358cc929e5e527f033e01f725c1c09">&#9670;&#160;</a></span>tileMbFunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; int64_t(int64_t i)&gt; <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileMbFunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns tileMb function. </p>
<p>Useful to construct matrices with the same block size. For submatrices, this is of the parent matrix. </p>

</div>
</div>
<a id="a05219997eb4aae0de1e7697d30cde712" name="a05219997eb4aae0de1e7697d30cde712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05219997eb4aae0de1e7697d30cde712">&#9670;&#160;</a></span>tileModified()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileModified </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em> = <code>HostNum</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permissive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks tile(i, j) as Modified on device. </p>
<p>Other instances will be invalidated. Unless permissive, asserts if other instances are in Modified state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID, defaults to host.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permissive</td><td>Defaults to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f1a1741c272f3e89a1d1f3e6691f35d" name="a7f1a1741c272f3e89a1d1f3e6691f35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1a1741c272f3e89a1d1f3e6691f35d">&#9670;&#160;</a></span>tileNb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileNb </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of cols (nb) in block col j of op(A). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d613f3ed706655d6234333e84d21fa1" name="a9d613f3ed706655d6234333e84d21fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d613f3ed706655d6234333e84d21fa1">&#9670;&#160;</a></span>tileNbFunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; int64_t(int64_t j)&gt; <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileNbFunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns tileNb function. </p>
<p>Useful to construct matrices with the same block size. For submatrices, this is of the parent matrix. </p>

</div>
</div>
<a id="af36a577f0a6bb5b7c4053e83127921e4" name="af36a577f0a6bb5b7c4053e83127921e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36a577f0a6bb5b7c4053e83127921e4">&#9670;&#160;</a></span>tileOnHold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileOnHold </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em> = <code>HostNum</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether tile(i, j) is OnHold on device (defaults to host). </p>
<p>Asserts if tile does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ba23dff11c9ab0ea4ef90bfc635a109" name="a7ba23dff11c9ab0ea4ef90bfc635a109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba23dff11c9ab0ea4ef90bfc635a109">&#9670;&#160;</a></span>tileRankFunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; int(ij_tuple ij)&gt; <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileRankFunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns tileRank function. </p>
<p>Useful to construct matrices with the same block size. For submatrices, this is of the parent matrix. </p>

</div>
</div>
<a id="a9a364ce568ff323df4a79644ce89b852" name="a9a364ce568ff323df4a79644ce89b852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a364ce568ff323df4a79644ce89b852">&#9670;&#160;</a></span>tileReceiveCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileReceiveCount </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns how many times the tile {i, j} is received through MPI. </p>
<p>This function is used to track tiles that may be communicated twice due to symmetricity during hemm and symm operations. </p>

</div>
</div>
<a id="ab77ee84b16b1b2e4c8b5ac8e5c9f14f7" name="ab77ee84b16b1b2e4c8b5ac8e5c9f14f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77ee84b16b1b2e4c8b5ac8e5c9f14f7">&#9670;&#160;</a></span>tileRecv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileRecv </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive tile {i, j} of op(A) to the given MPI rank. </p>
<p><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a> is allocated as workspace with life = 1 if it doesn't yet exist, or 1 is added to life if it does exist. Source rank must call <a class="el" href="classslate_1_1_base_matrix.html#a51d82299f56915257fa8f16e77a0f9fc" title="Send tile {i, j} of op(A) to the given MPI rank.">tileSend()</a>. Data received must be in 'layout' (ColMajor/RowMajor) major.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">target</td><td>Destination to target; either Host (default) or Device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_rank</td><td>Source MPI rank. If src_rank == mpiRank, this is a no-op.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>Indicates the Layout (ColMajor/RowMajor) of the received data. WARNING: must match the layout of the tile in the sender MPI rank.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>MPI tag, default 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadca36fe7517359afa9c1c534f5a24ee" name="aadca36fe7517359afa9c1c534f5a24ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadca36fe7517359afa9c1c534f5a24ee">&#9670;&#160;</a></span>tileRelease()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileRelease </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em> = <code>HostNum</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the tile {i, j}'s instance on device if it is a workspace tile that is not modified and no hold is set on it. </p>
<p>If tile's memory was allocated by SLATE, via tileInsert(i, j, dev) or tileInsertWorkspace(i, j, dev), then the memory is released to the allocator pool.</p>
<p>Note that Modified, local tiles are currently not released but that this behavior may change in the future and should not be relied apon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51d82299f56915257fa8f16e77a0f9fc" name="a51d82299f56915257fa8f16e77a0f9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d82299f56915257fa8f16e77a0f9fc">&#9670;&#160;</a></span>tileSend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="group__enum.html#gaf84c73d5e2cf203effad4b6cb3f96fb8">Target</a> target&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileSend </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dst_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send tile {i, j} of op(A) to the given MPI rank. </p>
<p>Destination rank must call <a class="el" href="classslate_1_1_base_matrix.html#ab77ee84b16b1b2e4c8b5ac8e5c9f14f7" title="Receive tile {i, j} of op(A) to the given MPI rank.">tileRecv()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">target</td><td>Destination to target; either Host (default) or Device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_rank</td><td>Destination MPI rank. If dst_rank == mpiRank, this is a no-op.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>MPI tag, default 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05212fdeb68f7548740207b85f389598" name="a05212fdeb68f7548740207b85f389598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05212fdeb68f7548740207b85f389598">&#9670;&#160;</a></span>tileState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileState </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082">MOSI</a>&#160;</td>
          <td class="paramname"><em>mosi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets tile(i, j)'s state on device. </p>
<p>Asserts if tile does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcb059bd32953340001b400279956d9d" name="adcb059bd32953340001b400279956d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb059bd32953340001b400279956d9d">&#9670;&#160;</a></span>tileState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082">MOSI</a> <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileState </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em> = <code>HostNum</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns tile(i, j)'s state on device (defaults to host). </p>
<p>Asserts if tile does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a682995e23692709ce243a987babb172d" name="a682995e23692709ce243a987babb172d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682995e23692709ce243a987babb172d">&#9670;&#160;</a></span>tileTick()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileTick </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements life counter of workspace tile {i, j} of op(A). </p>
<p>Then, if life reaches 0, deletes tile on all devices. For local, non-workspace tiles, does nothing. </p>

</div>
</div>
<a id="ae7761fa8df57612c3a5c08c39e62f510" name="ae7761fa8df57612c3a5c08c39e62f510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7761fa8df57612c3a5c08c39e62f510">&#9670;&#160;</a></span>tileUnsetHold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileUnsetHold </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em> = <code>HostNum</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the hold of tile(i, j) on device (defaults to host) if it was OnHold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9978416be77ada7c0a2576bae568838" name="ad9978416be77ada7c0a2576bae568838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9978416be77ada7c0a2576bae568838">&#9670;&#160;</a></span>tileUnsetHoldAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileUnsetHoldAll </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em> = <code>HostNum</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets all local tiles' hold on device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s device ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0649df9666eb89f813440347aad13be7" name="a0649df9666eb89f813440347aad13be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0649df9666eb89f813440347aad13be7">&#9670;&#160;</a></span>tileUpdateOrigin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslate_1_1_tile.html">Tile</a>&lt; scalar_t &gt; * <a class="el" href="classslate_1_1_base_matrix.html">slate::BaseMatrix</a>&lt; scalar_t &gt;::tileUpdateOrigin </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the origin instance of tile(i, j) if <a class="el" href="namespaceslate.html#a68146de4c8a20d4732b7ef37ebc35082ade601238c67d62b1890cd32616018e3f" title="tile data is obsolete, other instances may be Modified, Shared, or Invalid, may be purged">MOSI::Invalid</a> tile must be local. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block row index. 0 &lt;= i &lt; mt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td><a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>'s block column index. 0 &lt;= j &lt; nt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to origin instance of tile(i, j) </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="ad281d356456e5d851cbf8d60a555f887" name="ad281d356456e5d851cbf8d60a555f887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad281d356456e5d851cbf8d60a555f887">&#9670;&#160;</a></span>conj_transpose</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatrixType conj_transpose </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns shallow copy of op(A) that is conjugate-transpose. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#a7ee9c9d5847c3975520665d70777db57" title="Returns shallow copy of op(A) that is transposed.">transpose</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>copy of <a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>, etc. with updated op flag. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#a7ee9c9d5847c3975520665d70777db57" title="Returns shallow copy of op(A) that is transposed.">transpose()</a> </dd></dl>

</div>
</div>
<a id="aa00082b5710e18f42206b010a2185f2f" name="aa00082b5710e18f42206b010a2185f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00082b5710e18f42206b010a2185f2f">&#9670;&#160;</a></span>conjTranspose</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatrixType conjTranspose </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conjugate-transpose a <a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a> or any type of <a class="el" href="classslate_1_1_matrix.html" title="General non-symmetric, m-by-n, distributed, tiled matrices.">Matrix</a> object, changing op flag from NoTrans to ConjTrans, or from ConjTrans to NoTrans. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>copy of <a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>, etc. with updated op flag. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#a7ee9c9d5847c3975520665d70777db57" title="Returns shallow copy of op(A) that is transposed.">transpose()</a> </dd></dl>

</div>
</div>
<a id="a7ee9c9d5847c3975520665d70777db57" name="a7ee9c9d5847c3975520665d70777db57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee9c9d5847c3975520665d70777db57">&#9670;&#160;</a></span>transpose</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatrixType transpose </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns shallow copy of op(A) that is transposed. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classslate_1_1_base_matrix.html#ad281d356456e5d851cbf8d60a555f887" title="Returns shallow copy of op(A) that is conjugate-transpose.">conj_transpose</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>copy of <a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a>, etc. with updated op flag.</dd></dl>
<p>Making this a template avoids repeating the code ad nauseum in each class. <a class="el" href="classslate_1_1_tile.html" title="Tile holding an mb-by-nb matrix, with leading dimension (stride).">Tile</a> and <a class="el" href="classslate_1_1_base_matrix.html" title="Base class for all SLATE distributed, tiled matrices.">BaseMatrix</a> make this a friend, to change op. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/slate/BaseMatrix.hh</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceslate.html">slate</a></li><li class="navelem"><a class="el" href="classslate_1_1_base_matrix.html">BaseMatrix</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
