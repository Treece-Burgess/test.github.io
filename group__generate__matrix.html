<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SLATE: Generate test matrix</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
// see https://stackoverflow.com/questions/40270302/latex-newcommand-in-doxgygen-html-output
// see http://docs.mathjax.org/en/latest/tex.html#defining-tex-macros
MathJax.Hub.Config({
    TeX: {
        Macros: {
            abs: ["\\left| #1 \\right|", 1],
            norm: ["\\left\\lVert #1 \\right\\rVert", 1],
        }
    }
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SLATE<span id="projectnumber">&#160;2023.08.25</span>
   </div>
   <div id="projectbrief">Software for Linear Algebra Targeting Exascale</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__generate__matrix.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Generate test matrix<div class="ingroups"><a class="el" href="group__group__blas2__top.html">Level 2 BLAS and Auxiliary: O(n^2) work</a> &raquo; <a class="el" href="group__group__set.html">Initialize and copy</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5b48bc88bfe5630fba45983b57a09aa9"><td class="memTemplParams" colspan="2">template&lt;typename matrix_type &gt; </td></tr>
<tr class="memitem:ga5b48bc88bfe5630fba45983b57a09aa9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generate__matrix.html#ga5b48bc88bfe5630fba45983b57a09aa9">slate::generate_sigma</a> (MatrixParams &amp;params, TestMatrixDist dist, bool rand_sign, blas::real_type&lt; typename matrix_type::value_type &gt; cond, blas::real_type&lt; typename matrix_type::value_type &gt; sigma_max, matrix_type &amp;A, std::vector&lt; blas::real_type&lt; typename matrix_type::value_type &gt; &gt; &amp;Sigma, int64_t seed)</td></tr>
<tr class="memdesc:ga5b48bc88bfe5630fba45983b57a09aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates Sigma vector of singular or eigenvalues, according to distribution.  <br /></td></tr>
<tr class="separator:ga5b48bc88bfe5630fba45983b57a09aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04d99af123609cc307851e85aaad2aaa"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:ga04d99af123609cc307851e85aaad2aaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generate__matrix.html#ga04d99af123609cc307851e85aaad2aaa">slate::generate_svd</a> (MatrixParams &amp;params, TestMatrixDist dist, blas::real_type&lt; scalar_t &gt; cond, blas::real_type&lt; scalar_t &gt; condD, blas::real_type&lt; scalar_t &gt; sigma_max, <a class="el" href="classslate_1_1_matrix.html">slate::Matrix</a>&lt; scalar_t &gt; &amp;A, std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;Sigma, int64_t seed, slate::Options const &amp;opts)</td></tr>
<tr class="memdesc:ga04d99af123609cc307851e85aaad2aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given matrix A with singular values such that sum(sigma_i^2) = n, returns A with columns of unit norm, with the same condition number.  <br /></td></tr>
<tr class="separator:ga04d99af123609cc307851e85aaad2aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga191e107783c1013e57ecb365e3bc0c55"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:ga191e107783c1013e57ecb365e3bc0c55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generate__matrix.html#ga191e107783c1013e57ecb365e3bc0c55">slate::generate_heev</a> (MatrixParams &amp;params, TestMatrixDist dist, bool rand_sign, blas::real_type&lt; scalar_t &gt; cond, blas::real_type&lt; scalar_t &gt; condD, blas::real_type&lt; scalar_t &gt; sigma_max, <a class="el" href="classslate_1_1_matrix.html">slate::Matrix</a>&lt; scalar_t &gt; &amp;A, std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;Sigma, int64_t seed, slate::Options const &amp;opts)</td></tr>
<tr class="memdesc:ga191e107783c1013e57ecb365e3bc0c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates matrix using Hermitian eigenvalue decomposition, \(A = U Sigma U^H\).  <br /></td></tr>
<tr class="separator:ga191e107783c1013e57ecb365e3bc0c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0855f4b6aba372f7e29051d29e41882"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:gad0855f4b6aba372f7e29051d29e41882"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generate__matrix.html#gad0855f4b6aba372f7e29051d29e41882">slate::generate_geev</a> (MatrixParams &amp;params, TestMatrixDist dist, blas::real_type&lt; scalar_t &gt; cond, blas::real_type&lt; scalar_t &gt; sigma_max, <a class="el" href="classslate_1_1_matrix.html">slate::Matrix</a>&lt; scalar_t &gt; &amp;A, std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;Sigma, int64_t seed, slate::Options const &amp;opts)</td></tr>
<tr class="memdesc:gad0855f4b6aba372f7e29051d29e41882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates matrix using general eigenvalue decomposition, \(A = V T V^H\), with orthogonal eigenvectors.  <br /></td></tr>
<tr class="separator:gad0855f4b6aba372f7e29051d29e41882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1262f0ef9db6fd56febc73e7b86cdf6"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:gaf1262f0ef9db6fd56febc73e7b86cdf6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generate__matrix.html#gaf1262f0ef9db6fd56febc73e7b86cdf6">slate::generate_geevx</a> (MatrixParams &amp;params, TestMatrixDist dist, blas::real_type&lt; scalar_t &gt; cond, blas::real_type&lt; scalar_t &gt; sigma_max, <a class="el" href="classslate_1_1_matrix.html">slate::Matrix</a>&lt; scalar_t &gt; &amp;A, std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;Sigma, int64_t seed, slate::Options const &amp;opts)</td></tr>
<tr class="memdesc:gaf1262f0ef9db6fd56febc73e7b86cdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates matrix using general eigenvalue decomposition, \(A = X T X^{-1}\), with random eigenvectors.  <br /></td></tr>
<tr class="separator:gaf1262f0ef9db6fd56febc73e7b86cdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71cf149080a7a29951dfbdebe483a3a2"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:ga71cf149080a7a29951dfbdebe483a3a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generate__matrix.html#ga71cf149080a7a29951dfbdebe483a3a2">slate::generate_matrix</a> (MatrixParams &amp;params, <a class="el" href="classslate_1_1_matrix.html">slate::Matrix</a>&lt; scalar_t &gt; &amp;A, std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;Sigma, slate::Options const &amp;opts)</td></tr>
<tr class="memdesc:ga71cf149080a7a29951dfbdebe483a3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an m-by-n test matrix.  <br /></td></tr>
<tr class="separator:ga71cf149080a7a29951dfbdebe483a3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5e6cbaa51360b934b3808cc8c1ed6e7"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:gad5e6cbaa51360b934b3808cc8c1ed6e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generate__matrix.html#gad5e6cbaa51360b934b3808cc8c1ed6e7">slate::generate_matrix</a> (MatrixParams &amp;params, <a class="el" href="classslate_1_1_base_trapezoid_matrix.html">slate::BaseTrapezoidMatrix</a>&lt; scalar_t &gt; &amp;A, std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;Sigma, slate::Options const &amp;opts)</td></tr>
<tr class="memdesc:gad5e6cbaa51360b934b3808cc8c1ed6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an m-by-n trapezoid-storage test matrix.  <br /></td></tr>
<tr class="separator:gad5e6cbaa51360b934b3808cc8c1ed6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5792d47de184565e7bf3ec5dd46136"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:gaac5792d47de184565e7bf3ec5dd46136"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generate__matrix.html#gaac5792d47de184565e7bf3ec5dd46136">slate::generate_matrix</a> (MatrixParams &amp;params, <a class="el" href="classslate_1_1_hermitian_matrix.html">slate::HermitianMatrix</a>&lt; scalar_t &gt; &amp;A, std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;Sigma, slate::Options const &amp;opts)</td></tr>
<tr class="memdesc:gaac5792d47de184565e7bf3ec5dd46136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an m-by-n Hermitian-storage test matrix.  <br /></td></tr>
<tr class="separator:gaac5792d47de184565e7bf3ec5dd46136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa240861b18e94b197b26cce51347e675"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:gaa240861b18e94b197b26cce51347e675"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generate__matrix.html#gaa240861b18e94b197b26cce51347e675">slate::generate_matrix</a> (MatrixParams &amp;params, <a class="el" href="classslate_1_1_matrix.html">slate::Matrix</a>&lt; scalar_t &gt; &amp;A, slate::Options const &amp;opts)</td></tr>
<tr class="memdesc:gaa240861b18e94b197b26cce51347e675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload without Sigma.  <br /></td></tr>
<tr class="separator:gaa240861b18e94b197b26cce51347e675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2b09d5e0d6b33facacf5b0c400eaed0"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:gab2b09d5e0d6b33facacf5b0c400eaed0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generate__matrix.html#gab2b09d5e0d6b33facacf5b0c400eaed0">slate::generate_matrix</a> (MatrixParams &amp;params, <a class="el" href="classslate_1_1_base_trapezoid_matrix.html">slate::BaseTrapezoidMatrix</a>&lt; scalar_t &gt; &amp;A, slate::Options const &amp;opts)</td></tr>
<tr class="memdesc:gab2b09d5e0d6b33facacf5b0c400eaed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload without Sigma.  <br /></td></tr>
<tr class="separator:gab2b09d5e0d6b33facacf5b0c400eaed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ee2f1a5c94df2afc99d06ab97361d7a"><td class="memTemplParams" colspan="2">template&lt;typename scalar_t &gt; </td></tr>
<tr class="memitem:ga6ee2f1a5c94df2afc99d06ab97361d7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__generate__matrix.html#ga6ee2f1a5c94df2afc99d06ab97361d7a">slate::generate_matrix</a> (MatrixParams &amp;params, <a class="el" href="classslate_1_1_hermitian_matrix.html">slate::HermitianMatrix</a>&lt; scalar_t &gt; &amp;A, slate::Options const &amp;opts)</td></tr>
<tr class="memdesc:ga6ee2f1a5c94df2afc99d06ab97361d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload without Sigma.  <br /></td></tr>
<tr class="separator:ga6ee2f1a5c94df2afc99d06ab97361d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad0855f4b6aba372f7e29051d29e41882" name="gad0855f4b6aba372f7e29051d29e41882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0855f4b6aba372f7e29051d29e41882">&#9670;&#160;</a></span>generate_geev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::generate_geev </td>
          <td>(</td>
          <td class="paramtype">MatrixParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TestMatrixDist&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt;&#160;</td>
          <td class="paramname"><em>sigma_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">slate::Matrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slate::Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates matrix using general eigenvalue decomposition, \(A = V T V^H\), with orthogonal eigenvectors. </p>
<p>Not yet implemented.</p>
<p>Internal function, called from <a class="el" href="group__generate__matrix.html#ga71cf149080a7a29951dfbdebe483a3a2" title="Generates an m-by-n test matrix.">generate_matrix()</a>. </p>

</div>
</div>
<a id="gaf1262f0ef9db6fd56febc73e7b86cdf6" name="gaf1262f0ef9db6fd56febc73e7b86cdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1262f0ef9db6fd56febc73e7b86cdf6">&#9670;&#160;</a></span>generate_geevx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::generate_geevx </td>
          <td>(</td>
          <td class="paramtype">MatrixParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TestMatrixDist&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt;&#160;</td>
          <td class="paramname"><em>sigma_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">slate::Matrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slate::Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates matrix using general eigenvalue decomposition, \(A = X T X^{-1}\), with random eigenvectors. </p>
<p>Not yet implemented.</p>
<p>Internal function, called from <a class="el" href="group__generate__matrix.html#ga71cf149080a7a29951dfbdebe483a3a2" title="Generates an m-by-n test matrix.">generate_matrix()</a>. </p>

</div>
</div>
<a id="ga191e107783c1013e57ecb365e3bc0c55" name="ga191e107783c1013e57ecb365e3bc0c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga191e107783c1013e57ecb365e3bc0c55">&#9670;&#160;</a></span>generate_heev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::generate_heev </td>
          <td>(</td>
          <td class="paramtype">MatrixParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TestMatrixDist&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rand_sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt;&#160;</td>
          <td class="paramname"><em>condD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt;&#160;</td>
          <td class="paramname"><em>sigma_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">slate::Matrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slate::Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates matrix using Hermitian eigenvalue decomposition, \(A = U Sigma U^H\). </p>
<p>Internal function, called from <a class="el" href="group__generate__matrix.html#ga71cf149080a7a29951dfbdebe483a3a2" title="Generates an m-by-n test matrix.">generate_matrix()</a>. </p>

</div>
</div>
<a id="gab2b09d5e0d6b33facacf5b0c400eaed0" name="gab2b09d5e0d6b33facacf5b0c400eaed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2b09d5e0d6b33facacf5b0c400eaed0">&#9670;&#160;</a></span>generate_matrix() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::generate_matrix </td>
          <td>(</td>
          <td class="paramtype">MatrixParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_base_trapezoid_matrix.html">slate::BaseTrapezoidMatrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slate::Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload without Sigma. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__generate__matrix.html#ga71cf149080a7a29951dfbdebe483a3a2" title="Generates an m-by-n test matrix.">generate_matrix()</a> </dd></dl>

</div>
</div>
<a id="gad5e6cbaa51360b934b3808cc8c1ed6e7" name="gad5e6cbaa51360b934b3808cc8c1ed6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5e6cbaa51360b934b3808cc8c1ed6e7">&#9670;&#160;</a></span>generate_matrix() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::generate_matrix </td>
          <td>(</td>
          <td class="paramtype">MatrixParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_base_trapezoid_matrix.html">slate::BaseTrapezoidMatrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slate::Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an m-by-n trapezoid-storage test matrix. </p>
<p>Handles Trapezoid, Triangular, Symmetric, and Hermitian matrices. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__generate__matrix.html#ga71cf149080a7a29951dfbdebe483a3a2" title="Generates an m-by-n test matrix.">generate_matrix</a> </dd></dl>

</div>
</div>
<a id="ga6ee2f1a5c94df2afc99d06ab97361d7a" name="ga6ee2f1a5c94df2afc99d06ab97361d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ee2f1a5c94df2afc99d06ab97361d7a">&#9670;&#160;</a></span>generate_matrix() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::generate_matrix </td>
          <td>(</td>
          <td class="paramtype">MatrixParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_hermitian_matrix.html">slate::HermitianMatrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slate::Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload without Sigma. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__generate__matrix.html#ga71cf149080a7a29951dfbdebe483a3a2" title="Generates an m-by-n test matrix.">generate_matrix()</a> </dd></dl>

</div>
</div>
<a id="gaac5792d47de184565e7bf3ec5dd46136" name="gaac5792d47de184565e7bf3ec5dd46136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac5792d47de184565e7bf3ec5dd46136">&#9670;&#160;</a></span>generate_matrix() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::generate_matrix </td>
          <td>(</td>
          <td class="paramtype">MatrixParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_hermitian_matrix.html">slate::HermitianMatrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slate::Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an m-by-n Hermitian-storage test matrix. </p>
<p>Handles Hermitian matrices. Diagonal elements of a Hermitian matrix must be real; their imaginary part must be 0. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__generate__matrix.html#ga71cf149080a7a29951dfbdebe483a3a2" title="Generates an m-by-n test matrix.">generate_matrix</a> </dd></dl>

</div>
</div>
<a id="gaa240861b18e94b197b26cce51347e675" name="gaa240861b18e94b197b26cce51347e675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa240861b18e94b197b26cce51347e675">&#9670;&#160;</a></span>generate_matrix() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::generate_matrix </td>
          <td>(</td>
          <td class="paramtype">MatrixParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">slate::Matrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slate::Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload without Sigma. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__generate__matrix.html#ga71cf149080a7a29951dfbdebe483a3a2" title="Generates an m-by-n test matrix.">generate_matrix()</a> </dd></dl>

</div>
</div>
<a id="ga71cf149080a7a29951dfbdebe483a3a2" name="ga71cf149080a7a29951dfbdebe483a3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71cf149080a7a29951dfbdebe483a3a2">&#9670;&#160;</a></span>generate_matrix() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::generate_matrix </td>
          <td>(</td>
          <td class="paramtype">MatrixParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">slate::Matrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slate::Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an m-by-n test matrix. </p>
<p>Similar to LAPACK's libtmg functionality, but a level 3 BLAS implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Test matrix parameters. Uses matrix, cond, condD parameters; see further details.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>Complex array, dimension (lda, n). On output, the m-by-n test matrix A in an lda-by-n array.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Sigma</td><td>Real array, dimension (min(m,n))<ul>
<li>On input with matrix distribution "_specified", contains user-specified singular or eigenvalues.</li>
<li>On output, contains singular or eigenvalues, if known, else set to NaN. Sigma is not necesarily sorted.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h3>Further Details</h3>
<p>The <b>matrix</b> parameter specifies the matrix kind according to the tables below. As indicated, kinds take an optional distribution suffix (^) and an optional scaling and modifier suffix (@). The default distribution is logrand. Examples: rand, rand_small, svd_arith, heev_geo_small.</p>
<p>The <b>cond</b> parameter specifies the condition number \(cond(S)\), where \(S\) is either the singular values \(\Sigma\) or the eigenvalues \(\Lambda\), as described by the distributions below. It does not apply to some matrices and distributions. For geev and geevx, cond(A) is generally much worse than cond(S). If _dominant is applied, cond(A) generally improves. By default, cond(S) = sqrt( 1/eps ) = 6.7e7 for double, 2.9e3 for single.</p>
<p>The <b>condD</b> parameter specifies the condition number cond(D), where D is a diagonal scaling matrix [1]. By default, condD = 1. If condD != 1, then:</p><ul>
<li>For matrix = svd, set \(A = A_0 K D\), where \(A_0 = U \Sigma V^H\), \(D\) has log-random entries in \([ \log(1/condD), \log(1) ]\), and \(K\) is diagonal such that columns of \(B = A_0 K\) have unit norm, hence \(B^T B\) has unit diagonal.</li>
<li>For matrix = heev, set \(A = D A_0 D\), where \(A_0 = U \Lambda U^H\), \(D\) has log-random entries in \([ \log(1/condD), \log(1) ]\). TODO: set \(A = D K A_0 K D\) where \(K\) is diagonal such that \(B = K A_0 K\) has unit diagonal.</li>
</ul>
<p>Note using condD changes the singular or eigenvalues of \(A\); on output, Sigma contains the singular or eigenvalues of \(A_0\), not of \(A\).</p>
<p>Notation used below: \(\Sigma\) is a diagonal matrix with entries \(\sigma_i\) for \(i = 1, \dots, n\); \(\Lambda\) is a diagonal matrix with entries \(\lambda_i = \pm \sigma_i\), with random sign; \(U\) and \(V\) are random orthogonal matrices from the Haar distribution [2], \(X\) is a random matrix.</p>
<p>See LAPACK Working Note (LAWN) 41:<br  />
Table 5 (Test matrices for the nonsymmetric eigenvalue problem)<br  />
Table 10 (Test matrices for the symmetric eigenvalue problem)<br  />
Table 11 (Test matrices for the singular value decomposition)</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><a class="el" href="classslate_1_1_matrix.html" title="General non-symmetric, m-by-n, distributed, tiled matrices.">Matrix</a>   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">zero   </td><td class="markdownTableBodyNone">all zero    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">one   </td><td class="markdownTableBodyNone">all one    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">identity   </td><td class="markdownTableBodyNone">ones on diagonal, rest zero    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">jordan   </td><td class="markdownTableBodyNone">ones on diagonal and first subdiagonal, rest zero    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">chebspec   </td><td class="markdownTableBodyNone">Nonsingular Chebyshev spectral differential matrix    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">circul   </td><td class="markdownTableBodyNone">A circulant matrix where the first column is [1, 2, ..., n]^T   </td></tr>
</table>
<p>fiedler | A matrix with entry i,j equal to |i - j| gfpp | A matrix with a growth factor of 1.5^n for gesv kms | Kac-Murdock-Szego Toeplitz matrix orthog | A matrix with entry i,j equal to sqrt(2/(n+1))sin(i*j*pi/(n+1)) riemann | A matrix with entry i,j equal to i+1 if j+2 divides i+2 elso -1 ris | A matrix with entry i,j equal to 0.5/(n-i-j+1.5) </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">zielkeNS   </th><th class="markdownTableHeadNone">A nonsymmetric matrix of Zielke    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">rand@   </td><td class="markdownTableBodyNone">matrix entries random uniform on (0, 1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">rands@   </td><td class="markdownTableBodyNone">matrix entries random uniform on (-1, 1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">randn@   </td><td class="markdownTableBodyNone">matrix entries random normal with mean 0, std 1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">randb@   </td><td class="markdownTableBodyNone">matrix entries random uniform in {0, 1}    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">randr@   </td><td class="markdownTableBodyNone">matrix entries random uniform in {-1, 1}    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">&ndash;   </td><td class="markdownTableBodyNone">&ndash;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">diag^@   </td><td class="markdownTableBodyNone">\(A = \Sigma\)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">svd^@   </td><td class="markdownTableBodyNone">\(A = U \Sigma V^H\)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">poev^@   </td><td class="markdownTableBodyNone">\(A = V \Sigma V^H\) (eigenvalues positive, i.e., matrix SPD)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">spd^@   </td><td class="markdownTableBodyNone">alias for poev    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">heev^@   </td><td class="markdownTableBodyNone">\(A = V \Lambda V^H\) (eigenvalues mixed signs)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">syev^@   </td><td class="markdownTableBodyNone">alias for heev    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">geev^@   </td><td class="markdownTableBodyNone">\(A = V T V^H\), Schur-form \(T\) [not yet implemented]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">geevx^@   </td><td class="markdownTableBodyNone">\(A = X T X^{-1}\), Schur-form \(T\), \(X\) ill-conditioned [not yet implemented]   </td></tr>
</table>
<p>Note for geev that \(cond(\Lambda)\) is specified, where \(\Lambda = diag(T)\); while \(cond(T)\) and \(cond(A)\) are usually much worse.</p>
<p>^ and @ denote optional suffixes described below.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">^ Distribution   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">_logrand   </td><td class="markdownTableBodyNone">\(\log(\sigma_i)\) random uniform on \([ \log(1/cond), \log(1) ]\); default    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">_arith   </td><td class="markdownTableBodyNone">\(\sigma_i = 1 - \frac{i - 1}{n - 1} (1 - 1/cond)\); arithmetic: \(\sigma_{i+1} - \sigma_i\) is constant    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">_geo   </td><td class="markdownTableBodyNone">\(\sigma_i = (cond)^{ -(i-1)/(n-1) }\); geometric: \(\sigma_{i+1} / \sigma_i\) is constant    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">_cluster0   </td><td class="markdownTableBodyNone">\(\Sigma = [ 1, 1/cond, ..., 1/cond ]\); 1 unit value, \(n-1\) small values    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">_cluster1   </td><td class="markdownTableBodyNone">\(\Sigma = [ 1, ..., 1, 1/cond ]\); \(n-1\) unit values, 1 small value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">_rarith   </td><td class="markdownTableBodyNone">_arith, reversed order    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">_rgeo   </td><td class="markdownTableBodyNone">_geo, reversed order    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">_rcluster0   </td><td class="markdownTableBodyNone">_cluster0, reversed order    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">_rcluster1   </td><td class="markdownTableBodyNone">_cluster1, reversed order    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">_specified   </td><td class="markdownTableBodyNone">user specified Sigma on input    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">&ndash;   </td><td class="markdownTableBodyNone">&ndash;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">_rand   </td><td class="markdownTableBodyNone">\(\sigma_i\) random uniform on (0, 1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">_rands   </td><td class="markdownTableBodyNone">\(\sigma_i\) random uniform on (-1, 1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">_randn   </td><td class="markdownTableBodyNone">\(\sigma_i\) random normal with mean 0, std 1   </td></tr>
</table>
<p>Note _rand, _rands, _randn do not use cond; the condition number is random.</p>
<p>Note for _rands and _randn, \(\Sigma\) contains negative values. This means poev_rands and poev_randn will not generate an SPD matrix.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">@ Scaling   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">_ufl   </td><td class="markdownTableBodyNone">scale near underflow = 1e-308 for double    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">_ofl   </td><td class="markdownTableBodyNone">scale near overflow = 2e+308 for double    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">_small   </td><td class="markdownTableBodyNone">scale near sqrt( underflow ) = 1e-154 for double    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">_large   </td><td class="markdownTableBodyNone">scale near sqrt( overflow  ) = 6e+153 for double   </td></tr>
</table>
<p>Note scaling changes the singular or eigenvalues, but not the condition number.</p>
<p>@ Modifier | Description -------------&mdash;|----------&mdash; _dominant | diagonally dominant: set \(A_{i,i} = \pm \max_i( \sum_j |A_{i,j}|, \sum_j |A_{j,i}| )\).</p>
<p>Note _dominant changes the singular or eigenvalues, and the condition number.</p>
<h3>References</h3>
<p>[1] Demmel and Veselic, Jacobi's method is more accurate than QR, 1992.</p>
<p>[2] Stewart, The efficient generation of random orthogonal matrices with an application to condition estimators, 1980. </p>

</div>
</div>
<a id="ga5b48bc88bfe5630fba45983b57a09aa9" name="ga5b48bc88bfe5630fba45983b57a09aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b48bc88bfe5630fba45983b57a09aa9">&#9670;&#160;</a></span>generate_sigma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename matrix_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::generate_sigma </td>
          <td>(</td>
          <td class="paramtype">MatrixParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TestMatrixDist&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rand_sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; typename matrix_type::value_type &gt;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; typename matrix_type::value_type &gt;&#160;</td>
          <td class="paramname"><em>sigma_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_type &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; blas::real_type&lt; typename matrix_type::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates Sigma vector of singular or eigenvalues, according to distribution. </p>
<p>Internal function, called from <a class="el" href="group__generate__matrix.html#ga71cf149080a7a29951dfbdebe483a3a2" title="Generates an m-by-n test matrix.">generate_matrix()</a>. </p>

</div>
</div>
<a id="ga04d99af123609cc307851e85aaad2aaa" name="ga04d99af123609cc307851e85aaad2aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04d99af123609cc307851e85aaad2aaa">&#9670;&#160;</a></span>generate_svd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename scalar_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void slate::generate_svd </td>
          <td>(</td>
          <td class="paramtype">MatrixParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TestMatrixDist&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt;&#160;</td>
          <td class="paramname"><em>condD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blas::real_type&lt; scalar_t &gt;&#160;</td>
          <td class="paramname"><em>sigma_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslate_1_1_matrix.html">slate::Matrix</a>&lt; scalar_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; blas::real_type&lt; scalar_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slate::Options const &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given matrix A with singular values such that sum(sigma_i^2) = n, returns A with columns of unit norm, with the same condition number. </p>
<p>see: Davies and Higham, 2000, Numerically stable generation of correlation matrices and their factors.</p>
<p>Internal function, called from <a class="el" href="group__generate__matrix.html#ga71cf149080a7a29951dfbdebe483a3a2" title="Generates an m-by-n test matrix.">generate_matrix()</a>. Generates matrix using SVD, \(A = U Sigma V^H\).</p>
<p>Internal function, called from <a class="el" href="group__generate__matrix.html#ga71cf149080a7a29951dfbdebe483a3a2" title="Generates an m-by-n test matrix.">generate_matrix()</a>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
